<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UploadRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prodDebug</a> &gt; <a href="index.source.html" class="el_package">fr.free.nrw.commons.repository</a> &gt; <span class="el_source">UploadRepository.java</span></div><h1>UploadRepository.java</h1><pre class="source lang-java linenums">package fr.free.nrw.commons.repository;

import androidx.annotation.Nullable;
import fr.free.nrw.commons.Media;
import fr.free.nrw.commons.category.CategoriesModel;
import fr.free.nrw.commons.category.CategoryItem;
import fr.free.nrw.commons.contributions.Contribution;
import fr.free.nrw.commons.contributions.ContributionDao;
import fr.free.nrw.commons.filepicker.UploadableFile;
import fr.free.nrw.commons.location.LatLng;
import fr.free.nrw.commons.nearby.NearbyPlaces;
import fr.free.nrw.commons.nearby.Place;
import fr.free.nrw.commons.upload.ImageCoordinates;
import fr.free.nrw.commons.upload.SimilarImageInterface;
import fr.free.nrw.commons.upload.UploadController;
import fr.free.nrw.commons.upload.UploadItem;
import fr.free.nrw.commons.upload.UploadModel;
import fr.free.nrw.commons.upload.structure.depictions.DepictModel;
import fr.free.nrw.commons.upload.structure.depictions.DepictedItem;
import io.reactivex.Flowable;
import io.reactivex.Observable;
import io.reactivex.Single;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import timber.log.Timber;

/**
 * The repository class for UploadActivity
 */
@Singleton
public class UploadRepository {

    private final UploadModel uploadModel;
    private final UploadController uploadController;
    private final CategoriesModel categoriesModel;
    private final NearbyPlaces nearbyPlaces;
    private final DepictModel depictModel;

    private static final double NEARBY_RADIUS_IN_KILO_METERS = 0.1; //100 meters
    private final ContributionDao contributionDao;

    @Inject
    public UploadRepository(UploadModel uploadModel,
        UploadController uploadController,
        CategoriesModel categoriesModel,
        NearbyPlaces nearbyPlaces,
        DepictModel depictModel,
<span class="nc" id="L53">        ContributionDao contributionDao) {</span>
<span class="nc" id="L54">        this.uploadModel = uploadModel;</span>
<span class="nc" id="L55">        this.uploadController = uploadController;</span>
<span class="nc" id="L56">        this.categoriesModel = categoriesModel;</span>
<span class="nc" id="L57">        this.nearbyPlaces = nearbyPlaces;</span>
<span class="nc" id="L58">        this.depictModel = depictModel;</span>
<span class="nc" id="L59">        this.contributionDao=contributionDao;</span>
<span class="nc" id="L60">    }</span>

    /**
     * asks the RemoteDataSource to build contributions
     *
     * @return
     */
    public Observable&lt;Contribution&gt; buildContributions() {
<span class="nc" id="L68">        return uploadModel.buildContributions();</span>
    }

    /**
     * asks the RemoteDataSource to start upload for the contribution
     *
     * @param contribution
     */

    public void prepareMedia(Contribution contribution) {
<span class="nc" id="L78">        uploadController.prepareMedia(contribution);</span>
<span class="nc" id="L79">    }</span>


    public void saveContribution(Contribution contribution) {
<span class="nc" id="L83">        contributionDao.save(contribution).blockingAwait();</span>
<span class="nc" id="L84">    }</span>

    /**
     * Fetches and returns all the Upload Items
     *
     * @return
     */
    public List&lt;UploadItem&gt; getUploads() {
<span class="nc" id="L92">        return uploadModel.getUploads();</span>
    }

    /**
     *Prepare for a fresh upload
     */
    public void cleanup() {
<span class="nc" id="L99">        uploadModel.cleanUp();</span>
        //This needs further refactoring, this should not be here, right now the structure wont suppoort rhis
<span class="nc" id="L101">        categoriesModel.cleanUp();</span>
<span class="nc" id="L102">        depictModel.cleanUp();</span>
<span class="nc" id="L103">    }</span>

    /**
     * Fetches and returns the selected categories for the current upload
     *
     * @return
     */
    public List&lt;CategoryItem&gt; getSelectedCategories() {
<span class="nc" id="L111">        return categoriesModel.getSelectedCategories();</span>
    }

    /**
     * all categories from MWApi
     *
     * @param query
     * @param imageTitleList
     * @param selectedDepictions
     * @return
     */
    public Observable&lt;List&lt;CategoryItem&gt;&gt; searchAll(String query, List&lt;String&gt; imageTitleList,
        List&lt;DepictedItem&gt; selectedDepictions) {
<span class="nc" id="L124">        return categoriesModel.searchAll(query, imageTitleList, selectedDepictions);</span>
    }

    /**
     * sets the list of selected categories for the current upload
     *
     * @param categoryStringList
     */
    public void setSelectedCategories(List&lt;String&gt; categoryStringList) {
<span class="nc" id="L133">        uploadModel.setSelectedCategories(categoryStringList);</span>
<span class="nc" id="L134">    }</span>

    /**
     * handles the category selection/deselection
     *
     * @param categoryItem
     */
    public void onCategoryClicked(CategoryItem categoryItem, final Media media) {
<span class="nc" id="L142">        categoriesModel.onCategoryItemClicked(categoryItem, media);</span>
<span class="nc" id="L143">    }</span>

    /**
     * prunes the category list for irrelevant categories see #750
     *
     * @param name
     * @return
     */
    public boolean containsYear(String name) {
<span class="nc" id="L152">        return categoriesModel.containsYear(name);</span>
    }

    /**
     * retursn the string list of available license from the LocalDataSource
     *
     * @return
     */
    public List&lt;String&gt; getLicenses() {
<span class="nc" id="L161">        return uploadModel.getLicenses();</span>
    }

    /**
     * returns the selected license for the current upload
     *
     * @return
     */
    public String getSelectedLicense() {
<span class="nc" id="L170">        return uploadModel.getSelectedLicense();</span>
    }

    /**
     * returns the number of Upload Items
     *
     * @return
     */
    public int getCount() {
<span class="nc" id="L179">        return uploadModel.getCount();</span>
    }

    /**
     * ask the RemoteDataSource to pre process the image
     *
     * @param uploadableFile
     * @param place
     * @param similarImageInterface
     * @return
     */
    public Observable&lt;UploadItem&gt; preProcessImage(UploadableFile uploadableFile, Place place,
        SimilarImageInterface similarImageInterface, LatLng inAppPictureLocation) {
<span class="nc" id="L192">        return uploadModel.preProcessImage(uploadableFile, place,</span>
            similarImageInterface, inAppPictureLocation);
    }

    /**
     * query the RemoteDataSource for image quality
     *
     * @param uploadItem
     * @return
     */
    public Single&lt;Integer&gt; getImageQuality(UploadItem uploadItem, LatLng location) {
<span class="nc" id="L203">        return uploadModel.getImageQuality(uploadItem, location);</span>
    }

    /**
     * asks the LocalDataSource to delete the file with the given file path
     *
     * @param filePath
     */
    public void deletePicture(String filePath) {
<span class="nc" id="L212">        uploadModel.deletePicture(filePath);</span>
<span class="nc" id="L213">    }</span>

    /**
     * fetches and returns the upload item
     *
     * @param index
     * @return
     */
    public UploadItem getUploadItem(int index) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (index &gt;= 0) {</span>
<span class="nc" id="L223">            return uploadModel.getItems().get(index);</span>
        }
<span class="nc" id="L225">        return null; //There is no item to copy details</span>
    }

    /**
     * set selected license for the current upload
     *
     * @param licenseName
     */
    public void setSelectedLicense(String licenseName) {
<span class="nc" id="L234">        uploadModel.setSelectedLicense(licenseName);</span>
<span class="nc" id="L235">    }</span>

    public void onDepictItemClicked(DepictedItem depictedItem, final Media media) {
<span class="nc" id="L238">        uploadModel.onDepictItemClicked(depictedItem, media);</span>
<span class="nc" id="L239">    }</span>

    /**
     * Fetches and returns the selected depictions for the current upload
     *
     * @return
     */

    public List&lt;DepictedItem&gt; getSelectedDepictions() {
<span class="nc" id="L248">        return uploadModel.getSelectedDepictions();</span>
    }

    /**
     * Provides selected existing depicts
     *
     * @return selected existing depicts
     */
    public List&lt;String&gt; getSelectedExistingDepictions() {
<span class="nc" id="L257">        return uploadModel.getSelectedExistingDepictions();</span>
    }

    /**
     * Initialize existing depicts
     *
     * @param selectedExistingDepictions existing depicts
     */
    public void setSelectedExistingDepictions(final List&lt;String&gt; selectedExistingDepictions) {
<span class="nc" id="L266">        uploadModel.setSelectedExistingDepictions(selectedExistingDepictions);</span>
<span class="nc" id="L267">    }</span>
    /**
     * Search all depictions from
     *
     * @param query
     * @return
     */

    public Flowable&lt;List&lt;DepictedItem&gt;&gt; searchAllEntities(String query) {
<span class="nc" id="L276">        return depictModel.searchAllEntities(query, this);</span>
    }

    /**
     * Gets the depiction for each unique {@link Place} associated with an {@link UploadItem}
     * from {@link #getUploads()}
     *
     * @return a single that provides the depictions
     */
    public Single&lt;List&lt;DepictedItem&gt;&gt; getPlaceDepictions() {
<span class="nc" id="L286">        final Set&lt;String&gt; qids = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (final UploadItem item : getUploads()) {</span>
<span class="nc" id="L288">            final Place place = item.getPlace();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (place != null) {</span>
<span class="nc" id="L290">                qids.add(place.getWikiDataEntityId());</span>
            }
<span class="nc" id="L292">        }</span>
<span class="nc" id="L293">        return depictModel.getPlaceDepictions(new ArrayList&lt;&gt;(qids));</span>
    }

    /**
     * Gets the category for each unique {@link Place} associated with an {@link UploadItem}
     * from {@link #getUploads()}
     *
     * @return a single that provides the categories
     */
    public Single&lt;List&lt;CategoryItem&gt;&gt; getPlaceCategories() {
<span class="nc" id="L303">        final Set&lt;String&gt; qids = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        for (final UploadItem item : getUploads()) {</span>
<span class="nc" id="L305">            final Place place = item.getPlace();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (place != null) {</span>
<span class="nc" id="L307">                qids.add(place.getCategory());</span>
            }
<span class="nc" id="L309">        }</span>
<span class="nc" id="L310">        return Single.fromObservable(categoriesModel.getCategoriesByName(new ArrayList&lt;&gt;(qids)));</span>
    }

    /**
     * Takes depict IDs as a parameter, converts into a slash separated String and Gets DepictItem
     * from the server
     *
     * @param depictionsQIDs IDs of Depiction
     * @return Flowable&lt;List&lt;DepictedItem&gt;&gt;
     */
    public Flowable&lt;List&lt;DepictedItem&gt;&gt; getDepictions(final List&lt;String&gt; depictionsQIDs){
<span class="nc" id="L321">        final String ids = joinQIDs(depictionsQIDs);</span>
<span class="nc" id="L322">        return depictModel.getDepictions(ids).toFlowable();</span>
    }

    /**
     * Builds a string by joining all IDs divided by &quot;|&quot;
     *
     * @param depictionsQIDs IDs of depiction ex. [&quot;Q11023&quot;,&quot;Q1356&quot;]
     * @return string ex. &quot;Q11023|Q1356&quot;
     */
    private String joinQIDs(final List&lt;String&gt; depictionsQIDs) {
<span class="nc bnc" id="L332" title="All 4 branches missed.">        if (depictionsQIDs != null &amp;&amp; !depictionsQIDs.isEmpty()) {</span>
<span class="nc" id="L333">            final StringBuilder buffer = new StringBuilder(depictionsQIDs.get(0));</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (depictionsQIDs.size() &gt; 1) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                for (int i = 1; i &lt; depictionsQIDs.size(); i++) {</span>
<span class="nc" id="L337">                    buffer.append(&quot;|&quot;);</span>
<span class="nc" id="L338">                    buffer.append(depictionsQIDs.get(i));</span>
                }
            }
<span class="nc" id="L341">            return buffer.toString();</span>
        }
<span class="nc" id="L343">        return null;</span>
    }

    /**
     * Returns nearest place matching the passed latitude and longitude
     * @param decLatitude
     * @param decLongitude
     * @return
     */
    @Nullable
    public Place checkNearbyPlaces(final double decLatitude, final double decLongitude) {
        try {
<span class="nc" id="L355">            final List&lt;Place&gt; fromWikidataQuery = nearbyPlaces.getFromWikidataQuery(new LatLng(</span>
                    decLatitude, decLongitude, 0.0f),
<span class="nc" id="L357">                    Locale.getDefault().getLanguage(),</span>
                    NEARBY_RADIUS_IN_KILO_METERS, false, null);
<span class="nc bnc" id="L359" title="All 4 branches missed.">            return (fromWikidataQuery != null &amp;&amp; fromWikidataQuery.size() &gt; 0) ? fromWikidataQuery</span>
<span class="nc" id="L360">                .get(0) : null;</span>
<span class="nc" id="L361">        }catch (final Exception e) {</span>
<span class="nc" id="L362">            Timber.e(&quot;Error fetching nearby places: %s&quot;, e.getMessage());</span>
<span class="nc" id="L363">            return null;</span>
        }
    }

    public void useSimilarPictureCoordinates(ImageCoordinates imageCoordinates, int uploadItemIndex) {
<span class="nc" id="L368">        uploadModel.useSimilarPictureCoordinates(imageCoordinates, uploadItemIndex);</span>
<span class="nc" id="L369">    }</span>

    public boolean isWMLSupportedForThisPlace() {
<span class="nc" id="L372">        return uploadModel.getItems().get(0).isWLMUpload();</span>
    }

    /**
     * Provides selected existing categories
     *
     * @return selected existing categories
     */
    public List&lt;String&gt; getSelectedExistingCategories() {
<span class="nc" id="L381">        return categoriesModel.getSelectedExistingCategories();</span>
    }

    /**
     * Initialize existing categories
     *
     * @param selectedExistingCategories existing categories
     */
    public void setSelectedExistingCategories(final List&lt;String&gt; selectedExistingCategories) {
<span class="nc" id="L390">        categoriesModel.setSelectedExistingCategories(selectedExistingCategories);</span>
<span class="nc" id="L391">    }</span>

    /**
     * Takes category names and Gets CategoryItem from the server
     *
     * @param categories names of Category
     * @return Observable&lt;List&lt;CategoryItem&gt;&gt;
     */
    public Observable&lt;List&lt;CategoryItem&gt;&gt; getCategories(final List&lt;String&gt; categories){
<span class="nc" id="L400">        return categoriesModel.getCategoriesByName(categories);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.0.2</div></body></html>