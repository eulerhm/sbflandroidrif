<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ZoomableDraweeView.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prodDebug</a> &gt; <a href="index.source.html" class="el_package">fr.free.nrw.commons.media.zoomControllers.zoomable</a> &gt; <span class="el_source">ZoomableDraweeView.java</span></div><h1>ZoomableDraweeView.java</h1><pre class="source lang-java linenums">package fr.free.nrw.commons.media.zoomControllers.zoomable;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.graphics.drawable.Animatable;
import android.util.AttributeSet;
import android.view.GestureDetector;
import android.view.MotionEvent;

import androidx.annotation.Nullable;
import androidx.core.view.ScrollingView;
import com.facebook.common.internal.Preconditions;
import com.facebook.common.logging.FLog;
import com.facebook.drawee.controller.AbstractDraweeController;
import com.facebook.drawee.controller.BaseControllerListener;
import com.facebook.drawee.controller.ControllerListener;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.drawee.generic.GenericDraweeHierarchy;
import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
import com.facebook.drawee.generic.GenericDraweeHierarchyInflater;
import com.facebook.drawee.interfaces.DraweeController;
import com.facebook.drawee.view.DraweeView;


/**
 * DraweeView that has zoomable capabilities.
 *
 * &lt;p&gt;Once the image loads, pinch-to-zoom and translation gestures are enabled.
 */
public class ZoomableDraweeView extends DraweeView&lt;GenericDraweeHierarchy&gt;
        implements ScrollingView {

<span class="nc" id="L36">    private static final Class&lt;?&gt; TAG = ZoomableDraweeView.class;</span>

    private static final float HUGE_IMAGE_SCALE_FACTOR_THRESHOLD = 1.1f;

<span class="nc" id="L40">    private final RectF mImageBounds = new RectF();</span>
<span class="nc" id="L41">    private final RectF mViewBounds = new RectF();</span>

    private DraweeController mHugeImageController;
    private ZoomableController mZoomableController;
    private GestureDetector mTapGestureDetector;
<span class="nc" id="L46">    private boolean mAllowTouchInterceptionWhileZoomed = true;</span>

<span class="nc" id="L48">    private boolean mIsDialtoneEnabled = false;</span>
<span class="nc" id="L49">    private boolean mZoomingEnabled = true;</span>
    private TransformationListener transformationListener;

<span class="nc" id="L52">    private final ControllerListener mControllerListener =</span>
<span class="nc" id="L53">            new BaseControllerListener&lt;Object&gt;() {</span>
                @Override
                public void onFinalImageSet(
                        String id, @Nullable Object imageInfo, @Nullable Animatable animatable) {
<span class="nc" id="L57">                    ZoomableDraweeView.this.onFinalImageSet();</span>
<span class="nc" id="L58">                }</span>

                @Override
                public void onRelease(String id) {
<span class="nc" id="L62">                    ZoomableDraweeView.this.onRelease();</span>
<span class="nc" id="L63">                }</span>
            };

<span class="nc" id="L66">    private final ZoomableController.Listener mZoomableListener =</span>
<span class="nc" id="L67">            new ZoomableController.Listener() {</span>
                @Override
<span class="nc" id="L69">                public void onTransformBegin(Matrix transform) {}</span>

                @Override
                public void onTransformChanged(Matrix transform) {
<span class="nc" id="L73">                    ZoomableDraweeView.this.onTransformChanged(transform);</span>
<span class="nc" id="L74">                }</span>

                @Override
                public void onTransformEnd(Matrix transform) {
<span class="nc bnc" id="L78" title="All 2 branches missed.">                    if (null != transformationListener) {</span>
<span class="nc" id="L79">                        transformationListener.onTransformationEnd();</span>
                    }
<span class="nc" id="L81">                }</span>
            };

    public void setTransformationListener(
        TransformationListener transformationListener) {
<span class="nc" id="L86">        this.transformationListener = transformationListener;</span>
<span class="nc" id="L87">    }</span>

<span class="nc" id="L89">    private final GestureListenerWrapper mTapListenerWrapper = new GestureListenerWrapper();</span>

    public ZoomableDraweeView(Context context, GenericDraweeHierarchy hierarchy) {
<span class="nc" id="L92">        super(context);</span>
<span class="nc" id="L93">        setHierarchy(hierarchy);</span>
<span class="nc" id="L94">        init();</span>
<span class="nc" id="L95">    }</span>

    public ZoomableDraweeView(Context context) {
<span class="nc" id="L98">        super(context);</span>
<span class="nc" id="L99">        inflateHierarchy(context, null);</span>
<span class="nc" id="L100">        init();</span>
<span class="nc" id="L101">    }</span>

    public ZoomableDraweeView(Context context, AttributeSet attrs) {
<span class="nc" id="L104">        super(context, attrs);</span>
<span class="nc" id="L105">        inflateHierarchy(context, attrs);</span>
<span class="nc" id="L106">        init();</span>
<span class="nc" id="L107">    }</span>

    public ZoomableDraweeView(Context context, AttributeSet attrs, int defStyle) {
<span class="nc" id="L110">        super(context, attrs, defStyle);</span>
<span class="nc" id="L111">        inflateHierarchy(context, attrs);</span>
<span class="nc" id="L112">        init();</span>
<span class="nc" id="L113">    }</span>

    protected void inflateHierarchy(Context context, @Nullable AttributeSet attrs) {
<span class="nc" id="L116">        Resources resources = context.getResources();</span>
<span class="nc" id="L117">        GenericDraweeHierarchyBuilder builder =</span>
                new GenericDraweeHierarchyBuilder(resources)
<span class="nc" id="L119">                        .setActualImageScaleType(ScalingUtils.ScaleType.FIT_CENTER);</span>
<span class="nc" id="L120">        GenericDraweeHierarchyInflater.updateBuilder(builder, context, attrs);</span>
<span class="nc" id="L121">        setAspectRatio(builder.getDesiredAspectRatio());</span>
<span class="nc" id="L122">        setHierarchy(builder.build());</span>
<span class="nc" id="L123">    }</span>

    private void init() {
<span class="nc" id="L126">        mZoomableController = createZoomableController();</span>
<span class="nc" id="L127">        mZoomableController.setListener(mZoomableListener);</span>
<span class="nc" id="L128">        mTapGestureDetector = new GestureDetector(getContext(), mTapListenerWrapper);</span>
<span class="nc" id="L129">    }</span>

    public void setIsDialtoneEnabled(boolean isDialtoneEnabled) {
<span class="nc" id="L132">        mIsDialtoneEnabled = isDialtoneEnabled;</span>
<span class="nc" id="L133">    }</span>

    /**
     * Gets the original image bounds, in view-absolute coordinates.
     *
     * &lt;p&gt;The original image bounds are those reported by the hierarchy. The hierarchy itself may
     * apply scaling on its own (e.g. due to scale type) so the reported bounds are not necessarily
     * the same as the actual bitmap dimensions. In other words, the original image bounds correspond
     * to the image bounds within this view when no zoomable transformation is applied, but including
     * the potential scaling of the hierarchy. Having the actual bitmap dimensions abstracted away
     * from this view greatly simplifies implementation because the actual bitmap may change (e.g.
     * when a high-res image arrives and replaces the previously set low-res image). With proper
     * hierarchy scaling (e.g. FIT_CENTER), this underlying change will not affect this view nor the
     * zoomable transformation in any way.
     */
    protected void getImageBounds(RectF outBounds) {
<span class="nc" id="L149">        getHierarchy().getActualImageBounds(outBounds);</span>
<span class="nc" id="L150">    }</span>

    /**
     * Gets the bounds used to limit the translation, in view-absolute coordinates.
     *
     * &lt;p&gt;These bounds are passed to the zoomable controller in order to limit the translation. The
     * image is attempted to be centered within the limit bounds if the transformed image is smaller.
     * There will be no empty spaces within the limit bounds if the transformed image is bigger. This
     * applies to each dimension (horizontal and vertical) independently.
     *
     * &lt;p&gt;Unless overridden by a subclass, these bounds are same as the view bounds.
     */
    protected void getLimitBounds(RectF outBounds) {
<span class="nc" id="L163">        outBounds.set(0, 0, getWidth(), getHeight());</span>
<span class="nc" id="L164">    }</span>

    /** Sets a custom zoomable controller, instead of using the default one. */
    public void setZoomableController(ZoomableController zoomableController) {
<span class="nc" id="L168">        Preconditions.checkNotNull(zoomableController);</span>
<span class="nc" id="L169">        mZoomableController.setListener(null);</span>
<span class="nc" id="L170">        mZoomableController = zoomableController;</span>
<span class="nc" id="L171">        mZoomableController.setListener(mZoomableListener);</span>
<span class="nc" id="L172">    }</span>

    /**
     * Gets the zoomable controller.
     *
     * &lt;p&gt;Zoomable controller can be used to zoom to point, or to map point from view to image
     * coordinates for instance.
     */
    public ZoomableController getZoomableController() {
<span class="nc" id="L181">        return mZoomableController;</span>
    }

    /**
     * Check whether the parent view can intercept touch events while zoomed. This can be used, for
     * example, to swipe between images in a view pager while zoomed.
     *
     * @return true if touch events can be intercepted
     */
    public boolean allowsTouchInterceptionWhileZoomed() {
<span class="nc" id="L191">        return mAllowTouchInterceptionWhileZoomed;</span>
    }

    /**
     * If this is set to true, parent views can intercept touch events while the view is zoomed. For
     * example, this can be used to swipe between images in a view pager while zoomed.
     *
     * @param allowTouchInterceptionWhileZoomed true if the parent needs to intercept touches
     */
    public void setAllowTouchInterceptionWhileZoomed(boolean allowTouchInterceptionWhileZoomed) {
<span class="nc" id="L201">        mAllowTouchInterceptionWhileZoomed = allowTouchInterceptionWhileZoomed;</span>
<span class="nc" id="L202">    }</span>

    /** Sets the tap listener. */
    public void setTapListener(GestureDetector.SimpleOnGestureListener tapListener) {
<span class="nc" id="L206">        mTapListenerWrapper.setListener(tapListener);</span>
<span class="nc" id="L207">    }</span>

    /**
     * Sets whether long-press tap detection is enabled. Unfortunately, long-press conflicts with
     * onDoubleTapEvent.
     */
    public void setIsLongpressEnabled(boolean enabled) {
<span class="nc" id="L214">        mTapGestureDetector.setIsLongpressEnabled(enabled);</span>
<span class="nc" id="L215">    }</span>

    public void setZoomingEnabled(boolean zoomingEnabled) {
<span class="nc" id="L218">        mZoomingEnabled = zoomingEnabled;</span>
<span class="nc" id="L219">        mZoomableController.setEnabled(false);</span>
<span class="nc" id="L220">    }</span>

    /** Sets the image controller. */
    @Override
    public void setController(@Nullable DraweeController controller) {
<span class="nc" id="L225">        setControllers(controller, null);</span>
<span class="nc" id="L226">    }</span>

    /**
     * Sets the controllers for the normal and huge image.
     *
     * &lt;p&gt;The huge image controller is used after the image gets scaled above a certain threshold.
     *
     * &lt;p&gt;IMPORTANT: in order to avoid a flicker when switching to the huge image, the huge image
     * controller should have the normal-image-uri set as its low-res-uri.
     *
     * @param controller controller to be initially used
     * @param hugeImageController controller to be used after the client starts zooming-in
     */
    public void setControllers(
            @Nullable DraweeController controller, @Nullable DraweeController hugeImageController) {
<span class="nc" id="L241">        setControllersInternal(null, null);</span>
<span class="nc" id="L242">        mZoomableController.setEnabled(false);</span>
<span class="nc" id="L243">        setControllersInternal(controller, hugeImageController);</span>
<span class="nc" id="L244">    }</span>

    private void setControllersInternal(
            @Nullable DraweeController controller, @Nullable DraweeController hugeImageController) {
<span class="nc" id="L248">        removeControllerListener(getController());</span>
<span class="nc" id="L249">        addControllerListener(controller);</span>
<span class="nc" id="L250">        mHugeImageController = hugeImageController;</span>
<span class="nc" id="L251">        super.setController(controller);</span>
<span class="nc" id="L252">    }</span>

    private void maybeSetHugeImageController() {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (mHugeImageController != null</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">                &amp;&amp; mZoomableController.getScaleFactor() &gt; HUGE_IMAGE_SCALE_FACTOR_THRESHOLD) {</span>
<span class="nc" id="L257">            setControllersInternal(mHugeImageController, null);</span>
        }
<span class="nc" id="L259">    }</span>

    private void removeControllerListener(DraweeController controller) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (controller instanceof AbstractDraweeController) {</span>
<span class="nc" id="L263">            ((AbstractDraweeController) controller).removeControllerListener(mControllerListener);</span>
        }
<span class="nc" id="L265">    }</span>

    private void addControllerListener(DraweeController controller) {
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (controller instanceof AbstractDraweeController) {</span>
<span class="nc" id="L269">            ((AbstractDraweeController) controller).addControllerListener(mControllerListener);</span>
        }
<span class="nc" id="L271">    }</span>

    @Override
    protected void onDraw(Canvas canvas) {
<span class="nc" id="L275">        int saveCount = canvas.save();</span>
<span class="nc" id="L276">        canvas.concat(mZoomableController.getTransform());</span>
        try {
<span class="nc" id="L278">            super.onDraw(canvas);</span>
<span class="nc" id="L279">        } catch (Exception e) {</span>
<span class="nc" id="L280">            DraweeController controller = getController();</span>
<span class="nc bnc" id="L281" title="All 4 branches missed.">            if (controller != null &amp;&amp; controller instanceof AbstractDraweeController) {</span>
<span class="nc" id="L282">                Object callerContext = ((AbstractDraweeController) controller).getCallerContext();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                if (callerContext != null) {</span>
<span class="nc" id="L284">                    throw new RuntimeException(</span>
<span class="nc" id="L285">                            String.format(&quot;Exception in onDraw, callerContext=%s&quot;, callerContext.toString()), e);</span>
                }
            }
<span class="nc" id="L288">            throw e;</span>
<span class="nc" id="L289">        }</span>
<span class="nc" id="L290">        canvas.restoreToCount(saveCount);</span>
<span class="nc" id="L291">    }</span>

    @Override
    public boolean onTouchEvent(MotionEvent event) {
<span class="nc" id="L295">        int a = event.getActionMasked();</span>
<span class="nc" id="L296">        FLog.v(getLogTag(), &quot;onTouchEvent: %d, view %x, received&quot;, a, this.hashCode());</span>
<span class="nc bnc" id="L297" title="All 4 branches missed.">        if (!mIsDialtoneEnabled &amp;&amp; mTapGestureDetector.onTouchEvent(event)) {</span>
<span class="nc" id="L298">            FLog.v(</span>
<span class="nc" id="L299">                    getLogTag(),</span>
                    &quot;onTouchEvent: %d, view %x, handled by tap gesture detector&quot;,
<span class="nc" id="L301">                    a,</span>
<span class="nc" id="L302">                    this.hashCode());</span>
<span class="nc" id="L303">            return true;</span>
        }

<span class="nc bnc" id="L306" title="All 4 branches missed.">        if (!mIsDialtoneEnabled &amp;&amp; mZoomableController.onTouchEvent(event)) {</span>
<span class="nc" id="L307">            FLog.v(</span>
<span class="nc" id="L308">                    getLogTag(),</span>
                    &quot;onTouchEvent: %d, view %x, handled by zoomable controller&quot;,
<span class="nc" id="L310">                    a,</span>
<span class="nc" id="L311">                    this.hashCode());</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">            if (!mAllowTouchInterceptionWhileZoomed &amp;&amp; !mZoomableController.isIdentity()) {</span>
<span class="nc" id="L313">                getParent().requestDisallowInterceptTouchEvent(true);</span>
            }
<span class="nc" id="L315">            return true;</span>
        }
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (super.onTouchEvent(event)) {</span>
<span class="nc" id="L318">            FLog.v(getLogTag(), &quot;onTouchEvent: %d, view %x, handled by the super&quot;, a, this.hashCode());</span>
<span class="nc" id="L319">            return true;</span>
        }
        // None of our components reported that they handled the touch event. Upon returning false
        // from this method, our parent won't send us any more events for this gesture. Unfortunately,
        // some components may have started a delayed action, such as a long-press timer, and since we
        // won't receive an ACTION_UP that would cancel that timer, a false event may be triggered.
        // To prevent that we explicitly send one last cancel event when returning false.
<span class="nc" id="L326">        MotionEvent cancelEvent = MotionEvent.obtain(event);</span>
<span class="nc" id="L327">        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);</span>
<span class="nc" id="L328">        mTapGestureDetector.onTouchEvent(cancelEvent);</span>
<span class="nc" id="L329">        mZoomableController.onTouchEvent(cancelEvent);</span>
<span class="nc" id="L330">        cancelEvent.recycle();</span>
<span class="nc" id="L331">        return false;</span>
    }

    @Override
    public int computeHorizontalScrollRange() {
<span class="nc" id="L336">        return mZoomableController.computeHorizontalScrollRange();</span>
    }

    @Override
    public int computeHorizontalScrollOffset() {
<span class="nc" id="L341">        return mZoomableController.computeHorizontalScrollOffset();</span>
    }

    @Override
    public int computeHorizontalScrollExtent() {
<span class="nc" id="L346">        return mZoomableController.computeHorizontalScrollExtent();</span>
    }

    @Override
    public int computeVerticalScrollRange() {
<span class="nc" id="L351">        return mZoomableController.computeVerticalScrollRange();</span>
    }

    @Override
    public int computeVerticalScrollOffset() {
<span class="nc" id="L356">        return mZoomableController.computeVerticalScrollOffset();</span>
    }

    @Override
    public int computeVerticalScrollExtent() {
<span class="nc" id="L361">        return mZoomableController.computeVerticalScrollExtent();</span>
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
<span class="nc" id="L366">        FLog.v(getLogTag(), &quot;onLayout: view %x&quot;, this.hashCode());</span>
<span class="nc" id="L367">        super.onLayout(changed, left, top, right, bottom);</span>
<span class="nc" id="L368">        updateZoomableControllerBounds();</span>
<span class="nc" id="L369">    }</span>

    private void onFinalImageSet() {
<span class="nc" id="L372">        FLog.v(getLogTag(), &quot;onFinalImageSet: view %x&quot;, this.hashCode());</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">        if (!mZoomableController.isEnabled() &amp;&amp; mZoomingEnabled) {</span>
<span class="nc" id="L374">            mZoomableController.setEnabled(true);</span>
<span class="nc" id="L375">            updateZoomableControllerBounds();</span>
        }
<span class="nc" id="L377">    }</span>

    private void onRelease() {
<span class="nc" id="L380">        FLog.v(getLogTag(), &quot;onRelease: view %x&quot;, this.hashCode());</span>
<span class="nc" id="L381">        mZoomableController.setEnabled(false);</span>
<span class="nc" id="L382">    }</span>

    protected void onTransformChanged(Matrix transform) {
<span class="nc" id="L385">        FLog.v(getLogTag(), &quot;onTransformChanged: view %x, transform: %s&quot;, this.hashCode(), transform);</span>
<span class="nc" id="L386">        maybeSetHugeImageController();</span>
<span class="nc" id="L387">        invalidate();</span>
<span class="nc" id="L388">    }</span>

    protected void updateZoomableControllerBounds() {
<span class="nc" id="L391">        getImageBounds(mImageBounds);</span>
<span class="nc" id="L392">        getLimitBounds(mViewBounds);</span>
<span class="nc" id="L393">        mZoomableController.setImageBounds(mImageBounds);</span>
<span class="nc" id="L394">        mZoomableController.setViewBounds(mViewBounds);</span>
<span class="nc" id="L395">        FLog.v(</span>
<span class="nc" id="L396">                getLogTag(),</span>
                &quot;updateZoomableControllerBounds: view %x, view bounds: %s, image bounds: %s&quot;,
<span class="nc" id="L398">                this.hashCode(),</span>
                mViewBounds,
                mImageBounds);
<span class="nc" id="L401">    }</span>

    protected Class&lt;?&gt; getLogTag() {
<span class="nc" id="L404">        return TAG;</span>
    }

    protected ZoomableController createZoomableController() {
<span class="nc" id="L408">        return AnimatedZoomableController.newInstance();</span>
    }

    /**
     * Use this, If someone is willing to listen to scale change
     */
    public interface TransformationListener{
        void onTransformationEnd();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.0.2</div></body></html>