<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultZoomableController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prodDebug</a> &gt; <a href="index.source.html" class="el_package">fr.free.nrw.commons.media.zoomControllers.zoomable</a> &gt; <span class="el_source">DefaultZoomableController.java</span></div><h1>DefaultZoomableController.java</h1><pre class="source lang-java linenums">package fr.free.nrw.commons.media.zoomControllers.zoomable;

import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.RectF;
import android.view.MotionEvent;
import androidx.annotation.IntDef;
import androidx.annotation.Nullable;
import fr.free.nrw.commons.media.zoomControllers.gestures.TransformGestureDetector;
import com.facebook.common.logging.FLog;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/** Zoomable controller that calculates transformation based on touch events. */
public class DefaultZoomableController
        implements ZoomableController, TransformGestureDetector.Listener {

    /** Interface for handling call backs when the image bounds are set. */
    public interface ImageBoundsListener {
        void onImageBoundsSet(RectF imageBounds);
    }

    @IntDef(
            flag = true,
            value = {LIMIT_NONE, LIMIT_TRANSLATION_X, LIMIT_TRANSLATION_Y, LIMIT_SCALE, LIMIT_ALL})
    @Retention(RetentionPolicy.SOURCE)
    public @interface LimitFlag {}

    public static final int LIMIT_NONE = 0;
    public static final int LIMIT_TRANSLATION_X = 1;
    public static final int LIMIT_TRANSLATION_Y = 2;
    public static final int LIMIT_SCALE = 4;
    public static final int LIMIT_ALL = LIMIT_TRANSLATION_X | LIMIT_TRANSLATION_Y | LIMIT_SCALE;

    private static final float EPS = 1e-3f;

<span class="nc" id="L37">    private static final Class&lt;?&gt; TAG = DefaultZoomableController.class;</span>

<span class="nc" id="L39">    private static final RectF IDENTITY_RECT = new RectF(0, 0, 1, 1);</span>

    private TransformGestureDetector mGestureDetector;

    private @Nullable ImageBoundsListener mImageBoundsListener;

<span class="nc" id="L45">    private @Nullable Listener mListener = null;</span>

<span class="nc" id="L47">    private boolean mIsEnabled = false;</span>
<span class="nc" id="L48">    private boolean mIsRotationEnabled = false;</span>
<span class="nc" id="L49">    private boolean mIsScaleEnabled = true;</span>
<span class="nc" id="L50">    private boolean mIsTranslationEnabled = true;</span>
<span class="nc" id="L51">    private boolean mIsGestureZoomEnabled = true;</span>

<span class="nc" id="L53">    private float mMinScaleFactor = 1.0f;</span>
<span class="nc" id="L54">    private float mMaxScaleFactor = 2.0f;</span>

    // View bounds, in view-absolute coordinates
<span class="nc" id="L57">    private final RectF mViewBounds = new RectF();</span>
    // Non-transformed image bounds, in view-absolute coordinates
<span class="nc" id="L59">    private final RectF mImageBounds = new RectF();</span>
    // Transformed image bounds, in view-absolute coordinates
<span class="nc" id="L61">    private final RectF mTransformedImageBounds = new RectF();</span>

<span class="nc" id="L63">    private final Matrix mPreviousTransform = new Matrix();</span>
<span class="nc" id="L64">    private final Matrix mActiveTransform = new Matrix();</span>
<span class="nc" id="L65">    private final Matrix mActiveTransformInverse = new Matrix();</span>
<span class="nc" id="L66">    private final float[] mTempValues = new float[9];</span>
<span class="nc" id="L67">    private final RectF mTempRect = new RectF();</span>
    private boolean mWasTransformCorrected;

    public static DefaultZoomableController newInstance() {
<span class="nc" id="L71">        return new DefaultZoomableController(TransformGestureDetector.newInstance());</span>
    }

<span class="nc" id="L74">    public DefaultZoomableController(TransformGestureDetector gestureDetector) {</span>
<span class="nc" id="L75">        mGestureDetector = gestureDetector;</span>
<span class="nc" id="L76">        mGestureDetector.setListener(this);</span>
<span class="nc" id="L77">    }</span>

    /** Rests the controller. */
    public void reset() {
<span class="nc" id="L81">        FLog.v(TAG, &quot;reset&quot;);</span>
<span class="nc" id="L82">        mGestureDetector.reset();</span>
<span class="nc" id="L83">        mPreviousTransform.reset();</span>
<span class="nc" id="L84">        mActiveTransform.reset();</span>
<span class="nc" id="L85">        onTransformChanged();</span>
<span class="nc" id="L86">    }</span>

    /** Sets the zoomable listener. */
    @Override
    public void setListener(Listener listener) {
<span class="nc" id="L91">        mListener = listener;</span>
<span class="nc" id="L92">    }</span>

    /** Sets whether the controller is enabled or not. */
    @Override
    public void setEnabled(boolean enabled) {
<span class="nc" id="L97">        mIsEnabled = enabled;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (!enabled) {</span>
<span class="nc" id="L99">            reset();</span>
        }
<span class="nc" id="L101">    }</span>

    /** Gets whether the controller is enabled or not. */
    @Override
    public boolean isEnabled() {
<span class="nc" id="L106">        return mIsEnabled;</span>
    }

    /** Sets whether the rotation gesture is enabled or not. */
    public void setRotationEnabled(boolean enabled) {
<span class="nc" id="L111">        mIsRotationEnabled = enabled;</span>
<span class="nc" id="L112">    }</span>

    /** Gets whether the rotation gesture is enabled or not. */
    public boolean isRotationEnabled() {
<span class="nc" id="L116">        return mIsRotationEnabled;</span>
    }

    /** Sets whether the scale gesture is enabled or not. */
    public void setScaleEnabled(boolean enabled) {
<span class="nc" id="L121">        mIsScaleEnabled = enabled;</span>
<span class="nc" id="L122">    }</span>

    /** Gets whether the scale gesture is enabled or not. */
    public boolean isScaleEnabled() {
<span class="nc" id="L126">        return mIsScaleEnabled;</span>
    }

    /** Sets whether the translation gesture is enabled or not. */
    public void setTranslationEnabled(boolean enabled) {
<span class="nc" id="L131">        mIsTranslationEnabled = enabled;</span>
<span class="nc" id="L132">    }</span>

    /** Gets whether the translations gesture is enabled or not. */
    public boolean isTranslationEnabled() {
<span class="nc" id="L136">        return mIsTranslationEnabled;</span>
    }

    /**
     * Sets the minimum scale factor allowed.
     *
     * &lt;p&gt;Hierarchy's scaling (if any) is not taken into account.
     */
    public void setMinScaleFactor(float minScaleFactor) {
<span class="nc" id="L145">        mMinScaleFactor = minScaleFactor;</span>
<span class="nc" id="L146">    }</span>

    /** Gets the minimum scale factor allowed. */
    public float getMinScaleFactor() {
<span class="nc" id="L150">        return mMinScaleFactor;</span>
    }

    /**
     * Sets the maximum scale factor allowed.
     *
     * &lt;p&gt;Hierarchy's scaling (if any) is not taken into account.
     */
    public void setMaxScaleFactor(float maxScaleFactor) {
<span class="nc" id="L159">        mMaxScaleFactor = maxScaleFactor;</span>
<span class="nc" id="L160">    }</span>

    /** Gets the maximum scale factor allowed. */
    public float getMaxScaleFactor() {
<span class="nc" id="L164">        return mMaxScaleFactor;</span>
    }

    /** Sets whether gesture zooms are enabled or not. */
    public void setGestureZoomEnabled(boolean isGestureZoomEnabled) {
<span class="nc" id="L169">        mIsGestureZoomEnabled = isGestureZoomEnabled;</span>
<span class="nc" id="L170">    }</span>

    /** Gets whether gesture zooms are enabled or not. */
    public boolean isGestureZoomEnabled() {
<span class="nc" id="L174">        return mIsGestureZoomEnabled;</span>
    }

    /** Gets the current scale factor. */
    @Override
    public float getScaleFactor() {
<span class="nc" id="L180">        return getMatrixScaleFactor(mActiveTransform);</span>
    }

    /** Sets the image bounds, in view-absolute coordinates. */
    @Override
    public void setImageBounds(RectF imageBounds) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (!imageBounds.equals(mImageBounds)) {</span>
<span class="nc" id="L187">            mImageBounds.set(imageBounds);</span>
<span class="nc" id="L188">            onTransformChanged();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (mImageBoundsListener != null) {</span>
<span class="nc" id="L190">                mImageBoundsListener.onImageBoundsSet(mImageBounds);</span>
            }
        }
<span class="nc" id="L193">    }</span>

    /** Gets the non-transformed image bounds, in view-absolute coordinates. */
    public RectF getImageBounds() {
<span class="nc" id="L197">        return mImageBounds;</span>
    }

    /** Gets the transformed image bounds, in view-absolute coordinates */
    private RectF getTransformedImageBounds() {
<span class="nc" id="L202">        return mTransformedImageBounds;</span>
    }

    /** Sets the view bounds. */
    @Override
    public void setViewBounds(RectF viewBounds) {
<span class="nc" id="L208">        mViewBounds.set(viewBounds);</span>
<span class="nc" id="L209">    }</span>

    /** Gets the view bounds. */
    public RectF getViewBounds() {
<span class="nc" id="L213">        return mViewBounds;</span>
    }

    /** Sets the image bounds listener. */
    public void setImageBoundsListener(@Nullable ImageBoundsListener imageBoundsListener) {
<span class="nc" id="L218">        mImageBoundsListener = imageBoundsListener;</span>
<span class="nc" id="L219">    }</span>

    /** Gets the image bounds listener. */
    public @Nullable ImageBoundsListener getImageBoundsListener() {
<span class="nc" id="L223">        return mImageBoundsListener;</span>
    }

    /** Returns true if the zoomable transform is identity matrix. */
    @Override
    public boolean isIdentity() {
<span class="nc" id="L229">        return isMatrixIdentity(mActiveTransform, 1e-3f);</span>
    }

    /**
     * Returns true if the transform was corrected during the last update.
     *
     * &lt;p&gt;We should rename this method to `wasTransformedWithoutCorrection` and just return the
     * internal flag directly. However, this requires interface change and negation of meaning.
     */
    @Override
    public boolean wasTransformCorrected() {
<span class="nc" id="L240">        return mWasTransformCorrected;</span>
    }

    /**
     * Gets the matrix that transforms image-absolute coordinates to view-absolute coordinates. The
     * zoomable transformation is taken into account.
     *
     * &lt;p&gt;Internal matrix is exposed for performance reasons and is not to be modified by the callers.
     */
    @Override
    public Matrix getTransform() {
<span class="nc" id="L251">        return mActiveTransform;</span>
    }

    /**
     * Gets the matrix that transforms image-relative coordinates to view-absolute coordinates. The
     * zoomable transformation is taken into account.
     */
    public void getImageRelativeToViewAbsoluteTransform(Matrix outMatrix) {
<span class="nc" id="L259">        outMatrix.setRectToRect(IDENTITY_RECT, mTransformedImageBounds, Matrix.ScaleToFit.FILL);</span>
<span class="nc" id="L260">    }</span>

    /**
     * Maps point from view-absolute to image-relative coordinates. This takes into account the
     * zoomable transformation.
     */
    public PointF mapViewToImage(PointF viewPoint) {
<span class="nc" id="L267">        float[] points = mTempValues;</span>
<span class="nc" id="L268">        points[0] = viewPoint.x;</span>
<span class="nc" id="L269">        points[1] = viewPoint.y;</span>
<span class="nc" id="L270">        mActiveTransform.invert(mActiveTransformInverse);</span>
<span class="nc" id="L271">        mActiveTransformInverse.mapPoints(points, 0, points, 0, 1);</span>
<span class="nc" id="L272">        mapAbsoluteToRelative(points, points, 1);</span>
<span class="nc" id="L273">        return new PointF(points[0], points[1]);</span>
    }

    /**
     * Maps point from image-relative to view-absolute coordinates. This takes into account the
     * zoomable transformation.
     */
    public PointF mapImageToView(PointF imagePoint) {
<span class="nc" id="L281">        float[] points = mTempValues;</span>
<span class="nc" id="L282">        points[0] = imagePoint.x;</span>
<span class="nc" id="L283">        points[1] = imagePoint.y;</span>
<span class="nc" id="L284">        mapRelativeToAbsolute(points, points, 1);</span>
<span class="nc" id="L285">        mActiveTransform.mapPoints(points, 0, points, 0, 1);</span>
<span class="nc" id="L286">        return new PointF(points[0], points[1]);</span>
    }

    /**
     * Maps array of 2D points from view-absolute to image-relative coordinates. This does NOT take
     * into account the zoomable transformation. Points are represented by a float array of [x0, y0,
     * x1, y1, ...].
     *
     * @param destPoints destination array (may be the same as source array)
     * @param srcPoints source array
     * @param numPoints number of points to map
     */
    private void mapAbsoluteToRelative(float[] destPoints, float[] srcPoints, int numPoints) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int i = 0; i &lt; numPoints; i++) {</span>
<span class="nc" id="L300">            destPoints[i * 2 + 0] = (srcPoints[i * 2 + 0] - mImageBounds.left) / mImageBounds.width();</span>
<span class="nc" id="L301">            destPoints[i * 2 + 1] = (srcPoints[i * 2 + 1] - mImageBounds.top) / mImageBounds.height();</span>
        }
<span class="nc" id="L303">    }</span>

    /**
     * Maps array of 2D points from image-relative to view-absolute coordinates. This does NOT take
     * into account the zoomable transformation. Points are represented by float array of [x0, y0, x1,
     * y1, ...].
     *
     * @param destPoints destination array (may be the same as source array)
     * @param srcPoints source array
     * @param numPoints number of points to map
     */
    private void mapRelativeToAbsolute(float[] destPoints, float[] srcPoints, int numPoints) {
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (int i = 0; i &lt; numPoints; i++) {</span>
<span class="nc" id="L316">            destPoints[i * 2 + 0] = srcPoints[i * 2 + 0] * mImageBounds.width() + mImageBounds.left;</span>
<span class="nc" id="L317">            destPoints[i * 2 + 1] = srcPoints[i * 2 + 1] * mImageBounds.height() + mImageBounds.top;</span>
        }
<span class="nc" id="L319">    }</span>

    /**
     * Zooms to the desired scale and positions the image so that the given image point corresponds to
     * the given view point.
     *
     * @param scale desired scale, will be limited to {min, max} scale factor
     * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 &lt;= x, y &lt;= 1)
     * @param viewPoint 2D point in view's absolute coordinate system
     */
    public void zoomToPoint(float scale, PointF imagePoint, PointF viewPoint) {
<span class="nc" id="L330">        FLog.v(TAG, &quot;zoomToPoint&quot;);</span>
<span class="nc" id="L331">        calculateZoomToPointTransform(mActiveTransform, scale, imagePoint, viewPoint, LIMIT_ALL);</span>
<span class="nc" id="L332">        onTransformChanged();</span>
<span class="nc" id="L333">    }</span>

    /**
     * Calculates the zoom transformation that would zoom to the desired scale and position the image
     * so that the given image point corresponds to the given view point.
     *
     * @param outTransform the matrix to store the result to
     * @param scale desired scale, will be limited to {min, max} scale factor
     * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 &lt;= x, y &lt;= 1)
     * @param viewPoint 2D point in view's absolute coordinate system
     * @param limitFlags whether to limit translation and/or scale.
     * @return whether or not the transform has been corrected due to limitation
     */
    protected boolean calculateZoomToPointTransform(
            Matrix outTransform,
            float scale,
            PointF imagePoint,
            PointF viewPoint,
            @LimitFlag int limitFlags) {
<span class="nc" id="L352">        float[] viewAbsolute = mTempValues;</span>
<span class="nc" id="L353">        viewAbsolute[0] = imagePoint.x;</span>
<span class="nc" id="L354">        viewAbsolute[1] = imagePoint.y;</span>
<span class="nc" id="L355">        mapRelativeToAbsolute(viewAbsolute, viewAbsolute, 1);</span>
<span class="nc" id="L356">        float distanceX = viewPoint.x - viewAbsolute[0];</span>
<span class="nc" id="L357">        float distanceY = viewPoint.y - viewAbsolute[1];</span>
<span class="nc" id="L358">        boolean transformCorrected = false;</span>
<span class="nc" id="L359">        outTransform.setScale(scale, scale, viewAbsolute[0], viewAbsolute[1]);</span>
<span class="nc" id="L360">        transformCorrected |= limitScale(outTransform, viewAbsolute[0], viewAbsolute[1], limitFlags);</span>
<span class="nc" id="L361">        outTransform.postTranslate(distanceX, distanceY);</span>
<span class="nc" id="L362">        transformCorrected |= limitTranslation(outTransform, limitFlags);</span>
<span class="nc" id="L363">        return transformCorrected;</span>
    }

    /** Sets a new zoom transformation. */
    public void setTransform(Matrix newTransform) {
<span class="nc" id="L368">        FLog.v(TAG, &quot;setTransform&quot;);</span>
<span class="nc" id="L369">        mActiveTransform.set(newTransform);</span>
<span class="nc" id="L370">        onTransformChanged();</span>
<span class="nc" id="L371">    }</span>

    /** Gets the gesture detector. */
    protected TransformGestureDetector getDetector() {
<span class="nc" id="L375">        return mGestureDetector;</span>
    }

    /** Notifies controller of the received touch event. */
    @Override
    public boolean onTouchEvent(MotionEvent event) {
<span class="nc" id="L381">        FLog.v(TAG, &quot;onTouchEvent: action: &quot;, event.getAction());</span>
<span class="nc bnc" id="L382" title="All 4 branches missed.">        if (mIsEnabled &amp;&amp; mIsGestureZoomEnabled) {</span>
<span class="nc" id="L383">            return mGestureDetector.onTouchEvent(event);</span>
        }
<span class="nc" id="L385">        return false;</span>
    }

    /* TransformGestureDetector.Listener methods  */

    @Override
    public void onGestureBegin(TransformGestureDetector detector) {
<span class="nc" id="L392">        FLog.v(TAG, &quot;onGestureBegin&quot;);</span>
<span class="nc" id="L393">        mPreviousTransform.set(mActiveTransform);</span>
<span class="nc" id="L394">        onTransformBegin();</span>
        // We only received a touch down event so far, and so we don't know yet in which direction a
        // future move event will follow. Therefore, if we can't scroll in all directions, we have to
        // assume the worst case where the user tries to scroll out of edge, which would cause
        // transformation to be corrected.
<span class="nc bnc" id="L399" title="All 2 branches missed.">        mWasTransformCorrected = !canScrollInAllDirection();</span>
<span class="nc" id="L400">    }</span>

    @Override
    public void onGestureUpdate(TransformGestureDetector detector) {
<span class="nc" id="L404">        FLog.v(TAG, &quot;onGestureUpdate&quot;);</span>
<span class="nc" id="L405">        boolean transformCorrected = calculateGestureTransform(mActiveTransform, LIMIT_ALL);</span>
<span class="nc" id="L406">        onTransformChanged();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (transformCorrected) {</span>
<span class="nc" id="L408">            mGestureDetector.restartGesture();</span>
        }
        // A transformation happened, but was it without correction?
<span class="nc" id="L411">        mWasTransformCorrected = transformCorrected;</span>
<span class="nc" id="L412">    }</span>

    @Override
    public void onGestureEnd(TransformGestureDetector detector) {
<span class="nc" id="L416">        FLog.v(TAG, &quot;onGestureEnd&quot;);</span>
<span class="nc" id="L417">        onTransformEnd();</span>
<span class="nc" id="L418">    }</span>

    /**
     * Calculates the zoom transformation based on the current gesture.
     *
     * @param outTransform the matrix to store the result to
     * @param limitTypes whether to limit translation and/or scale.
     * @return whether or not the transform has been corrected due to limitation
     */
    protected boolean calculateGestureTransform(Matrix outTransform, @LimitFlag int limitTypes) {
<span class="nc" id="L428">        TransformGestureDetector detector = mGestureDetector;</span>
<span class="nc" id="L429">        boolean transformCorrected = false;</span>
<span class="nc" id="L430">        outTransform.set(mPreviousTransform);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (mIsRotationEnabled) {</span>
<span class="nc" id="L432">            float angle = detector.getRotation() * (float) (180 / Math.PI);</span>
<span class="nc" id="L433">            outTransform.postRotate(angle, detector.getPivotX(), detector.getPivotY());</span>
        }
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (mIsScaleEnabled) {</span>
<span class="nc" id="L436">            float scale = detector.getScale();</span>
<span class="nc" id="L437">            outTransform.postScale(scale, scale, detector.getPivotX(), detector.getPivotY());</span>
        }
<span class="nc" id="L439">        transformCorrected |=</span>
<span class="nc" id="L440">                limitScale(outTransform, detector.getPivotX(), detector.getPivotY(), limitTypes);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (mIsTranslationEnabled) {</span>
<span class="nc" id="L442">            outTransform.postTranslate(detector.getTranslationX(), detector.getTranslationY());</span>
        }
<span class="nc" id="L444">        transformCorrected |= limitTranslation(outTransform, limitTypes);</span>
<span class="nc" id="L445">        return transformCorrected;</span>
    }

    private void onTransformBegin() {
<span class="nc bnc" id="L449" title="All 4 branches missed.">        if (mListener != null &amp;&amp; isEnabled()) {</span>
<span class="nc" id="L450">            mListener.onTransformBegin(mActiveTransform);</span>
        }
<span class="nc" id="L452">    }</span>

    private void onTransformChanged() {
<span class="nc" id="L455">        mActiveTransform.mapRect(mTransformedImageBounds, mImageBounds);</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">        if (mListener != null &amp;&amp; isEnabled()) {</span>
<span class="nc" id="L457">            mListener.onTransformChanged(mActiveTransform);</span>
        }
<span class="nc" id="L459">    }</span>

    private void onTransformEnd() {
<span class="nc bnc" id="L462" title="All 4 branches missed.">        if (mListener != null &amp;&amp; isEnabled()) {</span>
<span class="nc" id="L463">            mListener.onTransformEnd(mActiveTransform);</span>
        }
<span class="nc" id="L465">    }</span>

    /**
     * Keeps the scaling factor within the specified limits.
     *
     * @param pivotX x coordinate of the pivot point
     * @param pivotY y coordinate of the pivot point
     * @param limitTypes whether to limit scale.
     * @return whether limiting has been applied or not
     */
    private boolean limitScale(
            Matrix transform, float pivotX, float pivotY, @LimitFlag int limitTypes) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (!shouldLimit(limitTypes, LIMIT_SCALE)) {</span>
<span class="nc" id="L478">            return false;</span>
        }
<span class="nc" id="L480">        float currentScale = getMatrixScaleFactor(transform);</span>
<span class="nc" id="L481">        float targetScale = limit(currentScale, mMinScaleFactor, mMaxScaleFactor);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (targetScale != currentScale) {</span>
<span class="nc" id="L483">            float scale = targetScale / currentScale;</span>
<span class="nc" id="L484">            transform.postScale(scale, scale, pivotX, pivotY);</span>
<span class="nc" id="L485">            return true;</span>
        }
<span class="nc" id="L487">        return false;</span>
    }

    /**
     * Limits the translation so that there are no empty spaces on the sides if possible.
     *
     * &lt;p&gt;The image is attempted to be centered within the view bounds if the transformed image is
     * smaller. There will be no empty spaces within the view bounds if the transformed image is
     * bigger. This applies to each dimension (horizontal and vertical) independently.
     *
     * @param limitTypes whether to limit translation along the specific axis.
     * @return whether limiting has been applied or not
     */
    private boolean limitTranslation(Matrix transform, @LimitFlag int limitTypes) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (!shouldLimit(limitTypes, LIMIT_TRANSLATION_X | LIMIT_TRANSLATION_Y)) {</span>
<span class="nc" id="L502">            return false;</span>
        }
<span class="nc" id="L504">        RectF b = mTempRect;</span>
<span class="nc" id="L505">        b.set(mImageBounds);</span>
<span class="nc" id="L506">        transform.mapRect(b);</span>
        float offsetLeft =
<span class="nc bnc" id="L508" title="All 2 branches missed.">                shouldLimit(limitTypes, LIMIT_TRANSLATION_X)</span>
<span class="nc" id="L509">                        ? getOffset(</span>
<span class="nc" id="L510">                        b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX())</span>
<span class="nc" id="L511">                        : 0;</span>
        float offsetTop =
<span class="nc bnc" id="L513" title="All 2 branches missed.">                shouldLimit(limitTypes, LIMIT_TRANSLATION_Y)</span>
<span class="nc" id="L514">                        ? getOffset(</span>
<span class="nc" id="L515">                        b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY())</span>
<span class="nc" id="L516">                        : 0;</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">        if (offsetLeft != 0 || offsetTop != 0) {</span>
<span class="nc" id="L518">            transform.postTranslate(offsetLeft, offsetTop);</span>
<span class="nc" id="L519">            return true;</span>
        }
<span class="nc" id="L521">        return false;</span>
    }

    /**
     * Checks whether the specified limit flag is present in the limits provided.
     *
     * &lt;p&gt;If the flag contains multiple flags together using a bitwise OR, this only checks that at
     * least one of the flags is included.
     *
     * @param limits the limits to apply
     * @param flag the limit flag(s) to check for
     * @return true if the flag (or one of the flags) is included in the limits
     */
    private static boolean shouldLimit(@LimitFlag int limits, @LimitFlag int flag) {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        return (limits &amp; flag) != LIMIT_NONE;</span>
    }

    /**
     * Returns the offset necessary to make sure that: - the image is centered within the limit if the
     * image is smaller than the limit - there is no empty space on left/right if the image is bigger
     * than the limit
     */
    private float getOffset(
            float imageStart, float imageEnd, float limitStart, float limitEnd, float limitCenter) {
<span class="nc" id="L545">        float imageWidth = imageEnd - imageStart, limitWidth = limitEnd - limitStart;</span>
<span class="nc" id="L546">        float limitInnerWidth = Math.min(limitCenter - limitStart, limitEnd - limitCenter) * 2;</span>
        // center if smaller than limitInnerWidth
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (imageWidth &lt; limitInnerWidth) {</span>
<span class="nc" id="L549">            return limitCenter - (imageEnd + imageStart) / 2;</span>
        }
        // to the edge if in between and limitCenter is not (limitLeft + limitRight) / 2
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (imageWidth &lt; limitWidth) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (limitCenter &lt; (limitStart + limitEnd) / 2) {</span>
<span class="nc" id="L554">                return limitStart - imageStart;</span>
            } else {
<span class="nc" id="L556">                return limitEnd - imageEnd;</span>
            }
        }
        // to the edge if larger than limitWidth and empty space visible
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (imageStart &gt; limitStart) {</span>
<span class="nc" id="L561">            return limitStart - imageStart;</span>
        }
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (imageEnd &lt; limitEnd) {</span>
<span class="nc" id="L564">            return limitEnd - imageEnd;</span>
        }
<span class="nc" id="L566">        return 0;</span>
    }

    /** Limits the value to the given min and max range. */
    private float limit(float value, float min, float max) {
<span class="nc" id="L571">        return Math.min(Math.max(min, value), max);</span>
    }

    /**
     * Gets the scale factor for the given matrix. This method assumes the equal scaling factor for X
     * and Y axis.
     */
    private float getMatrixScaleFactor(Matrix transform) {
<span class="nc" id="L579">        transform.getValues(mTempValues);</span>
<span class="nc" id="L580">        return mTempValues[Matrix.MSCALE_X];</span>
    }

    /** Same as {@code Matrix.isIdentity()}, but with tolerance {@code eps}. */
    private boolean isMatrixIdentity(Matrix transform, float eps) {
        // Checks whether the given matrix is close enough to the identity matrix:
        //   1 0 0
        //   0 1 0
        //   0 0 1
        // Or equivalently to the zero matrix, after subtracting 1.0f from the diagonal elements:
        //   0 0 0
        //   0 0 0
        //   0 0 0
<span class="nc" id="L593">        transform.getValues(mTempValues);</span>
<span class="nc" id="L594">        mTempValues[0] -= 1.0f; // m00</span>
<span class="nc" id="L595">        mTempValues[4] -= 1.0f; // m11</span>
<span class="nc" id="L596">        mTempValues[8] -= 1.0f; // m22</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        for (int i = 0; i &lt; 9; i++) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (Math.abs(mTempValues[i]) &gt; eps) {</span>
<span class="nc" id="L599">                return false;</span>
            }
        }
<span class="nc" id="L602">        return true;</span>
    }

    /** Returns whether the scroll can happen in all directions. I.e. the image is not on any edge. */
    private boolean canScrollInAllDirection() {
<span class="nc bnc" id="L607" title="All 8 branches missed.">        return mTransformedImageBounds.left &lt; mViewBounds.left - EPS</span>
                &amp;&amp; mTransformedImageBounds.top &lt; mViewBounds.top - EPS
                &amp;&amp; mTransformedImageBounds.right &gt; mViewBounds.right + EPS
                &amp;&amp; mTransformedImageBounds.bottom &gt; mViewBounds.bottom + EPS;
    }

    @Override
    public int computeHorizontalScrollRange() {
<span class="nc" id="L615">        return (int) mTransformedImageBounds.width();</span>
    }

    @Override
    public int computeHorizontalScrollOffset() {
<span class="nc" id="L620">        return (int) (mViewBounds.left - mTransformedImageBounds.left);</span>
    }

    @Override
    public int computeHorizontalScrollExtent() {
<span class="nc" id="L625">        return (int) mViewBounds.width();</span>
    }

    @Override
    public int computeVerticalScrollRange() {
<span class="nc" id="L630">        return (int) mTransformedImageBounds.height();</span>
    }

    @Override
    public int computeVerticalScrollOffset() {
<span class="nc" id="L635">        return (int) (mViewBounds.top - mTransformedImageBounds.top);</span>
    }

    @Override
    public int computeVerticalScrollExtent() {
<span class="nc" id="L640">        return (int) mViewBounds.height();</span>
    }

    public Listener getListener() {
<span class="nc" id="L644">        return mListener;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.0.2</div></body></html>