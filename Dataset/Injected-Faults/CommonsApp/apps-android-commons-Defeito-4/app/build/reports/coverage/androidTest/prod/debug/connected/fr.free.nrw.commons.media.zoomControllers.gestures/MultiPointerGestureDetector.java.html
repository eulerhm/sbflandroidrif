<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultiPointerGestureDetector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prodDebug</a> &gt; <a href="index.source.html" class="el_package">fr.free.nrw.commons.media.zoomControllers.gestures</a> &gt; <span class="el_source">MultiPointerGestureDetector.java</span></div><h1>MultiPointerGestureDetector.java</h1><pre class="source lang-java linenums">package fr.free.nrw.commons.media.zoomControllers.gestures;

import android.view.MotionEvent;

/**
 * Component that detects and tracks multiple pointers based on touch events.
 *
 * Each time a pointer gets pressed or released, the current gesture (if any) will end, and a new
 * one will be started (if there are still pressed pointers left). It is guaranteed that the number
 * of pointers within the single gesture will remain the same during the whole gesture.
 */
public class MultiPointerGestureDetector {

    /** The listener for receiving notifications when gestures occur. */
    public interface Listener {
        /** A callback called right before the gesture is about to start. */
        public void onGestureBegin(MultiPointerGestureDetector detector);

        /** A callback called each time the gesture gets updated. */
        public void onGestureUpdate(MultiPointerGestureDetector detector);

        /** A callback called right after the gesture has finished. */
        public void onGestureEnd(MultiPointerGestureDetector detector);
    }

    private static final int MAX_POINTERS = 2;

    private boolean mGestureInProgress;
    private int mPointerCount;
    private int mNewPointerCount;
<span class="nc" id="L31">    private final int mId[] = new int[MAX_POINTERS];</span>
<span class="nc" id="L32">    private final float mStartX[] = new float[MAX_POINTERS];</span>
<span class="nc" id="L33">    private final float mStartY[] = new float[MAX_POINTERS];</span>
<span class="nc" id="L34">    private final float mCurrentX[] = new float[MAX_POINTERS];</span>
<span class="nc" id="L35">    private final float mCurrentY[] = new float[MAX_POINTERS];</span>

<span class="nc" id="L37">    private Listener mListener = null;</span>

<span class="nc" id="L39">    public MultiPointerGestureDetector() {</span>
<span class="nc" id="L40">        reset();</span>
<span class="nc" id="L41">    }</span>

    /** Factory method that creates a new instance of MultiPointerGestureDetector */
    public static MultiPointerGestureDetector newInstance() {
<span class="nc" id="L45">        return new MultiPointerGestureDetector();</span>
    }

    /**
     * Sets the listener.
     *
     * @param listener listener to set
     */
    public void setListener(Listener listener) {
<span class="nc" id="L54">        mListener = listener;</span>
<span class="nc" id="L55">    }</span>

    /** Resets the component to the initial state. */
    public void reset() {
<span class="nc" id="L59">        mGestureInProgress = false;</span>
<span class="nc" id="L60">        mPointerCount = 0;</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">        for (int i = 0; i &lt; MAX_POINTERS; i++) {</span>
<span class="nc" id="L62">            mId[i] = MotionEvent.INVALID_POINTER_ID;</span>
        }
<span class="nc" id="L64">    }</span>

    /**
     * This method can be overridden in order to perform threshold check or something similar.
     *
     * @return whether or not to start a new gesture
     */
    protected boolean shouldStartGesture() {
<span class="nc" id="L72">        return true;</span>
    }

    /** Starts a new gesture and calls the listener just before starting it. */
    private void startGesture() {
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (!mGestureInProgress) {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (mListener != null) {</span>
<span class="nc" id="L79">                mListener.onGestureBegin(this);</span>
            }
<span class="nc" id="L81">            mGestureInProgress = true;</span>
        }
<span class="nc" id="L83">    }</span>

    /** Stops the current gesture and calls the listener right after stopping it. */
    private void stopGesture() {
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (mGestureInProgress) {</span>
<span class="nc" id="L88">            mGestureInProgress = false;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (mListener != null) {</span>
<span class="nc" id="L90">                mListener.onGestureEnd(this);</span>
            }
        }
<span class="nc" id="L93">    }</span>

    /**
     * Gets the index of the i-th pressed pointer. Normally, the index will be equal to i, except in
     * the case when the pointer is released.
     *
     * @return index of the specified pointer or -1 if not found (i.e. not enough pointers are down)
     */
    private int getPressedPointerIndex(MotionEvent event, int i) {
<span class="nc" id="L102">        final int count = event.getPointerCount();</span>
<span class="nc" id="L103">        final int action = event.getActionMasked();</span>
<span class="nc" id="L104">        final int index = event.getActionIndex();</span>
<span class="nc bnc" id="L105" title="All 4 branches missed.">        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP) {</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">            if (i &gt;= index) {</span>
<span class="nc" id="L107">                i++;</span>
            }
        }
<span class="nc bnc" id="L110" title="All 2 branches missed.">        return (i &lt; count) ? i : -1;</span>
    }

    /** Gets the number of pressed pointers (fingers down). */
    private static int getPressedPointerCount(MotionEvent event) {
<span class="nc" id="L115">        int count = event.getPointerCount();</span>
<span class="nc" id="L116">        int action = event.getActionMasked();</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP) {</span>
<span class="nc" id="L118">            count--;</span>
        }
<span class="nc" id="L120">        return count;</span>
    }

    private void updatePointersOnTap(MotionEvent event) {
<span class="nc" id="L124">        mPointerCount = 0;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        for (int i = 0; i &lt; MAX_POINTERS; i++) {</span>
<span class="nc" id="L126">            int index = getPressedPointerIndex(event, i);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L128">                mId[i] = MotionEvent.INVALID_POINTER_ID;</span>
            } else {
<span class="nc" id="L130">                mId[i] = event.getPointerId(index);</span>
<span class="nc" id="L131">                mCurrentX[i] = mStartX[i] = event.getX(index);</span>
<span class="nc" id="L132">                mCurrentY[i] = mStartY[i] = event.getY(index);</span>
<span class="nc" id="L133">                mPointerCount++;</span>
            }
        }
<span class="nc" id="L136">    }</span>

    private void updatePointersOnMove(MotionEvent event) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (int i = 0; i &lt; MAX_POINTERS; i++) {</span>
<span class="nc" id="L140">            int index = event.findPointerIndex(mId[i]);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (index != -1) {</span>
<span class="nc" id="L142">                mCurrentX[i] = event.getX(index);</span>
<span class="nc" id="L143">                mCurrentY[i] = event.getY(index);</span>
            }
        }
<span class="nc" id="L146">    }</span>

    /**
     * Handles the given motion event.
     *
     * @param event event to handle
     * @return whether or not the event was handled
     */
    public boolean onTouchEvent(final MotionEvent event) {
<span class="nc bnc" id="L155" title="All 4 branches missed.">        switch (event.getActionMasked()) {</span>
            case MotionEvent.ACTION_MOVE:
            {
                // update pointers
<span class="nc" id="L159">                updatePointersOnMove(event);</span>
                // start a new gesture if not already started
<span class="nc bnc" id="L161" title="All 6 branches missed.">                if (!mGestureInProgress &amp;&amp; mPointerCount &gt; 0 &amp;&amp; shouldStartGesture()) {</span>
<span class="nc" id="L162">                    startGesture();</span>
                }
                // notify listener
<span class="nc bnc" id="L165" title="All 4 branches missed.">                if (mGestureInProgress &amp;&amp; mListener != null) {</span>
<span class="nc" id="L166">                    mListener.onGestureUpdate(this);</span>
                }
                break;
            }

            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_POINTER_DOWN:
            case MotionEvent.ACTION_POINTER_UP:
            case MotionEvent.ACTION_UP:
            {
                // restart gesture whenever the number of pointers changes
<span class="nc" id="L177">                mNewPointerCount = getPressedPointerCount(event);</span>
<span class="nc" id="L178">                stopGesture();</span>
<span class="nc" id="L179">                updatePointersOnTap(event);</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">                if (mPointerCount &gt; 0 &amp;&amp; shouldStartGesture()) {</span>
<span class="nc" id="L181">                    startGesture();</span>
                }
                break;
            }

            case MotionEvent.ACTION_CANCEL:
            {
<span class="nc" id="L188">                mNewPointerCount = 0;</span>
<span class="nc" id="L189">                stopGesture();</span>
<span class="nc" id="L190">                reset();</span>
                break;
            }
        }
<span class="nc" id="L194">        return true;</span>
    }

    /** Restarts the current gesture (if any). */
    public void restartGesture() {
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (!mGestureInProgress) {</span>
<span class="nc" id="L200">            return;</span>
        }
<span class="nc" id="L202">        stopGesture();</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (int i = 0; i &lt; MAX_POINTERS; i++) {</span>
<span class="nc" id="L204">            mStartX[i] = mCurrentX[i];</span>
<span class="nc" id="L205">            mStartY[i] = mCurrentY[i];</span>
        }
<span class="nc" id="L207">        startGesture();</span>
<span class="nc" id="L208">    }</span>

    /** Gets whether there is a gesture in progress */
    public boolean isGestureInProgress() {
<span class="nc" id="L212">        return mGestureInProgress;</span>
    }

    /** Gets the number of pointers after the current gesture */
    public int getNewPointerCount() {
<span class="nc" id="L217">        return mNewPointerCount;</span>
    }

    /** Gets the number of pointers in the current gesture */
    public int getPointerCount() {
<span class="nc" id="L222">        return mPointerCount;</span>
    }

    /**
     * Gets the start X coordinates for the all pointers Mutable array is exposed for performance
     * reasons and is not to be modified by the callers.
     */
    public float[] getStartX() {
<span class="nc" id="L230">        return mStartX;</span>
    }

    /**
     * Gets the start Y coordinates for the all pointers Mutable array is exposed for performance
     * reasons and is not to be modified by the callers.
     */
    public float[] getStartY() {
<span class="nc" id="L238">        return mStartY;</span>
    }

    /**
     * Gets the current X coordinates for the all pointers Mutable array is exposed for performance
     * reasons and is not to be modified by the callers.
     */
    public float[] getCurrentX() {
<span class="nc" id="L246">        return mCurrentX;</span>
    }

    /**
     * Gets the current Y coordinates for the all pointers Mutable array is exposed for performance
     * reasons and is not to be modified by the callers.
     */
    public float[] getCurrentY() {
<span class="nc" id="L254">        return mCurrentY;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.0.2</div></body></html>