<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NearbyController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prodDebug</a> &gt; <a href="index.source.html" class="el_package">fr.free.nrw.commons.nearby</a> &gt; <span class="el_source">NearbyController.java</span></div><h1>NearbyController.java</h1><pre class="source lang-java linenums">package fr.free.nrw.commons.nearby;

import static fr.free.nrw.commons.utils.LengthUtils.computeDistanceBetween;
import static fr.free.nrw.commons.utils.LengthUtils.formatDistanceBetween;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import androidx.annotation.MainThread;
import androidx.annotation.Nullable;
import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;
import com.mapbox.mapboxsdk.annotations.IconFactory;
import com.mapbox.mapboxsdk.annotations.Marker;

import fr.free.nrw.commons.MapController;
import fr.free.nrw.commons.R;
import fr.free.nrw.commons.location.LatLng;
import fr.free.nrw.commons.utils.UiUtils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import javax.inject.Inject;
import timber.log.Timber;

import static fr.free.nrw.commons.utils.LengthUtils.computeDistanceBetween;
import static fr.free.nrw.commons.utils.LengthUtils.formatDistanceBetween;

public class NearbyController extends MapController {

    private static final int MAX_RESULTS = 1000;
    private final NearbyPlaces nearbyPlaces;
<span class="nc" id="L36">    public static double currentLocationSearchRadius = 10.0; //in kilometers</span>
    public static LatLng currentLocation; // Users latest fetched location
    public static LatLng latestSearchLocation; // Can be current and camera target on search this area button is used
<span class="nc" id="L39">    public static double latestSearchRadius = 10.0; // Any last search radius except closest result search</span>

<span class="nc" id="L41">    public static List&lt;MarkerPlaceGroup&gt; markerLabelList = new ArrayList&lt;&gt;();</span>
    public static Map&lt;Boolean, Marker&gt; markerExistsMap;
    public static Map&lt;Boolean, Marker&gt; markerNeedPicMap;

    @Inject
<span class="nc" id="L46">    public NearbyController(NearbyPlaces nearbyPlaces) {</span>
<span class="nc" id="L47">        this.nearbyPlaces = nearbyPlaces;</span>
<span class="nc" id="L48">    }</span>


    /**
     * Prepares Place list to make their distance information update later.
     *
     * @param curLatLng current location for user
     * @param searchLatLng the location user wants to search around
     * @param returnClosestResult if this search is done to find closest result or all results
     * @param customQuery if this search is done via an advanced query
     * @return NearbyPlacesInfo a variable holds Place list without distance information
     * and boundary coordinates of current Place List
     */
    public NearbyPlacesInfo loadAttractionsFromLocation(final LatLng curLatLng, final LatLng searchLatLng,
        final boolean returnClosestResult, final boolean checkingAroundCurrentLocation,
        final boolean shouldQueryForMonuments, @Nullable final String customQuery) throws Exception {

<span class="nc" id="L65">        Timber.d(&quot;Loading attractions near %s&quot;, searchLatLng);</span>
<span class="nc" id="L66">        NearbyPlacesInfo nearbyPlacesInfo = new NearbyPlacesInfo();</span>

<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (searchLatLng == null) {</span>
<span class="nc" id="L69">            Timber.d(&quot;Loading attractions nearby, but curLatLng is null&quot;);</span>
<span class="nc" id="L70">            return null;</span>
        }
<span class="nc" id="L72">        List&lt;Place&gt; places = nearbyPlaces</span>
<span class="nc" id="L73">            .radiusExpander(searchLatLng, Locale.getDefault().getLanguage(), returnClosestResult,</span>
                shouldQueryForMonuments, customQuery);

<span class="nc bnc" id="L76" title="All 4 branches missed.">        if (null != places &amp;&amp; places.size() &gt; 0) {</span>
<span class="nc" id="L77">            LatLng[] boundaryCoordinates = {places.get(0).location,   // south</span>
<span class="nc" id="L78">                    places.get(0).location, // north</span>
<span class="nc" id="L79">                    places.get(0).location, // west</span>
<span class="nc" id="L80">                    places.get(0).location};// east, init with a random location</span>


<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (curLatLng != null) {</span>
<span class="nc" id="L84">                Timber.d(&quot;Sorting places by distance...&quot;);</span>
<span class="nc" id="L85">                final Map&lt;Place, Double&gt; distances = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                for (Place place : places) {</span>
<span class="nc" id="L87">                    distances.put(place, computeDistanceBetween(place.location, curLatLng));</span>
                    // Find boundaries with basic find max approach
<span class="nc bnc" id="L89" title="All 2 branches missed.">                    if (place.location.getLatitude() &lt; boundaryCoordinates[0].getLatitude()) {</span>
<span class="nc" id="L90">                        boundaryCoordinates[0] = place.location;</span>
                    }
<span class="nc bnc" id="L92" title="All 2 branches missed.">                    if (place.location.getLatitude() &gt; boundaryCoordinates[1].getLatitude()) {</span>
<span class="nc" id="L93">                        boundaryCoordinates[1] = place.location;</span>
                    }
<span class="nc bnc" id="L95" title="All 2 branches missed.">                    if (place.location.getLongitude() &lt; boundaryCoordinates[2].getLongitude()) {</span>
<span class="nc" id="L96">                        boundaryCoordinates[2] = place.location;</span>
                    }
<span class="nc bnc" id="L98" title="All 2 branches missed.">                    if (place.location.getLongitude() &gt; boundaryCoordinates[3].getLongitude()) {</span>
<span class="nc" id="L99">                        boundaryCoordinates[3] = place.location;</span>
                    }
<span class="nc" id="L101">                }</span>
<span class="nc" id="L102">                Collections.sort(places,</span>
                        (lhs, rhs) -&gt; {
<span class="nc" id="L104">                            double lhsDistance = distances.get(lhs);</span>
<span class="nc" id="L105">                            double rhsDistance = distances.get(rhs);</span>
<span class="nc" id="L106">                            return (int) (lhsDistance - rhsDistance);</span>
                        }
                );
            }
<span class="nc" id="L110">            nearbyPlacesInfo.curLatLng = curLatLng;</span>
<span class="nc" id="L111">            nearbyPlacesInfo.searchLatLng = searchLatLng;</span>
<span class="nc" id="L112">            nearbyPlacesInfo.placeList = places;</span>
<span class="nc" id="L113">            nearbyPlacesInfo.boundaryCoordinates = boundaryCoordinates;</span>

            // Returning closes result means we use the controller for nearby card. So no need to set search this area flags
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (!returnClosestResult) {</span>
                // To remember latest search either around user or any point on map
<span class="nc" id="L118">                latestSearchLocation = searchLatLng;</span>
<span class="nc" id="L119">                latestSearchRadius = nearbyPlaces.radius*1000; // to meter</span>

                // Our radius searched around us, will be used to understand when user search their own location, we will follow them
<span class="nc bnc" id="L122" title="All 2 branches missed.">                if (checkingAroundCurrentLocation) {</span>
<span class="nc" id="L123">                    currentLocationSearchRadius = nearbyPlaces.radius*1000; // to meter</span>
<span class="nc" id="L124">                    currentLocation = curLatLng;</span>
                }
            }


        }
<span class="nc" id="L130">        return nearbyPlacesInfo;</span>
    }

    /**
     * Prepares Place list to make their distance information update later.
     *
     * @param curLatLng           current location for user
     * @param searchLatLng        the location user wants to search around
     * @param returnClosestResult if this search is done to find closest result or all results
     * @return NearbyPlacesInfo a variable holds Place list without distance information and
     * boundary coordinates of current Place List
     */
    public NearbyPlacesInfo loadAttractionsFromLocation(final LatLng curLatLng,
        final LatLng searchLatLng,
        final boolean returnClosestResult, final boolean checkingAroundCurrentLocation,
        final boolean shouldQueryForMonuments) throws Exception {
<span class="nc" id="L146">        return loadAttractionsFromLocation(curLatLng, searchLatLng, returnClosestResult,</span>
            checkingAroundCurrentLocation, shouldQueryForMonuments, null);
    }

    /**
     * Loads attractions from location for map view, we need to return BaseMarkerOption data type.
     *
     * @param curLatLng users current location
     * @param placeList list of nearby places in Place data type
     * @return BaseMarkerOptions list that holds nearby places
     */
    public static List&lt;NearbyBaseMarker&gt; loadAttractionsFromLocationToBaseMarkerOptions(
            LatLng curLatLng,
            List&lt;Place&gt; placeList,
            Context context,
            List&lt;Place&gt; bookmarkplacelist) {
<span class="nc" id="L162">        List&lt;NearbyBaseMarker&gt; baseMarkerOptions = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (placeList == null) {</span>
<span class="nc" id="L165">            return baseMarkerOptions;</span>
        }

<span class="nc" id="L168">        placeList = placeList.subList(0, Math.min(placeList.size(), MAX_RESULTS));</span>

<span class="nc" id="L170">        VectorDrawableCompat vectorDrawable = null;</span>
<span class="nc" id="L171">        VectorDrawableCompat vectorDrawableGreen = null;</span>
<span class="nc" id="L172">        VectorDrawableCompat vectorDrawableGrey = null;</span>
<span class="nc" id="L173">        VectorDrawableCompat vectorDrawableMonuments = null;</span>
<span class="nc" id="L174">        vectorDrawable = null;</span>
        try {
<span class="nc" id="L176">            vectorDrawable = VectorDrawableCompat.create(</span>
<span class="nc" id="L177">                    context.getResources(), R.drawable.ic_custom_map_marker, context.getTheme());</span>
<span class="nc" id="L178">            vectorDrawableGreen = VectorDrawableCompat.create(</span>
<span class="nc" id="L179">                    context.getResources(), R.drawable.ic_custom_map_marker_green, context.getTheme());</span>
<span class="nc" id="L180">            vectorDrawableGrey = VectorDrawableCompat.create(</span>
<span class="nc" id="L181">                    context.getResources(), R.drawable.ic_custom_map_marker_grey, context.getTheme());</span>
<span class="nc" id="L182">            vectorDrawableMonuments = VectorDrawableCompat</span>
<span class="nc" id="L183">                .create(context.getResources(), R.drawable.ic_custom_map_marker_monuments,</span>
<span class="nc" id="L184">                    context.getTheme());</span>
<span class="nc" id="L185">        } catch (Resources.NotFoundException e) {</span>
            // ignore when running tests.
<span class="nc" id="L187">        }</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (vectorDrawable != null) {</span>
<span class="nc" id="L189">            Bitmap icon = UiUtils.getBitmap(vectorDrawable);</span>
<span class="nc" id="L190">            Bitmap iconGreen = UiUtils.getBitmap(vectorDrawableGreen);</span>
<span class="nc" id="L191">            Bitmap iconGrey = UiUtils.getBitmap(vectorDrawableGrey);</span>
<span class="nc" id="L192">            Bitmap iconMonuments = UiUtils.getBitmap(vectorDrawableMonuments);</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">            for (Place place : placeList) {</span>
<span class="nc" id="L195">                NearbyBaseMarker nearbyBaseMarker = new NearbyBaseMarker();</span>
<span class="nc" id="L196">                String distance = formatDistanceBetween(curLatLng, place.location);</span>
<span class="nc" id="L197">                place.setDistance(distance);</span>

<span class="nc" id="L199">                nearbyBaseMarker.title(place.name);</span>
<span class="nc" id="L200">                nearbyBaseMarker.position(</span>
                    new com.mapbox.mapboxsdk.geometry.LatLng(
<span class="nc" id="L202">                        place.location.getLatitude(),</span>
<span class="nc" id="L203">                        place.location.getLongitude()));</span>
<span class="nc" id="L204">                nearbyBaseMarker.place(place);</span>
                // Check if string is only spaces or empty, if so place doesn't have any picture

<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (place.isMonument()) {</span>
<span class="nc" id="L208">                    nearbyBaseMarker.icon(IconFactory.getInstance(context)</span>
<span class="nc" id="L209">                        .fromBitmap(iconMonuments));</span>
                }
<span class="nc bnc" id="L211" title="All 2 branches missed.">                else if (!place.pic.trim().isEmpty()) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if (iconGreen != null) {</span>
<span class="nc" id="L213">                        nearbyBaseMarker.icon(IconFactory.getInstance(context)</span>
<span class="nc" id="L214">                            .fromBitmap(iconGreen));</span>
                    }
<span class="nc bnc" id="L216" title="All 2 branches missed.">                } else if (!place.exists) { // Means that the topic of the Wikidata item does not exist in the real world anymore, for instance it is a past event, or a place that was destroyed</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                    if (iconGrey != null) {</span>
<span class="nc" id="L218">                        nearbyBaseMarker.icon(IconFactory.getInstance(context)</span>
<span class="nc" id="L219">                            .fromBitmap(iconGrey));</span>
                    }
                } else {
<span class="nc" id="L222">                    nearbyBaseMarker.icon(IconFactory.getInstance(context)</span>
<span class="nc" id="L223">                        .fromBitmap(icon));</span>
                }
<span class="nc" id="L225">                baseMarkerOptions.add(nearbyBaseMarker);</span>
<span class="nc" id="L226">            }</span>
        }

<span class="nc" id="L229">        return baseMarkerOptions;</span>
    }

    /**
     * Updates makerLabelList item isBookmarked value
     * @param place place which is bookmarked
     * @param isBookmarked true is bookmarked, false if bookmark removed
     */
    @MainThread
    public static void updateMarkerLabelListBookmark(Place place, boolean isBookmarked) {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        for (ListIterator&lt;MarkerPlaceGroup&gt; iter = markerLabelList.listIterator(); iter.hasNext();) {</span>
<span class="nc" id="L240">            MarkerPlaceGroup markerPlaceGroup = iter.next();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (markerPlaceGroup.getPlace().getWikiDataEntityId().equals(place.getWikiDataEntityId())) {</span>
<span class="nc" id="L242">                iter.set(new MarkerPlaceGroup(markerPlaceGroup.getMarker(), isBookmarked, place));</span>
            }
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.0.2</div></body></html>