<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SuggestionAutoCompleteText.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">wordpressJalapenoDebug</a> &gt; <a href="index.source.html" class="el_package">org.wordpress.android.widgets</a> &gt; <span class="el_source">SuggestionAutoCompleteText.java</span></div><h1>SuggestionAutoCompleteText.java</h1><pre class="source lang-java linenums">package org.wordpress.android.widgets;

import android.content.Context;
import android.graphics.Rect;
import android.os.Parcel;
import android.os.Parcelable;
import android.text.Editable;
import android.util.AttributeSet;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;

import androidx.appcompat.widget.AppCompatMultiAutoCompleteTextView;

import org.wordpress.android.ui.suggestion.util.SuggestionTokenizer;
import org.wordpress.android.util.DeviceUtils;
import org.wordpress.persistentedittext.PersistentEditTextHelper;

public class SuggestionAutoCompleteText extends AppCompatMultiAutoCompleteTextView {
    PersistentEditTextHelper mPersistentEditTextHelper;
    private OnEditTextBackListener mBackListener;
    private SuggestionTokenizer mSuggestionTokenizer;
    private char mPrefix;

    public interface OnEditTextBackListener {
        void onEditTextBack();
    }

    public SuggestionAutoCompleteText(Context context) {
<span class="nc" id="L31">        super(context, null);</span>
<span class="nc" id="L32">        init(context);</span>
<span class="nc" id="L33">    }</span>

    public SuggestionAutoCompleteText(Context context, AttributeSet attrs) {
<span class="nc" id="L36">        super(context, attrs);</span>
<span class="nc" id="L37">        init(context);</span>
<span class="nc" id="L38">    }</span>

    public SuggestionAutoCompleteText(Context context, AttributeSet attrs, int defStyle) {
<span class="nc" id="L41">        super(context, attrs, defStyle);</span>
<span class="nc" id="L42">        init(context);</span>
<span class="nc" id="L43">    }</span>

    private void init(Context context) {
<span class="nc" id="L46">        mPersistentEditTextHelper = new PersistentEditTextHelper(context);</span>
        // When TYPE_TEXT_FLAG_AUTO_COMPLETE is set, autocorrection is disabled.
<span class="nc" id="L48">        setRawInputType(getInputType() &amp; ~EditorInfo.TYPE_TEXT_FLAG_AUTO_COMPLETE);</span>
<span class="nc" id="L49">    }</span>

    public void initializeWithPrefix(char prefix) {
<span class="nc" id="L52">        mPrefix = prefix;</span>
<span class="nc" id="L53">        mSuggestionTokenizer = new SuggestionTokenizer(mPrefix);</span>
<span class="nc" id="L54">        setTokenizer(mSuggestionTokenizer);</span>
<span class="nc" id="L55">        setThreshold(1);</span>
<span class="nc" id="L56">    }</span>

    @Override
    public boolean enoughToFilter() {
<span class="nc" id="L60">        Editable text = getText();</span>

<span class="nc" id="L62">        int end = getSelectionEnd();</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (end &lt; 0) {</span>
<span class="nc" id="L64">            return false;</span>
        }

<span class="nc" id="L67">        int start = mSuggestionTokenizer.findTokenStart(text, end);</span>

<span class="nc bnc" id="L69" title="All 6 branches missed.">        return start &gt; 0</span>
               &amp;&amp; (end - start &gt;= 1
<span class="nc bnc" id="L71" title="All 2 branches missed.">                             || (start == end &amp;&amp; text.charAt(start - 1) == mPrefix));</span>
    }

    public void forceFiltering(CharSequence text) {
<span class="nc" id="L75">        performFiltering(text, 0);</span>
<span class="nc" id="L76">    }</span>

    public PersistentEditTextHelper getAutoSaveTextHelper() {
<span class="nc" id="L79">        return mPersistentEditTextHelper;</span>
    }

    @Override
    protected void onAttachedToWindow() {
<span class="nc" id="L84">        super.onAttachedToWindow();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (getAutoSaveTextHelper().getUniqueId() == null) {</span>
<span class="nc" id="L86">            return;</span>
        }
<span class="nc" id="L88">        getAutoSaveTextHelper().loadString(this);</span>
<span class="nc" id="L89">    }</span>

    @Override
    protected void onDetachedFromWindow() {
<span class="nc" id="L93">        super.onDetachedFromWindow();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (getAutoSaveTextHelper().getUniqueId() == null) {</span>
<span class="nc" id="L95">            return;</span>
        }
<span class="nc" id="L97">        getAutoSaveTextHelper().saveString(this);</span>
<span class="nc" id="L98">    }</span>

    public void setOnBackListener(OnEditTextBackListener listener) {
<span class="nc" id="L101">        mBackListener = listener;</span>
<span class="nc" id="L102">    }</span>

    @Override
    public Parcelable onSaveInstanceState() {
<span class="nc" id="L106">        SavedState savedState = new SavedState(super.onSaveInstanceState());</span>

        // store the current Focused state
<span class="nc" id="L109">        savedState.mIsFocused = isFocused();</span>

<span class="nc" id="L111">        return savedState;</span>
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (!(state instanceof SavedState)) {</span>
<span class="nc" id="L117">            super.onRestoreInstanceState(state);</span>
<span class="nc" id="L118">            return;</span>
        }

<span class="nc" id="L121">        SavedState savedState = (SavedState) state;</span>
<span class="nc" id="L122">        super.onRestoreInstanceState(savedState.getSuperState());</span>

        // if we were focused, setup a properly timed future request for focus
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (savedState.mIsFocused) {</span>
            // this OnLayoutChangeListener will self unregister upon running and it's there so we can properly time the
            // on-screen IME opening
<span class="nc" id="L128">            addOnLayoutChangeListener(mOneoffFocusRequest);</span>
        }
<span class="nc" id="L130">    }</span>

<span class="nc" id="L132">    private final OnLayoutChangeListener mOneoffFocusRequest = new OnLayoutChangeListener() {</span>
        @Override
        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop,
                                   int oldRight, int oldBottom) {
            // we're now at a good point in time to launch a focus request
<span class="nc" id="L137">            post(new Runnable() {</span>
                @Override
                public void run() {
                    // self unregister so we won't auto-request focus again
<span class="nc" id="L141">                    removeOnLayoutChangeListener(mOneoffFocusRequest);</span>

                    // request focus
<span class="nc" id="L144">                    setFocusableInTouchMode(true);</span>
<span class="nc" id="L145">                    requestFocus();</span>
<span class="nc" id="L146">                }</span>
            });
<span class="nc" id="L148">        }</span>
    };

    @Override
    public boolean performClick() {
        // make sure we are focusable otherwise we will not get focused
<span class="nc" id="L154">        setFocusableInTouchMode(true);</span>
<span class="nc" id="L155">        requestFocus();</span>

<span class="nc" id="L157">        return super.performClick();</span>
    }

    /*
     * detect when user hits the back button while soft keyboard is showing (hiding the keyboard)
     */
    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
<span class="nc bnc" id="L165" title="All 4 branches missed.">        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_UP) {</span>
            // clear focus but stop being focusable first. This way we won't receive focus if we're the only focusable
            // widget on the page
<span class="nc" id="L168">            setFocusableInTouchMode(false);</span>
<span class="nc" id="L169">            clearFocus();</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (mBackListener != null) {</span>
<span class="nc" id="L172">                mBackListener.onEditTextBack();</span>
            }
        }

<span class="nc" id="L176">        return super.onKeyPreIme(keyCode, event);</span>
    }

    @Override
    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
<span class="nc" id="L181">        super.onFocusChanged(focused, direction, previouslyFocusedRect);</span>

        // if no hardware keys are present, associate being focused to having the on-screen keyboard visible
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (!DeviceUtils.getInstance().hasHardwareKeyboard(getContext())) {</span>
<span class="nc" id="L185">            InputMethodManager inputMethodManager = (InputMethodManager) getContext()</span>
<span class="nc" id="L186">                    .getSystemService(Context.INPUT_METHOD_SERVICE);</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (focused) {</span>
                // show the on-screen keybpoard if we got focused
<span class="nc" id="L190">                inputMethodManager.showSoftInput(this, 0);</span>
            } else {
                // stop being focusable so closing the keyboard won't focus us
<span class="nc" id="L193">                setFocusableInTouchMode(false);</span>
<span class="nc" id="L194">                inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);</span>
            }
        }
<span class="nc" id="L197">    }</span>

    /**
     * Local class for holding the EditBox's focused or not state
     */
    static class SavedState extends BaseSavedState {
        private boolean mIsFocused;

        SavedState(Parcelable superState) {
<span class="nc" id="L206">            super(superState);</span>
<span class="nc" id="L207">        }</span>

        private SavedState(Parcel in) {
<span class="nc" id="L210">            super(in);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            this.mIsFocused = (in.readInt() == 1);</span>
<span class="nc" id="L212">        }</span>

        @Override
        public void writeToParcel(Parcel out, int flags) {
<span class="nc" id="L216">            super.writeToParcel(out, flags);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            out.writeInt(this.mIsFocused ? 1 : 0);</span>
<span class="nc" id="L218">        }</span>

<span class="nc" id="L220">        public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;() {</span>
            public SavedState createFromParcel(Parcel in) {
<span class="nc" id="L222">                return new SavedState(in);</span>
            }

            public SavedState[] newArray(int size) {
<span class="nc" id="L226">                return new SavedState[size];</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>Generated by the Android Gradle plugin 7.1.1</div></body></html>