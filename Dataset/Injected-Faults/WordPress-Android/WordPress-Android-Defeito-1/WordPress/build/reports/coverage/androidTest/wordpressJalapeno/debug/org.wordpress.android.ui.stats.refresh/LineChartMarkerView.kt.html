<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LineChartMarkerView.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">wordpressJalapenoDebug</a> &gt; <a href="index.source.html" class="el_package">org.wordpress.android.ui.stats.refresh</a> &gt; <span class="el_source">LineChartMarkerView.kt</span></div><h1>LineChartMarkerView.kt</h1><pre class="source lang-java linenums">package org.wordpress.android.ui.stats.refresh

import android.content.Context
import android.graphics.BlurMaskFilter
import android.graphics.BlurMaskFilter.Blur.NORMAL
import android.graphics.Canvas
import android.graphics.CornerPathEffect
import android.graphics.Paint
import android.graphics.Path
import android.graphics.Path.Direction.CW
import android.graphics.RectF
import android.widget.TextView
import androidx.core.content.ContextCompat
import com.github.mikephil.charting.charts.LineChart
import com.github.mikephil.charting.components.MarkerView
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.highlight.Highlight
import com.github.mikephil.charting.utils.MPPointF
import dagger.hilt.android.AndroidEntryPoint
import org.wordpress.android.R
import org.wordpress.android.ui.stats.refresh.lists.sections.insights.usecases.ViewsAndVisitorsMapper.SelectedType
import org.wordpress.android.ui.stats.refresh.utils.StatsUtils
import javax.inject.Inject

@Suppress(&quot;MagicNumber&quot;)
@AndroidEntryPoint
<span class="nc" id="L28">class LineChartMarkerView @Inject constructor(</span>
    context: Context,
<span class="nc" id="L30">    private val selectedType: Int</span>
<span class="nc" id="L31">) : MarkerView(context, R.layout.stats_line_chart_marker) {</span>
<span class="nc bnc" id="L32" title="All 2 branches missed.">    @Inject lateinit var statsUtils: StatsUtils</span>
<span class="nc" id="L33">    private val changeView = findViewById&lt;TextView&gt;(R.id.marker_text1)</span>
<span class="nc" id="L34">    private val countView = findViewById&lt;TextView&gt;(R.id.marker_text2)</span>

    override fun refreshContent(e: Entry?, highlight: Highlight?) {
<span class="nc" id="L37">        val chart = chartView</span>

<span class="nc" id="L39">        var thisWeekCount = 0L</span>
<span class="nc" id="L40">        var prevWeekCount = 0L</span>

<span class="nc bnc" id="L42" title="All 2 branches missed.">        if (chart is LineChart) {</span>
<span class="nc" id="L43">            val lineData = chart.lineData</span>
<span class="nc" id="L44">            val dataSetList = lineData.dataSets // Get all the curves in the chart</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">            for (i in dataSetList.indices) {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">                val dataSet = dataSetList[i] as LineDataSet</span>
                // Get all the data sets on the Y axis of the curve, and
                // get the corresponding Y axis value according to the current X axis position
<span class="nc bnc" id="L49" title="All 2 branches missed.">                val index = if (e!!.x.toInt() &lt; dataSet.values.size) e.x.toInt() else 0</span>
<span class="nc" id="L50">                val y = dataSet.values[index].y</span>

<span class="nc bnc" id="L52" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc" id="L53">                    thisWeekCount = y.toLong()</span>
<span class="nc" id="L54">                    countView.text = context.getString(</span>
<span class="nc" id="L55">                            R.string.stats_insights_views_and_visitors_tooltip_count,</span>
<span class="nc" id="L56">                            y.toInt().toString(),</span>
<span class="nc" id="L57">                            SelectedType.valueOf(selectedType).toString()</span>
                    )
                }
<span class="nc bnc" id="L60" title="All 2 branches missed.">                if (i == 1) {</span>
<span class="nc" id="L61">                    prevWeekCount = y.toLong()</span>
                }
            }
<span class="nc bnc" id="L64" title="All 2 branches missed.">            val positive = thisWeekCount &gt;= (prevWeekCount ?: 0)</span>
<span class="nc" id="L65">            val change = statsUtils.buildChange(prevWeekCount, thisWeekCount, positive, isFormattedNumber = false)</span>
<span class="nc" id="L66">            changeView.text = change.toString()</span>
        }
<span class="nc" id="L68">        super.refreshContent(e, highlight)</span>
<span class="nc" id="L69">    }</span>

    override fun getOffsetForDrawingAtPoint(posX: Float, posY: Float): MPPointF {
        // posY posX refers to the position of the upper left corner of the markerView on the chart
<span class="nc" id="L73">        val width = width.toFloat()</span>
<span class="nc" id="L74">        val height = height.toFloat()</span>

        // If the y coordinate of the point is less than the height of the markerView,
        // if it is not processed, it will exceed the upper boundary. After processing,
        // the arrow is up at this time, and we need to move the icon down by the size of the arrow
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (posY &lt;= height + ARROW_SIZE) {</span>
<span class="nc" id="L80">            offset.y = ARROW_SIZE</span>
        } else {
            // Otherwise, it is normal, because our default is that the arrow is facing downwards,
            // and then the normal offset is that you need to offset the height of the markerView and the arrow size,
            // plus a stroke width, because you need to see the upper border of the dialog box
<span class="nc" id="L85">            offset.y = -height - ARROW_SIZE - STROKE_WIDTH</span>
        }

        // handle X direction, left, middle, and right side of the chart
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (posX &gt; chartView.width - width) { // If it exceeds the right boundary, offset the view width to the left</span>
<span class="nc" id="L90">            offset.x = -width</span>
        } else { // by default, no offset (because the point is in the upper left corner)
<span class="nc" id="L92">            offset.x = 0F</span>
            // If it is greater than half of the markerView, the arrow is in the middle,
            // so it is offset by half the width to the right
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (posX &gt; width / 2) {</span>
<span class="nc" id="L96">                offset.x = -(width / 2)</span>
            }
        }

<span class="nc" id="L100">        return offset</span>
    }

    override fun draw(canvas: Canvas?, posX: Float, posY: Float) {
<span class="nc" id="L104">        super.draw(canvas, posX, posY)</span>

<span class="nc bnc" id="L106" title="All 2 branches missed.">        val saveId = canvas?.save()</span>

<span class="nc" id="L108">        drawToolTip(canvas, posX, posY)</span>
<span class="nc" id="L109">        draw(canvas)</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">        saveId?.let {</span>
<span class="nc" id="L112">            canvas.restoreToCount(it)</span>
<span class="nc" id="L113">        }</span>
<span class="nc" id="L114">    }</span>

    @Suppress(&quot;LongMethod&quot;)
    private fun drawToolTip(canvas: Canvas?, posX: Float, posY: Float) {
<span class="nc" id="L118">        val borderPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {</span>
<span class="nc" id="L119">            strokeWidth = STROKE_WIDTH</span>
<span class="nc" id="L120">            style = Paint.Style.STROKE</span>
<span class="nc" id="L121">            strokeJoin = Paint.Join.ROUND</span>
<span class="nc" id="L122">            strokeCap = Paint.Cap.ROUND</span>
<span class="nc" id="L123">            pathEffect = CornerPathEffect(CORNER_RADIUS)</span>
<span class="nc" id="L124">            color = context.getColor(R.color.blue_100)</span>
<span class="nc" id="L125">        }</span>

<span class="nc" id="L127">        val bgPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {</span>
<span class="nc" id="L128">            style = Paint.Style.FILL</span>
<span class="nc" id="L129">            strokeCap = Paint.Cap.ROUND</span>
<span class="nc" id="L130">            pathEffect = CornerPathEffect(CORNER_RADIUS)</span>
<span class="nc" id="L131">            color = context.getColor(R.color.blue_100)</span>
<span class="nc" id="L132">        }</span>

<span class="nc" id="L134">        val chart = chartView</span>
<span class="nc" id="L135">        val width = width.toFloat()</span>
<span class="nc" id="L136">        val height = height.toFloat()</span>

<span class="nc" id="L138">        val offset = getOffsetForDrawingAtPoint(posX, posY)</span>

<span class="nc" id="L140">        val path = Path()</span>

<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (posY &lt; height + ARROW_SIZE) { // Processing exceeds the upper boundary</span>
<span class="nc" id="L143">            path.moveTo(0f, 0f)</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (posX &gt; chart.width - width) { // Exceed the right boundary</span>
<span class="nc" id="L145">                path.lineTo(width - ARROW_SIZE, 0f)</span>
<span class="nc" id="L146">                path.lineTo(width, -ARROW_SIZE + CIRCLE_OFFSET)</span>
<span class="nc" id="L147">                path.lineTo(width, 0f)</span>
            } else {
<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (posX &gt; width / 2) { // In the middle of the chart</span>
<span class="nc" id="L150">                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0f)</span>
<span class="nc" id="L151">                    path.lineTo(width / 2, -ARROW_SIZE + CIRCLE_OFFSET)</span>
<span class="nc" id="L152">                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0f)</span>
                } else { // Exceed the left margin
<span class="nc" id="L154">                    path.lineTo(0f, -ARROW_SIZE + CIRCLE_OFFSET)</span>
<span class="nc" id="L155">                    path.lineTo(0 + ARROW_SIZE, 0f)</span>
                }
            }
<span class="nc" id="L158">            path.lineTo(0 + width, 0f)</span>
<span class="nc" id="L159">            path.lineTo(0 + width, 0 + height)</span>
<span class="nc" id="L160">            path.lineTo(0f, 0 + height)</span>
<span class="nc" id="L161">            path.lineTo(0f, 0f)</span>
<span class="nc" id="L162">            path.offset(posX + offset.x, posY + offset.y)</span>
        } else { // Does not exceed the upper boundary
<span class="nc" id="L164">            path.moveTo(0f, 0f)</span>
<span class="nc" id="L165">            path.lineTo(0 + width, 0f)</span>
<span class="nc" id="L166">            path.lineTo(0 + width, 0 + height)</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (posX &gt; chart.width - width) {</span>
<span class="nc" id="L168">                path.lineTo(width, height + ARROW_SIZE - CIRCLE_OFFSET)</span>
<span class="nc" id="L169">                path.lineTo(width - ARROW_SIZE, 0 + height)</span>
<span class="nc" id="L170">                path.lineTo(0f, 0 + height)</span>
            } else {
<span class="nc bnc" id="L172" title="All 2 branches missed.">                if (posX &gt; width / 2) {</span>
<span class="nc" id="L173">                    path.lineTo(width / 2 + ARROW_SIZE / 2, 0 + height)</span>
<span class="nc" id="L174">                    path.lineTo(width / 2, height + ARROW_SIZE - CIRCLE_OFFSET)</span>
<span class="nc" id="L175">                    path.lineTo(width / 2 - ARROW_SIZE / 2, 0 + height)</span>
<span class="nc" id="L176">                    path.lineTo(0f, 0 + height)</span>
                } else {
<span class="nc" id="L178">                    path.lineTo(0 + ARROW_SIZE, 0 + height)</span>
<span class="nc" id="L179">                    path.lineTo(0f, height + ARROW_SIZE - CIRCLE_OFFSET)</span>
<span class="nc" id="L180">                    path.lineTo(0f, 0 + height)</span>
                }
            }
<span class="nc" id="L183">            path.lineTo(0f, 0f)</span>
<span class="nc" id="L184">            path.offset(posX + offset.x, posY + offset.y)</span>
        }
<span class="nc" id="L186">        path.close()</span>

        // translate to the correct position and draw
<span class="nc bnc" id="L189" title="All 2 branches missed.">        canvas?.apply {</span>
<span class="nc" id="L190">            drawPath(path, bgPaint)</span>
<span class="nc" id="L191">            drawPath(path, borderPaint)</span>
<span class="nc" id="L192">            drawDataPoint(canvas, posX, posY)</span>
<span class="nc" id="L193">            translate(posX + offset.x, posY + offset.y)</span>
<span class="nc" id="L194">        }</span>
<span class="nc" id="L195">    }</span>

    private fun drawDataPoint(canvas: Canvas?, posX: Float, posY: Float) {
<span class="nc" id="L198">        val circleShadowPaint = Paint().apply {</span>
<span class="nc" id="L199">            style = Paint.Style.FILL</span>
<span class="nc" id="L200">            color = ContextCompat.getColor(context, R.color.gray_10)</span>
<span class="nc" id="L201">            maskFilter = BlurMaskFilter(5F, NORMAL)</span>
<span class="nc" id="L202">        }</span>

<span class="nc" id="L204">        val circleBorderPaint = Paint().apply {</span>
<span class="nc" id="L205">            style = Paint.Style.STROKE</span>
<span class="nc" id="L206">            strokeWidth = CIRCLE_STROKE_WIDTH</span>
<span class="nc" id="L207">            isAntiAlias = true</span>
<span class="nc" id="L208">            isDither = true</span>
<span class="nc" id="L209">            color = ContextCompat.getColor(context, R.color.blue_0)</span>
<span class="nc" id="L210">        }</span>

<span class="nc" id="L212">        val circleFillPaint = Paint().apply {</span>
<span class="nc" id="L213">            style = Paint.Style.FILL</span>
<span class="nc" id="L214">            isAntiAlias = true</span>
<span class="nc" id="L215">            isDither = true</span>
<span class="nc" id="L216">            color = ContextCompat.getColor(context, SelectedType.getColor(selectedType))</span>
<span class="nc" id="L217">        }</span>

<span class="nc" id="L219">        val circleShadowPath = Path().apply {</span>
<span class="nc" id="L220">            addCircle(posX, posY, CIRCLE_SHADOW_RADIUS, CW)</span>
<span class="nc" id="L221">        }</span>

<span class="nc" id="L223">        val circleFillPath = Path().apply {</span>
<span class="nc" id="L224">            addCircle(posX, posY, CIRCLE_RADIUS, CW)</span>
<span class="nc" id="L225">        }</span>

<span class="nc" id="L227">        val circleBorderPath = Path().apply {</span>
<span class="nc" id="L228">            addCircle(posX, posY, CIRCLE_RADIUS, CW)</span>
<span class="nc" id="L229">            fillType = Path.FillType.EVEN_ODD</span>
<span class="nc" id="L230">        }</span>

<span class="nc" id="L232">        val innerCircle = RectF().apply {</span>
<span class="nc" id="L233">            inset(CIRCLE_STROKE_WIDTH, CIRCLE_STROKE_WIDTH)</span>
<span class="nc" id="L234">        }</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">        if (innerCircle.width() &gt; 0 &amp;&amp; innerCircle.height() &gt; 0) {</span>
<span class="nc" id="L236">            circleBorderPath.addCircle(posX, posY, CIRCLE_RADIUS, CW)</span>
        }

<span class="nc bnc" id="L239" title="All 2 branches missed.">        canvas?.apply {</span>
<span class="nc" id="L240">            drawPath(circleShadowPath, circleShadowPaint)</span>
<span class="nc" id="L241">            drawPath(circleFillPath, circleFillPaint)</span>
<span class="nc" id="L242">            drawPath(circleBorderPath, circleBorderPaint)</span>
<span class="nc" id="L243">        }</span>
<span class="nc" id="L244">    }</span>

    companion object {
        const val CORNER_RADIUS = 10F
        const val ARROW_SIZE = 40F
        const val STROKE_WIDTH = 5F
        const val CIRCLE_OFFSET = 14F

        const val CIRCLE_RADIUS = 12F
        const val CIRCLE_SHADOW_RADIUS = CIRCLE_RADIUS + 2F
        const val CIRCLE_STROKE_WIDTH = 4F
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>Generated by the Android Gradle plugin 7.1.1</div></body></html>