<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UploadService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">wordpressJalapenoDebug</a> &gt; <a href="index.source.html" class="el_package">org.wordpress.android.ui.uploads</a> &gt; <span class="el_source">UploadService.java</span></div><h1>UploadService.java</h1><pre class="source lang-java linenums">package org.wordpress.android.ui.uploads;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import org.greenrobot.eventbus.EventBus;
import org.greenrobot.eventbus.Subscribe;
import org.greenrobot.eventbus.ThreadMode;
import org.wordpress.android.R;
import org.wordpress.android.WordPress;
import org.wordpress.android.analytics.AnalyticsTracker;
import org.wordpress.android.editor.AztecEditorFragment;
import org.wordpress.android.fluxc.Dispatcher;
import org.wordpress.android.fluxc.generated.MediaActionBuilder;
import org.wordpress.android.fluxc.generated.PostActionBuilder;
import org.wordpress.android.fluxc.generated.UploadActionBuilder;
import org.wordpress.android.fluxc.model.CauseOfOnPostChanged;
import org.wordpress.android.fluxc.model.CauseOfOnPostChanged.RemoteAutoSavePost;
import org.wordpress.android.fluxc.model.MediaModel;
import org.wordpress.android.fluxc.model.MediaModel.MediaUploadState;
import org.wordpress.android.fluxc.model.PostImmutableModel;
import org.wordpress.android.fluxc.model.PostModel;
import org.wordpress.android.fluxc.model.SiteModel;
import org.wordpress.android.fluxc.store.MediaStore;
import org.wordpress.android.fluxc.store.MediaStore.OnMediaUploaded;
import org.wordpress.android.fluxc.store.PostStore;
import org.wordpress.android.fluxc.store.PostStore.OnPostChanged;
import org.wordpress.android.fluxc.store.PostStore.OnPostUploaded;
import org.wordpress.android.fluxc.store.SiteStore;
import org.wordpress.android.fluxc.store.UploadStore;
import org.wordpress.android.fluxc.store.UploadStore.ClearMediaPayload;
import org.wordpress.android.ui.media.services.MediaUploadReadyListener;
import org.wordpress.android.ui.mysite.SelectedSiteRepository;
import org.wordpress.android.ui.notifications.SystemNotificationsTracker;
import org.wordpress.android.ui.posts.PostUtils;
import org.wordpress.android.ui.posts.PostUtilsWrapper;
import org.wordpress.android.ui.prefs.AppPrefs;
import org.wordpress.android.util.AppLog;
import org.wordpress.android.util.AppLog.T;
import org.wordpress.android.util.DateTimeUtils;
import org.wordpress.android.util.FluxCUtils;
import org.wordpress.android.util.NetworkUtils;
import org.wordpress.android.util.StringUtils;
import org.wordpress.android.util.ToastUtils;
import org.wordpress.android.util.WPMediaUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.inject.Inject;

<span class="nc" id="L60">public class UploadService extends Service {</span>
    private static final String KEY_CHANGE_STATUS_TO_PUBLISH = &quot;shouldPublish&quot;;
    private static final String KEY_SHOULD_RETRY = &quot;shouldRetry&quot;;
    private static final String KEY_MEDIA_LIST = &quot;mediaList&quot;;
    private static final String KEY_UPLOAD_MEDIA_FROM_EDITOR = &quot;mediaFromEditor&quot;;
    private static final String KEY_LOCAL_POST_ID = &quot;localPostId&quot;;
    private static final String KEY_SHOULD_TRACK_ANALYTICS = &quot;shouldTrackPostAnalytics&quot;;

    private static @Nullable UploadService sInstance;

    private MediaUploadHandler mMediaUploadHandler;
    private PostUploadHandler mPostUploadHandler;
    private PostUploadNotifier mPostUploadNotifier;

    // we hold this reference here for the success notification for Media uploads
<span class="nc" id="L75">    private List&lt;MediaModel&gt; mMediaBatchUploaded = new ArrayList&lt;&gt;();</span>

    // we keep this list so we don't tell the user an error happened when we find a FAILED media item
    // for media that the user actively cancelled uploads for
<span class="fc" id="L79">    private static HashSet&lt;String&gt; mUserDeletedMediaItemIds = new HashSet&lt;&gt;();</span>


    @Inject Dispatcher mDispatcher;
    @Inject MediaStore mMediaStore;
    @Inject PostStore mPostStore;
    @Inject SiteStore mSiteStore;
    @Inject UploadStore mUploadStore;
    @Inject SystemNotificationsTracker mSystemNotificationsTracker;
    @Inject PostUtilsWrapper mPostUtilsWrapper;
    @Inject SelectedSiteRepository mSelectedSiteRepository;

    @Override
    public void onCreate() {
<span class="nc" id="L93">        super.onCreate();</span>
<span class="nc" id="L94">        ((WordPress) getApplication()).component().inject(this);</span>
<span class="nc" id="L95">        AppLog.i(T.MAIN, &quot;UploadService &gt; Created&quot;);</span>
<span class="nc" id="L96">        mDispatcher.register(this);</span>
<span class="nc" id="L97">        sInstance = this;</span>
        // TODO: Recover any posts/media uploads that were interrupted by the service being stopped

<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (mMediaUploadHandler == null) {</span>
<span class="nc" id="L101">            mMediaUploadHandler = new MediaUploadHandler();</span>
        }

<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (mPostUploadNotifier == null) {</span>
<span class="nc" id="L105">            mPostUploadNotifier = new PostUploadNotifier(getApplicationContext(), this, mSystemNotificationsTracker);</span>
        }

<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (mPostUploadHandler == null) {</span>
<span class="nc" id="L109">            mPostUploadHandler = new PostUploadHandler(mPostUploadNotifier);</span>
        }
<span class="nc" id="L111">    }</span>

    @Override
    public void onDestroy() {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (mMediaUploadHandler != null) {</span>
<span class="nc" id="L116">            mMediaUploadHandler.cancelInProgressUploads();</span>
<span class="nc" id="L117">            mMediaUploadHandler.unregister();</span>
        }

<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (mPostUploadHandler != null) {</span>
<span class="nc" id="L121">            mPostUploadHandler.cancelInProgressUploads();</span>
<span class="nc" id="L122">            mPostUploadHandler.unregister();</span>
        }

        // Update posts with any completed AND failed uploads in our post-&gt;media map
<span class="nc" id="L126">        doFinalProcessingOfPosts(null, null);</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">        for (PostModel pendingPost : mUploadStore.getPendingPosts()) {</span>
<span class="nc" id="L129">            cancelQueuedPostUpload(pendingPost);</span>
<span class="nc" id="L130">        }</span>

<span class="nc" id="L132">        mDispatcher.unregister(this);</span>
<span class="nc" id="L133">        sInstance = null;</span>
<span class="nc" id="L134">        AppLog.i(T.MAIN, &quot;UploadService &gt; Destroyed&quot;);</span>
<span class="nc" id="L135">        super.onDestroy();</span>
<span class="nc" id="L136">    }</span>

    @Override
    public IBinder onBind(Intent intent) {
<span class="nc" id="L140">        return null;</span>
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // Skip this request if no items to upload were given
<span class="nc bnc" id="L146" title="All 6 branches missed.">        if (intent == null || (!intent.hasExtra(KEY_MEDIA_LIST) &amp;&amp; !intent.hasExtra(KEY_LOCAL_POST_ID))) {</span>
<span class="nc" id="L147">            AppLog.e(T.MAIN, &quot;UploadService &gt; Killed and restarted with an empty intent&quot;);</span>
<span class="nc" id="L148">            stopServiceIfUploadsComplete();</span>
<span class="nc" id="L149">            return START_NOT_STICKY;</span>
        }

<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (intent.hasExtra(KEY_MEDIA_LIST)) {</span>
<span class="nc" id="L153">            unpackMediaIntent(intent);</span>
        }

<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (intent.hasExtra(KEY_LOCAL_POST_ID)) {</span>
<span class="nc" id="L157">            unpackPostIntent(intent);</span>
        }

<span class="nc" id="L160">        return START_REDELIVER_INTENT;</span>
    }

    private void unpackMediaIntent(@NonNull Intent intent) {
        // TODO right now, in the case we had pending uploads and the app/service was restarted,
        // we don't really have a way to tell which media was supposed to be added to which post,
        // unless we open each draft post from the PostStore and try to see if there was any locally added media to try
        // and match their IDs.
        // So let's hold on a bit on this functionality, the service won't be recovering any
        // pending / missing / cancelled / interrupted uploads for now

// // add local queued media from store
// List&lt;MediaModel&gt; localMedia = mMediaStore.getLocalSiteMedia(site);
// if (localMedia != null &amp;&amp; !localMedia.isEmpty()) {
// // uploading is updated to queued, queued media added to the queue, failed media added to completed list
// for (MediaModel mediaItem : localMedia) {
//
// if (MediaUploadState.UPLOADING.name().equals(mediaItem.getUploadState())) {
// mediaItem.setUploadState(MediaUploadState.QUEUED.name());
// mDispatcher.dispatch(MediaActionBuilder.newUpdateMediaAction(mediaItem));
// }
//
// if (MediaUploadState.QUEUED.name().equals(mediaItem.getUploadState())) {
// addUniqueMediaToQueue(mediaItem);
// } else if (MediaUploadState.FAILED.name().equals(mediaItem.getUploadState())) {
// getCompletedItems().add(mediaItem);
// }
// }
// }

        // add new media
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L192">        List&lt;MediaModel&gt; mediaList = (List&lt;MediaModel&gt;) intent.getSerializableExtra(KEY_MEDIA_LIST);</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">        if (mediaList != null &amp;&amp; !mediaList.isEmpty()) {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (!intent.getBooleanExtra(KEY_UPLOAD_MEDIA_FROM_EDITOR, false)) {</span>
                // only cancel the media error notification if we're triggering a new media upload
                // either from Media Browser or a RETRY from a notification.
                // Otherwise, this flag should be true, and we need to keep the error notification as
                // it might be a separate action (user is editing a Post and including media there)
<span class="nc" id="L199">                PostUploadNotifier.cancelFinalNotificationForMedia(this,</span>
<span class="nc" id="L200">                                                                   mSiteStore.getSiteByLocalId(</span>
<span class="nc" id="L201">                                                                           mediaList.get(0).getLocalSiteId()));</span>

                // add these media items so we can use them in WRITE POST once they end up loading successfully
<span class="nc" id="L204">                mMediaBatchUploaded.addAll(mediaList);</span>
            }

            // if this media belongs to some post, register such Post
<span class="nc" id="L208">            registerPostModelsForMedia(mediaList, intent.getBooleanExtra(KEY_SHOULD_RETRY, false));</span>

<span class="nc" id="L210">            ArrayList&lt;MediaModel&gt; toBeUploadedMediaList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            for (MediaModel media : mediaList) {</span>
<span class="nc" id="L212">                MediaModel localMedia = mMediaStore.getMediaWithLocalId(media.getId());</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                boolean notUploadedYet = localMedia != null</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                                         &amp;&amp; (localMedia.getUploadState() == null</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                                             || MediaUploadState.fromString(localMedia.getUploadState())</span>
                                                != MediaUploadState.UPLOADED);
<span class="nc bnc" id="L217" title="All 2 branches missed.">                if (notUploadedYet) {</span>
<span class="nc" id="L218">                    toBeUploadedMediaList.add(media);</span>
                }
<span class="nc" id="L220">            }</span>

<span class="nc bnc" id="L222" title="All 2 branches missed.">            for (MediaModel media : toBeUploadedMediaList) {</span>
<span class="nc" id="L223">                mMediaUploadHandler.upload(media);</span>
<span class="nc" id="L224">            }</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (!toBeUploadedMediaList.isEmpty()) {</span>
<span class="nc" id="L227">                mPostUploadNotifier.addMediaInfoToForegroundNotification(toBeUploadedMediaList);</span>
            }
        }
<span class="nc" id="L230">    }</span>

    private void registerPostModelsForMedia(List&lt;MediaModel&gt; mediaList, boolean isRetry) {
<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (mediaList != null &amp;&amp; !mediaList.isEmpty()) {</span>
<span class="nc" id="L234">            Set&lt;PostModel&gt; postsToRefresh = PostUtils.getPostsThatIncludeAnyOfTheseMedia(mPostStore, mediaList);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            for (PostImmutableModel post : postsToRefresh) {</span>
                // If the post is already registered, the new media will be added to its list
<span class="nc" id="L237">                mUploadStore.registerPostModel(post, mediaList);</span>
<span class="nc" id="L238">            }</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (isRetry) {</span>
                // Bump analytics
<span class="nc" id="L242">                AnalyticsTracker.track(AnalyticsTracker.Stat.NOTIFICATION_UPLOAD_MEDIA_ERROR_RETRY);</span>

                // send event so Editors can handle clearing Failed statuses properly if Post is being edited right now
<span class="nc" id="L245">                EventBus.getDefault().post(new UploadService.UploadMediaRetryEvent(mediaList));</span>
            }
        }
<span class="nc" id="L248">    }</span>

    private void unpackPostIntent(@NonNull Intent intent) {
<span class="nc" id="L251">        PostModel post = mPostStore.getPostByLocalPostId(intent.getIntExtra(KEY_LOCAL_POST_ID, 0));</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (post != null) {</span>
<span class="nc" id="L253">            boolean shouldTrackAnalytics = intent.getBooleanExtra(KEY_SHOULD_TRACK_ANALYTICS, false);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (shouldTrackAnalytics) {</span>
<span class="nc" id="L255">                mPostUploadHandler.registerPostForAnalyticsTracking(post.getId());</span>
            }

            // cancel any outstanding &quot;end&quot; notification for this Post before we start processing it again
            // i.e. dismiss success or error notification for the post.
<span class="nc" id="L260">            mPostUploadNotifier.cancelFinalNotification(this, post);</span>

            // if the user tapped on the PUBLISH quick action, make this Post publishable and track
            // analytics before starting the upload process.
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (intent.getBooleanExtra(KEY_CHANGE_STATUS_TO_PUBLISH, false)) {</span>
<span class="nc" id="L265">                SiteModel site = mSiteStore.getSiteByLocalId(post.getLocalSiteId());</span>
<span class="nc" id="L266">                makePostPublishable(post, site);</span>
<span class="nc" id="L267">                PostUtils.trackSavePostAnalytics(post, site);</span>
            }

<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (intent.getBooleanExtra(KEY_SHOULD_RETRY, false)) {</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">                if (AppPrefs.isAztecEditorEnabled() || AppPrefs.isGutenbergEditorEnabled()) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                    if (!NetworkUtils.isNetworkAvailable(this)) {</span>
<span class="nc" id="L273">                        rebuildNotificationError(post, getString(R.string.no_network_message));</span>
<span class="nc" id="L274">                        return;</span>
                    }
<span class="nc" id="L276">                    boolean postHasGutenbergBlocks = PostUtils.contentContainsGutenbergBlocks(post.getContent());</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                    retryUpload(post, !postHasGutenbergBlocks);</span>
<span class="nc" id="L278">                } else {</span>
<span class="nc" id="L279">                    ToastUtils.showToast(this, R.string.retry_needs_aztec);</span>
                }
<span class="nc" id="L281">                return;</span>
            }

            // is this a new post? only add count to the notification when the post is totally new
            // i.e. it still doesn't have any tracked state in the UploadStore
            // or it's a failed one the user is actively retrying.
<span class="nc bnc" id="L287" title="All 4 branches missed.">            if (isThisPostTotallyNewOrFailed(post) &amp;&amp; !PostUploadHandler.isPostUploadingOrQueued(post)) {</span>
<span class="nc" id="L288">                mPostUploadNotifier.addPostInfoToForegroundNotification(post, null);</span>
            }


<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (!getAllFailedMediaForPost(post).isEmpty()) {</span>
<span class="nc" id="L293">                boolean postHasGutenbergBlocks = PostUtils.contentContainsGutenbergBlocks(post.getContent());</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                retryUpload(post, !postHasGutenbergBlocks);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            } else if (hasPendingOrInProgressMediaUploadsForPost(post)) {</span>
                // Register the post (as PENDING) in the UploadStore, along with all media currently in progress for it
                // If the post is already registered, the new media will be added to its list
<span class="nc" id="L298">                List&lt;MediaModel&gt; activeMedia = MediaUploadHandler.getPendingOrInProgressMediaUploadsForPost(post);</span>
<span class="nc" id="L299">                mUploadStore.registerPostModel(post, activeMedia);</span>
<span class="nc" id="L300">            } else {</span>
<span class="nc" id="L301">                mPostUploadHandler.upload(post);</span>
            }
        }
<span class="nc" id="L304">    }</span>

    public static void cancelFinalNotification(Context context, PostImmutableModel post) {
        // cancel any outstanding &quot;end&quot; notification for this Post before we start processing it again
        // i.e. dismiss success or error notification for the post.
<span class="nc" id="L309">        PostUploadNotifier.cancelFinalNotification(context, post);</span>
<span class="nc" id="L310">    }</span>

    public static void cancelFinalNotificationForMedia(Context context, SiteModel site) {
<span class="nc" id="L313">        PostUploadNotifier.cancelFinalNotificationForMedia(context, site);</span>
<span class="nc" id="L314">    }</span>

    /**
     * Do not use this method unless the user explicitly confirmed changes - eg. clicked on publish button or
     * similar.
     */
    private void makePostPublishable(@NonNull PostModel post, SiteModel site) {
<span class="nc" id="L321">        PostUtils.preparePostForPublish(post, site);</span>
<span class="nc" id="L322">        mDispatcher.dispatch(PostActionBuilder.newUpdatePostAction(post));</span>
<span class="nc" id="L323">    }</span>

    private boolean isThisPostTotallyNewOrFailed(PostImmutableModel post) {
        // if we have any tracks for this Post's UploadState, this means this Post is not new.
        // Conditions under which the UploadStore would contain traces of this Post's UploadState are:
        // - it's been cancelled by entering/exiting/entering the editor thus cancelling the queued post upload
        // to allow for the user to keep editing it before sending to the server
        // - it's a failed upload (due to some network issue, for example)
        // - it's a pending upload (it is currently registered for upload once the associated media finishes
        // uploading).
<span class="nc bnc" id="L333" title="All 4 branches missed.">        return !mUploadStore.isRegisteredPostModel(post) || (mUploadStore.isFailedPost(post) || mUploadStore</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                .isPendingPost(post));</span>
    }

    public static Intent getRetryUploadServiceIntent(Context context, @NonNull PostImmutableModel post,
                                                     boolean trackAnalytics) {
<span class="nc" id="L339">        Intent intent = new Intent(context, UploadService.class);</span>
<span class="nc" id="L340">        intent.putExtra(KEY_LOCAL_POST_ID, post.getId());</span>
<span class="nc" id="L341">        intent.putExtra(KEY_SHOULD_TRACK_ANALYTICS, trackAnalytics);</span>
<span class="nc" id="L342">        intent.putExtra(KEY_SHOULD_RETRY, true);</span>
<span class="nc" id="L343">        return intent;</span>
    }

    /**
     * Do not use this method unless the user explicitly confirmed changes - eg. clicked on publish button or
     * similar.
     *
     * The only valid use-case for this method I can think of right know is when we want to put the intent into a
     * PendingIntent - eg. publish action on a notification. If you want to start the upload right away use
     * UploadUtils.publishPost(..) instead.
     */
    public static Intent getPublishPostServiceIntent(Context context, @NonNull PostImmutableModel post,
                                                     boolean trackAnalytics) {
<span class="nc" id="L356">        Intent intent = new Intent(context, UploadService.class);</span>
<span class="nc" id="L357">        intent.putExtra(KEY_LOCAL_POST_ID, post.getId());</span>
<span class="nc" id="L358">        intent.putExtra(KEY_SHOULD_TRACK_ANALYTICS, trackAnalytics);</span>
<span class="nc" id="L359">        intent.putExtra(KEY_CHANGE_STATUS_TO_PUBLISH, true);</span>
<span class="nc" id="L360">        return intent;</span>
    }

    public static Intent getUploadMediaServiceIntent(Context context, @NonNull ArrayList&lt;MediaModel&gt; mediaList,
                                                     boolean isRetry) {
<span class="nc" id="L365">        Intent intent = new Intent(context, UploadService.class);</span>
<span class="nc" id="L366">        intent.putExtra(UploadService.KEY_MEDIA_LIST, mediaList);</span>
<span class="nc" id="L367">        intent.putExtra(KEY_SHOULD_RETRY, isRetry);</span>
<span class="nc" id="L368">        return intent;</span>
    }

    /**
     * Adds a post to the queue.
     * @param postId
     * @param isFirstTimePublish true when its status changes from local draft or remote draft to published.
     */
    public static void uploadPost(Context context, int postId, boolean isFirstTimePublish) {
<span class="nc" id="L377">        Intent intent = new Intent(context, UploadService.class);</span>
<span class="nc" id="L378">        intent.putExtra(KEY_LOCAL_POST_ID, postId);</span>
<span class="nc" id="L379">        intent.putExtra(KEY_SHOULD_TRACK_ANALYTICS, isFirstTimePublish);</span>
<span class="nc" id="L380">        context.startService(intent);</span>
<span class="nc" id="L381">    }</span>

    public static void uploadMedia(Context context, @NonNull MediaModel media) {
<span class="nc" id="L384">        ArrayList&lt;MediaModel&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L385">        list.add(media);</span>

<span class="nc" id="L387">        uploadMedia(context, list);</span>
<span class="nc" id="L388">    }</span>

    public static void uploadMedia(Context context, @NonNull ArrayList&lt;MediaModel&gt; mediaList) {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L392">            return;</span>
        }

<span class="nc" id="L395">        Intent intent = new Intent(context, UploadService.class);</span>
<span class="nc" id="L396">        intent.putExtra(UploadService.KEY_MEDIA_LIST, mediaList);</span>
<span class="nc" id="L397">        context.startService(intent);</span>
<span class="nc" id="L398">    }</span>

    public static void uploadMediaFromEditor(Context context, @NonNull ArrayList&lt;MediaModel&gt; mediaList) {
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L402">            return;</span>
        }

<span class="nc" id="L405">        Intent intent = new Intent(context, UploadService.class);</span>
<span class="nc" id="L406">        intent.putExtra(UploadService.KEY_MEDIA_LIST, mediaList);</span>
<span class="nc" id="L407">        intent.putExtra(UploadService.KEY_UPLOAD_MEDIA_FROM_EDITOR, true);</span>
<span class="nc" id="L408">        context.startService(intent);</span>
<span class="nc" id="L409">    }</span>

    /**
     * Returns true if the passed post is either currently uploading or waiting to be uploaded.
     * Except for legacy mode, a post counts as 'uploading' if the post content itself is being uploaded - a post
     * waiting for media to finish uploading counts as 'waiting to be uploaded' until the media uploads complete.
     */
    public static boolean isPostUploadingOrQueued(PostImmutableModel post) {
<span class="nc" id="L417">        UploadService instance = sInstance;</span>
<span class="nc bnc" id="L418" title="All 4 branches missed.">        if (instance == null || post == null) {</span>
<span class="nc" id="L419">            return false;</span>
        }

        // First check for posts uploading or queued inside the PostUploadManager
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (PostUploadHandler.isPostUploadingOrQueued(post)) {</span>
<span class="nc" id="L424">            return true;</span>
        }

        // Then check the list of posts waiting for media to complete
<span class="nc" id="L428">        return instance.mUploadStore.isPendingPost(post);</span>
    }

    public static boolean isPostQueued(PostImmutableModel post) {
        // Check for posts queued inside the PostUploadManager
<span class="nc bnc" id="L433" title="All 4 branches missed.">        return sInstance != null &amp;&amp; PostUploadHandler.isPostQueued(post);</span>
    }

    /**
     * Returns true if the passed post is currently uploading.
     * Except for legacy mode, a post counts as 'uploading' if the post content itself is being uploaded - a post
     * waiting for media to finish uploading counts as 'waiting to be uploaded' until the media uploads complete.
     */
    public static boolean isPostUploading(PostImmutableModel post) {
<span class="nc bnc" id="L442" title="All 4 branches missed.">        return sInstance != null &amp;&amp; PostUploadHandler.isPostUploading(post);</span>
    }

    public static void cancelQueuedPostUploadAndRelatedMedia(Context context, PostModel post) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (post != null) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (sInstance != null) {</span>
<span class="nc" id="L448">                PostUploadNotifier.cancelFinalNotification(sInstance, post);</span>
<span class="nc" id="L449">                sInstance.mPostUploadNotifier.removePostInfoFromForegroundNotification(</span>
<span class="nc" id="L450">                        post, sInstance.mMediaStore.getMediaForPost(post));</span>
            } else {
<span class="nc" id="L452">                PostUploadNotifier.cancelFinalNotification(context, post);</span>
            }
<span class="nc" id="L454">            cancelQueuedPostUpload(post);</span>
<span class="nc" id="L455">            EventBus.getDefault().post(new PostEvents.PostMediaCanceled(post));</span>
        }
<span class="nc" id="L457">    }</span>

    public static void cancelQueuedPostUpload(PostModel post) {
<span class="nc bnc" id="L460" title="All 4 branches missed.">        if (sInstance != null &amp;&amp; post != null) {</span>
            // Mark the post as CANCELLED in the UploadStore
<span class="nc" id="L462">            sInstance.mDispatcher.dispatch(UploadActionBuilder.newCancelPostAction(post));</span>
        }
<span class="nc" id="L464">    }</span>

    public static PostModel updatePostWithCurrentlyCompletedUploads(PostModel post) {
<span class="nc bnc" id="L467" title="All 4 branches missed.">        if (post != null &amp;&amp; sInstance != null) {</span>
            // now get the list of completed media for this post, so we can make post content
            // updates in one go and save only once
<span class="nc" id="L470">            MediaUploadReadyListener processor = new MediaUploadReadyProcessor();</span>
<span class="nc" id="L471">            Set&lt;MediaModel&gt; completedMedia = sInstance.mUploadStore.getCompletedMediaForPost(post);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            for (MediaModel media : completedMedia) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (media.getMarkedLocallyAsFeatured()) {</span>
<span class="nc" id="L474">                    post = updatePostWithNewFeaturedImg(post, media.getMediaId());</span>
                } else {
<span class="nc" id="L476">                    post = updatePostWithMediaUrl(post, media, processor);</span>
                }
<span class="nc" id="L478">            }</span>

<span class="nc bnc" id="L480" title="All 4 branches missed.">            if (completedMedia != null &amp;&amp; !completedMedia.isEmpty()) {</span>
                // finally remove all completed uploads for this post, as they've been taken care of
<span class="nc" id="L482">                ClearMediaPayload clearMediaPayload = new ClearMediaPayload(post, completedMedia);</span>
<span class="nc" id="L483">                sInstance.mDispatcher.dispatch(UploadActionBuilder.newClearMediaForPostAction(clearMediaPayload));</span>
            }
        }
<span class="nc" id="L486">        return post;</span>
    }

    public static PostModel updatePostWithCurrentlyFailedUploads(PostModel post) {
<span class="nc bnc" id="L490" title="All 4 branches missed.">        if (post != null &amp;&amp; sInstance != null) {</span>
            // now get the list of failed media for this post, so we can make post content
            // updates in one go and save only once
<span class="nc" id="L493">            MediaUploadReadyListener processor = new MediaUploadReadyProcessor();</span>
<span class="nc" id="L494">            Set&lt;MediaModel&gt; failedMedia = sInstance.mUploadStore.getFailedMediaForPost(post);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            for (MediaModel media : failedMedia) {</span>
<span class="nc" id="L496">                post = updatePostWithFailedMedia(post, media, processor);</span>
<span class="nc" id="L497">            }</span>
            // Unlike completed media, we won't remove the failed media references, so we can look up their errors later
        }
<span class="nc" id="L500">        return post;</span>
    }

    public static boolean hasInProgressMediaUploadsForPost(PostImmutableModel postModel) {
<span class="nc bnc" id="L504" title="All 4 branches missed.">        return postModel != null &amp;&amp; MediaUploadHandler.hasInProgressMediaUploadsForPost(postModel.getId());</span>
    }

    public static boolean hasPendingMediaUploadsForPost(PostImmutableModel postModel) {
<span class="nc bnc" id="L508" title="All 4 branches missed.">        return postModel != null &amp;&amp; MediaUploadHandler.hasPendingMediaUploadsForPost(postModel.getId());</span>
    }

    public static boolean hasPendingOrInProgressMediaUploadsForPost(PostImmutableModel postModel) {
<span class="nc bnc" id="L512" title="All 4 branches missed.">        return postModel != null &amp;&amp; MediaUploadHandler.hasPendingOrInProgressMediaUploadsForPost(postModel.getId());</span>
    }

    public static MediaModel getPendingOrInProgressFeaturedImageUploadForPost(PostImmutableModel postModel) {
<span class="nc" id="L516">        return MediaUploadHandler.getPendingOrInProgressFeaturedImageUploadForPost(postModel);</span>
    }

    public static List&lt;MediaModel&gt; getPendingOrInProgressMediaUploadsForPost(PostImmutableModel post) {
<span class="nc" id="L520">        return MediaUploadHandler.getPendingOrInProgressMediaUploadsForPost(post);</span>
    }

    public static float getMediaUploadProgressForPost(PostModel postModel) {
<span class="nc" id="L524">        UploadService instance = sInstance;</span>
<span class="nc bnc" id="L525" title="All 4 branches missed.">        if (postModel == null || instance == null) {</span>
            // If the UploadService isn't running, there's no progress for this post
<span class="nc" id="L527">            return 0;</span>
        }

<span class="nc" id="L530">        Set&lt;MediaModel&gt; pendingMediaList = instance.mUploadStore.getUploadingMediaForPost(postModel);</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (pendingMediaList.size() == 0) {</span>
<span class="nc" id="L533">            return 1;</span>
        }

<span class="nc" id="L536">        float overallProgress = 0;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (MediaModel pendingMedia : pendingMediaList) {</span>
<span class="nc" id="L538">            overallProgress += getUploadProgressForMedia(pendingMedia);</span>
<span class="nc" id="L539">        }</span>
<span class="nc" id="L540">        overallProgress /= pendingMediaList.size();</span>

<span class="nc" id="L542">        return overallProgress;</span>
    }

    public static float getUploadProgressForMedia(MediaModel mediaModel) {
<span class="nc" id="L546">        UploadService instance = sInstance;</span>
<span class="nc bnc" id="L547" title="All 4 branches missed.">        if (mediaModel == null || instance == null) {</span>
            // If the UploadService isn't running, there's no progress for this media
<span class="nc" id="L549">            return 0;</span>
        }

<span class="nc" id="L552">        float uploadProgress = instance.mUploadStore.getUploadProgressForMedia(mediaModel);</span>

        // If this is a video and video optimization is enabled, include the optimization progress in the outcome
<span class="nc bnc" id="L555" title="All 4 branches missed.">        if (mediaModel.isVideo() &amp;&amp; WPMediaUtils.isVideoOptimizationEnabled()) {</span>
<span class="nc" id="L556">            return MediaUploadHandler.getOverallProgressForVideo(mediaModel.getId(), uploadProgress);</span>
        }

<span class="nc" id="L559">        return uploadProgress;</span>
    }

    public static @NonNull
    Set&lt;MediaModel&gt; getPendingMediaForPost(PostModel postModel) {
<span class="nc" id="L564">        UploadService instance = sInstance;</span>
<span class="nc bnc" id="L565" title="All 4 branches missed.">        if (postModel == null || instance == null) {</span>
<span class="nc" id="L566">            return Collections.emptySet();</span>
        }
<span class="nc" id="L568">        return instance.mUploadStore.getUploadingMediaForPost(postModel);</span>
    }

    public static boolean isPendingOrInProgressMediaUpload(@NonNull MediaModel media) {
<span class="nc" id="L572">        return MediaUploadHandler.isPendingOrInProgressMediaUpload(media.getId());</span>
    }

    /**
     * Rechecks all media in the MediaStore marked UPLOADING/QUEUED against the UploadingService to see
     * if it's actually uploading or queued and change it accordingly, to recover from an inconsistent state
     */
    public static void sanitizeMediaUploadStateForSite(@NonNull MediaStore mediaStore, @NonNull Dispatcher dispatcher,
                                                       @NonNull SiteModel site) {
<span class="fc" id="L581">        List&lt;MediaModel&gt; uploadingMedia =</span>
<span class="fc" id="L582">                mediaStore.getSiteMediaWithState(site, MediaUploadState.UPLOADING);</span>
<span class="fc" id="L583">        List&lt;MediaModel&gt; queuedMedia =</span>
<span class="fc" id="L584">                mediaStore.getSiteMediaWithState(site, MediaUploadState.QUEUED);</span>

<span class="pc bpc" id="L586" title="2 of 4 branches missed.">        if (uploadingMedia.isEmpty() &amp;&amp; queuedMedia.isEmpty()) {</span>
<span class="fc" id="L587">            return;</span>
        }

<span class="nc" id="L590">        List&lt;MediaModel&gt; uploadingOrQueuedMedia = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L591">        uploadingOrQueuedMedia.addAll(uploadingMedia);</span>
<span class="nc" id="L592">        uploadingOrQueuedMedia.addAll(queuedMedia);</span>

<span class="nc bnc" id="L594" title="All 2 branches missed.">        for (final MediaModel media : uploadingOrQueuedMedia) {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (!UploadService.isPendingOrInProgressMediaUpload(media)) {</span>
                // it is NOT being uploaded or queued in the actual UploadService, mark it failed
<span class="nc" id="L597">                media.setUploadState(MediaUploadState.FAILED);</span>
<span class="nc" id="L598">                dispatcher.dispatch(MediaActionBuilder.newUpdateMediaAction(media));</span>
            }
<span class="nc" id="L600">        }</span>
<span class="nc" id="L601">    }</span>

    private static synchronized PostModel updatePostWithNewFeaturedImg(PostModel post, Long remoteMediaId) {
<span class="nc bnc" id="L604" title="All 4 branches missed.">        if (post != null &amp;&amp; remoteMediaId != null) {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">            boolean changesConfirmed = post.contentHashcode() == post.getChangesConfirmedContentHashcode();</span>
<span class="nc" id="L606">            post.setFeaturedImageId(remoteMediaId);</span>
<span class="nc" id="L607">            post.setIsLocallyChanged(true);</span>
<span class="nc" id="L608">            post.setDateLocallyChanged(DateTimeUtils.iso8601UTCFromTimestamp(System.currentTimeMillis() / 1000));</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (changesConfirmed) {</span>
                /*
                 * We are replacing local featured image with a remote version. We need to make sure
                 * to retain the confirmation state.
                 */
<span class="nc" id="L614">                post.setChangesConfirmedContentHashcode(post.contentHashcode());</span>
            }
        }
<span class="nc" id="L617">        return post;</span>
    }
    private static synchronized PostModel updatePostWithMediaUrl(PostModel post, MediaModel media,
                                                                 MediaUploadReadyListener processor) {
<span class="nc bnc" id="L621" title="All 8 branches missed.">        if (media != null &amp;&amp; post != null &amp;&amp; processor != null &amp;&amp; sInstance != null) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            boolean changesConfirmed = post.contentHashcode() == post.getChangesConfirmedContentHashcode();</span>

            // obtain site url used to generate attachment page url
<span class="nc" id="L625">            SiteModel site = sInstance.mSiteStore.getSiteByLocalId(media.getLocalSiteId());</span>

            // actually replace the media ID with the media uri
<span class="nc" id="L628">            processor.replaceMediaFileWithUrlInPost(post, String.valueOf(media.getId()),</span>
<span class="nc" id="L629">                    FluxCUtils.mediaFileFromMediaModel(media), site);</span>

            // we changed the post, so let’s mark this down
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (!post.isLocalDraft()) {</span>
<span class="nc" id="L633">                post.setIsLocallyChanged(true);</span>
            }
<span class="nc" id="L635">            post.setDateLocallyChanged(DateTimeUtils.iso8601UTCFromTimestamp(System.currentTimeMillis() / 1000));</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (changesConfirmed) {</span>
                /*
                 * We are replacing image local path with a url. We need to make sure to retain the confirmation
                 * state.
                 */
<span class="nc" id="L641">                post.setChangesConfirmedContentHashcode(post.contentHashcode());</span>
            }
        }
<span class="nc" id="L644">        return post;</span>
    }

    private static synchronized PostModel updatePostWithFailedMedia(PostModel post, MediaModel media,
                                                                    MediaUploadReadyListener processor) {
<span class="nc bnc" id="L649" title="All 6 branches missed.">        if (media != null &amp;&amp; post != null &amp;&amp; processor != null) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            boolean changesConfirmed = post.contentHashcode() == post.getChangesConfirmedContentHashcode();</span>
            // actually mark the media failed within the Post
<span class="nc" id="L652">            processor.markMediaUploadFailedInPost(post, String.valueOf(media.getId()),</span>
<span class="nc" id="L653">                    FluxCUtils.mediaFileFromMediaModel(media));</span>

            // we changed the post, so let’s mark this down
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if (!post.isLocalDraft()) {</span>
<span class="nc" id="L657">                post.setIsLocallyChanged(true);</span>
            }
<span class="nc" id="L659">            post.setDateLocallyChanged(DateTimeUtils.iso8601UTCFromTimestamp(System.currentTimeMillis() / 1000));</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (changesConfirmed) {</span>
                /*
                 * We are updating media upload status, but we don't make any undesired changes to the post. We need to
                 * make sure to retain the confirmation state.
                 */
<span class="nc" id="L665">                post.setChangesConfirmedContentHashcode(post.contentHashcode());</span>
            }
        }
<span class="nc" id="L668">        return post;</span>
    }

    private synchronized void stopServiceIfUploadsComplete() {
<span class="nc" id="L672">        stopServiceIfUploadsComplete(null, null);</span>
<span class="nc" id="L673">    }</span>


    private synchronized void stopServiceIfUploadsComplete(Boolean isError, PostModel post) {
<span class="nc bnc" id="L677" title="All 4 branches missed.">        if (mPostUploadHandler != null &amp;&amp; mPostUploadHandler.hasInProgressUploads()) {</span>
<span class="nc" id="L678">            return;</span>
        }

<span class="nc bnc" id="L681" title="All 4 branches missed.">        if (mMediaUploadHandler != null &amp;&amp; mMediaUploadHandler.hasInProgressUploads()) {</span>
<span class="nc" id="L682">            return;</span>
        } else {
<span class="nc" id="L684">            verifyMediaOnlyUploadsAndNotify();</span>
        }

<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (doFinalProcessingOfPosts(isError, post)) {</span>
            // when more Posts have been re-enqueued, don't stop the service just yet.
<span class="nc" id="L689">            return;</span>
        }

<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (!mUploadStore.getPendingPosts().isEmpty()) {</span>
<span class="nc" id="L693">            return;</span>
        }

<span class="nc" id="L696">        AppLog.i(T.MAIN, &quot;UploadService &gt; Completed&quot;);</span>
<span class="nc" id="L697">        stopSelf();</span>
<span class="nc" id="L698">    }</span>


    private void verifyMediaOnlyUploadsAndNotify() {
        // check if all are successful uploads, then notify the user about it
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (!mMediaBatchUploaded.isEmpty()) {</span>
<span class="nc" id="L704">            ArrayList&lt;MediaModel&gt; standAloneMediaItems = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            for (MediaModel media : mMediaBatchUploaded) {</span>
                // we need to obtain the latest copy from the Store, as it's got the remote mediaId field
<span class="nc" id="L707">                MediaModel currentMedia = mMediaStore.getMediaWithLocalId(media.getId());</span>
<span class="nc bnc" id="L708" title="All 4 branches missed.">                if (currentMedia != null &amp;&amp; currentMedia.getLocalPostId() == 0</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                    &amp;&amp; MediaUploadState.fromString(currentMedia.getUploadState())</span>
                       == MediaUploadState.UPLOADED) {
<span class="nc" id="L711">                    standAloneMediaItems.add(currentMedia);</span>
                }
<span class="nc" id="L713">            }</span>

<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (!standAloneMediaItems.isEmpty()) {</span>
<span class="nc" id="L716">                SiteModel site = mSiteStore.getSiteByLocalId(standAloneMediaItems.get(0).getLocalSiteId());</span>
<span class="nc" id="L717">                mPostUploadNotifier.updateNotificationSuccessForMedia(standAloneMediaItems, site);</span>
<span class="nc" id="L718">                mMediaBatchUploaded.clear();</span>
            }
        }
<span class="nc" id="L721">    }</span>

    private PostModel updateOnePostModelWithCompletedAndFailedUploads(PostModel postModel) {
<span class="nc" id="L724">        PostModel updatedPost = updatePostWithCurrentlyCompletedUploads(postModel);</span>
        // also do the same now with failed uploads
<span class="nc" id="L726">        updatedPost = updatePostWithCurrentlyFailedUploads(updatedPost);</span>
        // finally, save the PostModel
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (updatedPost != null) {</span>
<span class="nc" id="L729">            mDispatcher.dispatch(PostActionBuilder.newUpdatePostAction(updatedPost));</span>
        }
<span class="nc" id="L731">        return updatedPost;</span>
    }

    private boolean mediaBelongsToAPost(MediaModel media) {
<span class="nc" id="L735">        PostModel postToCancel = mPostStore.getPostByLocalPostId(media.getLocalPostId());</span>
<span class="nc bnc" id="L736" title="All 4 branches missed.">        return (postToCancel != null &amp;&amp; mUploadStore.isRegisteredPostModel(postToCancel));</span>
    }

    /*
        returns true if Post canceled
        returns false if Post can't be found or is not registered in the UploadStore
     */
    private boolean cancelPostUploadMatchingMedia(@NonNull MediaModel media, String errorMessage, boolean showError) {
<span class="nc" id="L744">        PostModel postToCancel = mPostStore.getPostByLocalPostId(media.getLocalPostId());</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (postToCancel == null) {</span>
<span class="nc" id="L746">            return false;</span>
        }

<span class="nc bnc" id="L749" title="All 2 branches missed.">        if (!mUploadStore.isRegisteredPostModel(postToCancel)) {</span>
<span class="nc" id="L750">            return false;</span>
        }

<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (PostUploadHandler.isPostUploadingOrQueued(postToCancel) &amp;&amp; !PostUtils</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                .isPostCurrentlyBeingEdited(postToCancel)) {</span>
            // post is not being edited and is currently queued, update the count on the foreground notification
<span class="nc" id="L756">            mPostUploadNotifier.incrementUploadedPostCountFromForegroundNotification(postToCancel);</span>
        }

<span class="nc bnc" id="L759" title="All 4 branches missed.">        if (showError || mUploadStore.isFailedPost(postToCancel)) {</span>
            // Only show the media upload error notification if the post is NOT registered in the UploadStore
            // - otherwise if it IS registered in the UploadStore and we get a `cancelled` signal it means
            // the user actively cancelled it. No need to show an error then.
<span class="nc" id="L763">            String message = UploadUtils.getErrorMessage(this, postToCancel.isPage(), errorMessage, true);</span>
<span class="nc" id="L764">            SiteModel site = mSiteStore.getSiteByLocalId(postToCancel.getLocalSiteId());</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            if (site != null) {</span>
<span class="nc" id="L766">                mPostUploadNotifier.updateNotificationErrorForPost(postToCancel, site, message,</span>
<span class="nc" id="L767">                        mUploadStore.getFailedMediaForPost(postToCancel).size());</span>
            } else {
<span class="nc" id="L769">                AppLog.e(T.POSTS, &quot;Trying to update notifications with missing site&quot;);</span>
            }
        }

<span class="nc" id="L773">        mPostUploadHandler.unregisterPostForAnalyticsTracking(postToCancel.getId());</span>
<span class="nc" id="L774">        EventBus.getDefault().post(new PostEvents.PostUploadCanceled(postToCancel));</span>

<span class="nc" id="L776">        return true;</span>
    }

    private void rebuildNotificationError(PostModel post, String errorMessage) {
<span class="nc" id="L780">        Set&lt;MediaModel&gt; failedMedia = mUploadStore.getFailedMediaForPost(post);</span>
<span class="nc" id="L781">        mPostUploadNotifier.setTotalMediaItems(post, failedMedia.size());</span>
<span class="nc" id="L782">        SiteModel site = mSiteStore.getSiteByLocalId(post.getLocalSiteId());</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (site != null) {</span>
<span class="nc" id="L784">            mPostUploadNotifier.updateNotificationErrorForPost(post, site, errorMessage, 0);</span>
        } else {
<span class="nc" id="L786">            AppLog.e(T.POSTS, &quot;Trying to rebuild notification error without a site&quot;);</span>
        }
<span class="nc" id="L788">    }</span>

    private void aztecRegisterFailedMediaForThisPost(PostModel post) {
        // there could be failed media in the post, that has not been registered in the UploadStore because
        // the media was being uploaded separately (i.e. the user included media, started uploading within
        // the editor, and such media failed _before_ exiting the eidtor, thus the registration never happened.
        // We're recovering the information here so we make sure to rebuild the status only when the user taps
        // on Retry.
<span class="nc" id="L796">        List&lt;String&gt; mediaIds = AztecEditorFragment.getMediaMarkedFailedInPostContent(this, post.getContent());</span>

<span class="nc bnc" id="L798" title="All 4 branches missed.">        if (mediaIds != null &amp;&amp; !mediaIds.isEmpty()) {</span>
<span class="nc" id="L799">            ArrayList&lt;MediaModel&gt; mediaList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            for (String mediaId : mediaIds) {</span>
<span class="nc" id="L801">                MediaModel media = mMediaStore.getMediaWithLocalId(StringUtils.stringToInt(mediaId));</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">                if (media != null) {</span>
<span class="nc" id="L803">                    mediaList.add(media);</span>
                    // if this media item didn't have the Postid set, let's set it as we found it
                    // in the Post body anyway. So let's fix that now.
<span class="nc bnc" id="L806" title="All 2 branches missed.">                    if (media.getLocalPostId() == 0) {</span>
<span class="nc" id="L807">                        media.setLocalPostId(post.getId());</span>
<span class="nc" id="L808">                        mDispatcher.dispatch(MediaActionBuilder.newUpdateMediaAction(media));</span>
                    }
                }
<span class="nc" id="L811">            }</span>

<span class="nc bnc" id="L813" title="All 2 branches missed.">            if (!mediaList.isEmpty()) {</span>
                // given we found failed media within this Post, let's also cancel the media error
<span class="nc" id="L815">                mPostUploadNotifier</span>
<span class="nc" id="L816">                        .cancelFinalNotificationForMedia(this, mSiteStore.getSiteByLocalId(post.getLocalSiteId()));</span>

                // now we have a list. Let' register this list.
<span class="nc" id="L819">                mUploadStore.registerPostModel(post, mediaList);</span>
            }
        }
<span class="nc" id="L822">    }</span>

    private void retryUpload(PostModel post, boolean processWithAztec) {
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (mUploadStore.isPendingPost(post)) {</span>
            // The post is already pending upload so there is no need to manually retry it. Actually, the retry might
            // result in the post being uploaded without its media. As if the media upload is in progress, the
            // `getAllFailedMediaForPost()` methods returns an empty set. If we invoke `mPostUploadHandler.upload()`
            // the post will be uploaded ignoring its media (we could upload content with paths to local storage).
<span class="nc" id="L830">            return;</span>
        }
<span class="nc" id="L832">        AnalyticsTracker.track(AnalyticsTracker.Stat.NOTIFICATION_UPLOAD_POST_ERROR_RETRY);</span>

<span class="nc bnc" id="L834" title="All 2 branches missed.">        if (processWithAztec) {</span>
<span class="nc" id="L835">            aztecRegisterFailedMediaForThisPost(post);</span>
        }

<span class="nc" id="L838">        List&lt;MediaModel&gt; mediaToRetry = getAllFailedMediaForPost(post);</span>

<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (!mediaToRetry.isEmpty()) {</span>
            // reset these media items to QUEUED
<span class="nc bnc" id="L842" title="All 2 branches missed.">            for (MediaModel media : mediaToRetry) {</span>
<span class="nc" id="L843">                media.setUploadState(MediaUploadState.QUEUED);</span>
<span class="nc" id="L844">                mDispatcher.dispatch(MediaActionBuilder.newUpdateMediaAction(media));</span>
<span class="nc" id="L845">            }</span>

<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (processWithAztec) {</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                boolean changesConfirmed = post.contentHashcode() == post.getChangesConfirmedContentHashcode();</span>

                // do the same within the Post content itself
<span class="nc" id="L851">                String postContentWithRestartedUploads =</span>
<span class="nc" id="L852">                        AztecEditorFragment.restartFailedMediaToUploading(this, post.getContent());</span>
<span class="nc" id="L853">                post.setContent(postContentWithRestartedUploads);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                if (changesConfirmed) {</span>
                    /*
                     * We are updating media upload status, but we don't make any undesired changes to the post. We
                     * need to make sure to retain the confirmation state.
                     */
<span class="nc" id="L859">                    post.setChangesConfirmedContentHashcode(post.contentHashcode());</span>
                }
<span class="nc" id="L861">                mDispatcher.dispatch(PostActionBuilder.newUpdatePostAction(post));</span>
            }

            // retry uploading media items
<span class="nc bnc" id="L865" title="All 2 branches missed.">            for (MediaModel media : mediaToRetry) {</span>
<span class="nc" id="L866">                mMediaUploadHandler.upload(media);</span>
<span class="nc" id="L867">            }</span>

            // Register the post (as PENDING) in the UploadStore, along with all media currently in progress for it
            // If the post is already registered, the new media will be added to its list
<span class="nc" id="L871">            mUploadStore.registerPostModel(post, mediaToRetry);</span>
<span class="nc" id="L872">            mPostUploadNotifier.addPostInfoToForegroundNotification(post, mediaToRetry);</span>

            // send event so Editors can handle clearing Failed statuses properly if Post is being edited right now
<span class="nc" id="L875">            EventBus.getDefault().post(new UploadService.UploadMediaRetryEvent(mediaToRetry));</span>
        } else {
<span class="nc" id="L877">            mPostUploadNotifier.addPostInfoToForegroundNotification(post, null);</span>
            // retry uploading the Post
<span class="nc" id="L879">            mPostUploadHandler.upload(post);</span>
        }
<span class="nc" id="L881">    }</span>

    private List&lt;MediaModel&gt; getAllFailedMediaForPost(PostModel postModel) {
<span class="nc" id="L884">        Set&lt;MediaModel&gt; failedMedia = mUploadStore.getFailedMediaForPost(postModel);</span>
<span class="nc" id="L885">        return filterOutRecentlyDeletedMedia(failedMedia);</span>
    }

    private List&lt;MediaModel&gt; filterOutRecentlyDeletedMedia(Set&lt;MediaModel&gt; failedMedia) {
<span class="nc" id="L889">        List&lt;MediaModel&gt; mediaToRetry = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">        for (MediaModel mediaModel : failedMedia) {</span>
<span class="nc" id="L891">            String mediaIdToCompare = String.valueOf(mediaModel.getId());</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (!mUserDeletedMediaItemIds.contains(mediaIdToCompare)) {</span>
<span class="nc" id="L893">                mediaToRetry.add(mediaModel);</span>
            }
<span class="nc" id="L895">        }</span>
<span class="nc" id="L896">        return mediaToRetry;</span>
    }

    /**
     * Has lower priority than the UploadHandlers, which ensures that the handlers have already received and
     * processed this OnMediaUploaded event. This means we can safely rely on their internal state being up to date.
     */
    @SuppressWarnings(&quot;unused&quot;)
    @Subscribe(threadMode = ThreadMode.MAIN, priority = 7)
    public void onMediaUploaded(OnMediaUploaded event) {
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (event.media == null) {</span>
<span class="nc" id="L907">            return;</span>
        }

<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (event.isError()) {</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (event.media.getLocalPostId() &gt; 0) {</span>
<span class="nc" id="L912">                AppLog.w(T.MAIN, &quot;UploadService &gt; Media upload failed for post &quot; + event.media.getLocalPostId() + &quot; : &quot;</span>
                                 + event.error.type + &quot;: &quot; + event.error.message);
<span class="nc" id="L914">                String errorMessage = UploadUtils.getErrorMessageFromMediaError(this, event.media, event.error);</span>

<span class="nc" id="L916">                cancelPostUploadMatchingMedia(event.media, errorMessage, true);</span>
            }


<span class="nc bnc" id="L920" title="All 2 branches missed.">            if (!mediaBelongsToAPost(event.media)) {</span>
                // this media item doesn't belong to a Post
<span class="nc" id="L922">                mPostUploadNotifier.incrementUploadedMediaCountFromProgressNotification(event.media.getId());</span>
                // Only show the media upload error notification if the post is NOT registered in the UploadStore
                // - otherwise if it IS registered in the UploadStore and we get a `cancelled` signal it means
                // the user actively cancelled it. No need to show an error then.
<span class="nc" id="L926">                String message = UploadUtils.getErrorMessageFromMediaError(this, event.media, event.error);</span>

                // if media has a local site id, use that. If not, default to currently selected site.
<span class="nc bnc" id="L929" title="All 2 branches missed.">                int siteLocalId = event.media.getLocalSiteId() &gt; 0 ? event.media.getLocalSiteId()</span>
<span class="nc" id="L930">                        : mSelectedSiteRepository.getSelectedSiteLocalId(true);</span>
<span class="nc" id="L931">                SiteModel selectedSite = mSiteStore.getSiteByLocalId(siteLocalId);</span>

<span class="nc" id="L933">                List&lt;MediaModel&gt; failedStandAloneMedia = getRetriableStandaloneMedia(selectedSite);</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                if (failedStandAloneMedia.isEmpty()) {</span>
                    // if we couldn't get the failed media from the MediaStore, at least we know
                    // for sure we're handling the event for this specific media item, so throw an error
                    // notification for this particular media item travelling in event.media
<span class="nc" id="L938">                    failedStandAloneMedia.add(event.media);</span>
                }

<span class="nc" id="L941">                mPostUploadNotifier.updateNotificationErrorForMedia(failedStandAloneMedia,</span>
                        selectedSite, message);
            }
<span class="nc" id="L944">            stopServiceIfUploadsComplete();</span>
<span class="nc" id="L945">            return;</span>
        }

<span class="nc bnc" id="L948" title="All 2 branches missed.">        if (event.canceled) {</span>
            // remove this media item from the progress notification
<span class="nc bnc" id="L950" title="All 2 branches missed.">            if (sInstance != null) {</span>
<span class="nc" id="L951">                sInstance.mPostUploadNotifier.removeOneMediaItemInfoFromForegroundNotification();</span>
            }
<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (event.media.getLocalPostId() &gt; 0) {</span>
<span class="nc" id="L954">                AppLog.i(T.MAIN, &quot;UploadService &gt; Upload cancelled for post with id &quot; + event.media.getLocalPostId()</span>
<span class="nc" id="L955">                                 + &quot; - a media upload for this post has been cancelled, id: &quot; + event.media.getId());</span>
<span class="nc" id="L956">                cancelPostUploadMatchingMedia(event.media, getString(R.string.error_media_canceled), false);</span>
            }
<span class="nc" id="L958">            stopServiceIfUploadsComplete();</span>
<span class="nc" id="L959">            return;</span>
        }

<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (event.completed) {</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (event.media.getLocalPostId() != 0) {</span>
<span class="nc" id="L964">                AppLog.i(T.MAIN, &quot;UploadService &gt; Processing completed media with id &quot; + event.media.getId()</span>
<span class="nc" id="L965">                                 + &quot; and local post id &quot; + event.media.getLocalPostId());</span>
            }
<span class="nc" id="L967">            mPostUploadNotifier.incrementUploadedMediaCountFromProgressNotification(event.media.getId());</span>
<span class="nc" id="L968">            stopServiceIfUploadsComplete();</span>
        } else {
            // in-progress upload
            // Progress update
<span class="nc" id="L972">            mPostUploadNotifier.updateNotificationProgressForMedia(event.media, event.progress);</span>
        }
<span class="nc" id="L974">    }</span>

    /*
     * This method will make sure to keep the bodies of all Posts registered (*) in the UploadStore
     * up-to-date with their corresponding media item upload statuses (i.e. marking them failed or
     * successfully uploaded in the actual Post content to reflect what the UploadStore says).
     *
     * Finally, it will either cancel the Post upload from the queue and create an error notification
     * for the user if there are any failed media items for such a Post, or upload the Post if it's
     * in good shape.
     *
     * This method returns:
     * - `false` if all registered posts have no in-progress items, and at least one or more retriable
     * (failed) items are found in them (this, in other words, means all registered posts are found
     * in a `finalized` state other than &quot;UPLOADED&quot;).
     * - `true` if at least one registered Post is found that is in good conditions to be uploaded.
     *
     *
     * (*)`Registered` posts are posts that had media in them and are waiting to be uploaded once
     * their corresponding associated media is uploaded first.
     */
    private boolean doFinalProcessingOfPosts(Boolean isError, PostModel post) {
        // If this was the last media upload a post was waiting for, update the post content
        // This done for pending as well as cancelled and failed posts
<span class="nc bnc" id="L998" title="All 2 branches missed.">        for (PostModel postModel : mUploadStore.getAllRegisteredPosts()) {</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (mPostUtilsWrapper.isPostCurrentlyBeingEdited(postModel)) {</span>
                // Don't upload a Post that is being currently open in the Editor.
                // This fixes the issue on self-hosted sites when you have a queued post which couldn't be
                // remote autosaved. When you try to leave the editor without saving it will get stuck in queued
                // upload state. In case of the post still being edited we cancel any ongoing upload post action.
<span class="nc" id="L1004">                mDispatcher.dispatch(UploadActionBuilder.newCancelPostAction(post));</span>
<span class="nc" id="L1005">                continue;</span>
            }

<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if (!UploadService.hasPendingOrInProgressMediaUploadsForPost(postModel)) {</span>
                // Replace local with remote media in the post content
<span class="nc" id="L1010">                PostModel updatedPost = updateOnePostModelWithCompletedAndFailedUploads(postModel);</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                if (updatedPost != null) {</span>
                    // here let's check if there are any failed media
<span class="nc" id="L1013">                    Set&lt;MediaModel&gt; failedMedia = mUploadStore.getFailedMediaForPost(postModel);</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">                    if (!failedMedia.isEmpty()) {</span>
                        // this Post has failed media, don't upload it just yet,
                        // but tell the user about the error
<span class="nc" id="L1017">                        cancelQueuedPostUpload(postModel);</span>

                        // update error notification for Post, unless the media is in the user-deleted media set
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                        if (!isAllFailedMediaUserDeleted(failedMedia)) {</span>
<span class="nc" id="L1021">                            SiteModel site = mSiteStore.getSiteByLocalId(postModel.getLocalSiteId());</span>
<span class="nc" id="L1022">                            String message = UploadUtils</span>
<span class="nc" id="L1023">                                    .getErrorMessage(this, postModel.isPage(), getString(R.string.error_generic_error),</span>
                                            true);
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                            if (site != null) {</span>
<span class="nc" id="L1026">                                mPostUploadNotifier.updateNotificationErrorForPost(postModel, site, message, 0);</span>
                            } else {
<span class="nc" id="L1028">                                AppLog.e(T.POSTS, &quot;Error notification cannot be updated without a post&quot;);</span>
                            }
                        }

<span class="nc" id="L1032">                        mPostUploadHandler.unregisterPostForAnalyticsTracking(postModel.getId());</span>
<span class="nc" id="L1033">                        EventBus.getDefault().post(</span>
                                new PostEvents.PostUploadCanceled(postModel));
                    } else {
                        // Do not re-enqueue a post that has already failed
<span class="nc bnc" id="L1037" title="All 6 branches missed.">                        if (isError != null &amp;&amp; isError &amp;&amp; mUploadStore.isFailedPost(updatedPost)) {</span>
<span class="nc" id="L1038">                            continue;</span>
                        }
                        // TODO Should do some extra validation here
                        // e.g. what if the post has local media URLs but no pending media uploads?
<span class="nc" id="L1042">                        mPostUploadHandler.upload(updatedPost);</span>
<span class="nc" id="L1043">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L1047">        }</span>
<span class="nc" id="L1048">        return false;</span>
    }

    private boolean isAllFailedMediaUserDeleted(Set&lt;MediaModel&gt; failedMediaSet) {
<span class="nc bnc" id="L1052" title="All 4 branches missed.">        if (failedMediaSet != null &amp;&amp; failedMediaSet.size() == mUserDeletedMediaItemIds.size()) {</span>
<span class="nc" id="L1053">            int numberOfMatches = 0;</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            for (MediaModel media : failedMediaSet) {</span>
<span class="nc" id="L1055">                String mediaIdToCompare = String.valueOf(media.getId());</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                if (mUserDeletedMediaItemIds.contains(mediaIdToCompare)) {</span>
<span class="nc" id="L1057">                    numberOfMatches++;</span>
                }
<span class="nc" id="L1059">            }</span>

<span class="nc bnc" id="L1061" title="All 2 branches missed.">            if (numberOfMatches == mUserDeletedMediaItemIds.size()) {</span>
<span class="nc" id="L1062">                return true;</span>
            }
        }
<span class="nc" id="L1065">        return false;</span>
    }

    public static void setDeletedMediaItemIds(List&lt;String&gt; mediaIds) {
<span class="nc" id="L1069">        mUserDeletedMediaItemIds.clear();</span>
<span class="nc" id="L1070">        mUserDeletedMediaItemIds.addAll(mediaIds);</span>
<span class="nc" id="L1071">    }</span>

    private List&lt;MediaModel&gt; getRetriableStandaloneMedia(SiteModel selectedSite) {
        // get all retriable media ? To retry or not to retry, that is the question
<span class="nc" id="L1075">        List&lt;MediaModel&gt; failedStandAloneMedia = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (selectedSite != null) {</span>
<span class="nc" id="L1077">            List&lt;MediaModel&gt; failedMedia = mMediaStore.getSiteMediaWithState(</span>
                    selectedSite, MediaUploadState.FAILED);

            // only take into account those media items that do not belong to any Post
<span class="nc bnc" id="L1081" title="All 2 branches missed.">            for (MediaModel media : failedMedia) {</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                if (media.getLocalPostId() == 0) {</span>
<span class="nc" id="L1083">                    failedStandAloneMedia.add(media);</span>
                }
<span class="nc" id="L1085">            }</span>
        }

<span class="nc" id="L1088">        return failedStandAloneMedia;</span>
    }

    /**
     * Has lower priority than the PostUploadHandler, which ensures that the handler has already received and
     * processed this OnPostUploaded event. This means we can safely rely on its internal state being up to date.
     */
    @SuppressWarnings(&quot;unused&quot;)
    @Subscribe(threadMode = ThreadMode.MAIN, priority = 7)
    public void onPostUploaded(OnPostUploaded event) {
<span class="nc" id="L1098">        stopServiceIfUploadsComplete(event.isError(), event.post);</span>
<span class="nc" id="L1099">    }</span>

    /**
     * Has lower priority than the PostUploadHandler, which ensures that the handler has already received and
     * processed this OnPostChanged event. This means we can safely rely on its internal state being up to date.
     */
    @Subscribe(threadMode = ThreadMode.MAIN, priority = 7)
    public void onPostChanged(OnPostChanged event) {
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        if (event.causeOfChange instanceof CauseOfOnPostChanged.RemoteAutoSavePost) {</span>
<span class="nc" id="L1108">            PostModel post =</span>
<span class="nc" id="L1109">                    mPostStore.getPostByLocalPostId(((RemoteAutoSavePost) event.causeOfChange).getLocalPostId());</span>
<span class="nc" id="L1110">            stopServiceIfUploadsComplete(event.isError(), post);</span>
        }
<span class="nc" id="L1112">    }</span>

    public static class UploadErrorEvent {
        public final PostModel post;
        public final List&lt;MediaModel&gt; mediaModelList;
        public final String errorMessage;

<span class="nc" id="L1119">        public UploadErrorEvent(PostModel post, String errorMessage) {</span>
<span class="nc" id="L1120">            this.post = post;</span>
<span class="nc" id="L1121">            this.mediaModelList = null;</span>
<span class="nc" id="L1122">            this.errorMessage = errorMessage;</span>
<span class="nc" id="L1123">        }</span>

<span class="nc" id="L1125">        public UploadErrorEvent(List&lt;MediaModel&gt; mediaModelList, String errorMessage) {</span>
<span class="nc" id="L1126">            this.post = null;</span>
<span class="nc" id="L1127">            this.mediaModelList = mediaModelList;</span>
<span class="nc" id="L1128">            this.errorMessage = errorMessage;</span>
<span class="nc" id="L1129">        }</span>
    }

    public static class UploadMediaSuccessEvent {
        public final List&lt;MediaModel&gt; mediaModelList;
        public final String successMessage;

<span class="nc" id="L1136">        public UploadMediaSuccessEvent(List&lt;MediaModel&gt; mediaModelList, String successMessage) {</span>
<span class="nc" id="L1137">            this.mediaModelList = mediaModelList;</span>
<span class="nc" id="L1138">            this.successMessage = successMessage;</span>
<span class="nc" id="L1139">        }</span>
    }

    public static class UploadMediaRetryEvent {
        public final List&lt;MediaModel&gt; mediaModelList;

<span class="nc" id="L1145">        UploadMediaRetryEvent(List&lt;MediaModel&gt; mediaModelList) {</span>
<span class="nc" id="L1146">            this.mediaModelList = mediaModelList;</span>
<span class="nc" id="L1147">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>Generated by the Android Gradle plugin 7.1.1</div></body></html>