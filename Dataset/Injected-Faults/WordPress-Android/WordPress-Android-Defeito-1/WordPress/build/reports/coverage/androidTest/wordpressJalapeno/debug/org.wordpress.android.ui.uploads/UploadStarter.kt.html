<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UploadStarter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">wordpressJalapenoDebug</a> &gt; <a href="index.source.html" class="el_package">org.wordpress.android.ui.uploads</a> &gt; <span class="el_source">UploadStarter.kt</span></div><h1>UploadStarter.kt</h1><pre class="source lang-java linenums">package org.wordpress.android.ui.uploads

import android.content.Context
import androidx.lifecycle.Lifecycle.Event
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.LiveData
import androidx.lifecycle.Observer
import androidx.lifecycle.OnLifecycleEvent
import androidx.lifecycle.ProcessLifecycleOwner
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import org.wordpress.android.analytics.AnalyticsTracker.Stat
import org.wordpress.android.fluxc.Dispatcher
import org.wordpress.android.fluxc.generated.UploadActionBuilder
import org.wordpress.android.fluxc.model.SiteModel
import org.wordpress.android.fluxc.store.PageStore
import org.wordpress.android.fluxc.store.PostStore
import org.wordpress.android.fluxc.store.SiteStore
import org.wordpress.android.modules.BG_THREAD
import org.wordpress.android.modules.IO_THREAD
import org.wordpress.android.testing.OpenForTesting
import org.wordpress.android.ui.uploads.UploadActionUseCase.UploadAction
import org.wordpress.android.ui.uploads.UploadActionUseCase.UploadAction.DO_NOTHING
import org.wordpress.android.util.AppLog
import org.wordpress.android.util.AppLog.T
import org.wordpress.android.util.NetworkUtilsWrapper
import org.wordpress.android.util.analytics.AnalyticsTrackerWrapper
import org.wordpress.android.util.skip
import org.wordpress.android.viewmodel.helpers.ConnectionStatus
import javax.inject.Inject
import javax.inject.Named
import javax.inject.Singleton
import kotlin.coroutines.CoroutineContext

/**
 * Automatically remote-auto-save or upload all local modifications to posts.
 *
 * Auto-uploads happen when the app is placed in the foreground or when the internet connection is restored. In
 * addition to this, call sites can also request an immediate execution by calling [checkConnectionAndUpload].
 *
 * The method [activateAutoUploading] must be called once, preferably during app creation, for the auto-uploads to work.
 */
<span class="fc" id="L47">@Singleton</span>
@OpenForTesting
<span class="fc" id="L49">class UploadStarter @Inject constructor(</span>
    /**
     * The Application context
     */
<span class="fc" id="L53">    private val context: Context,</span>
<span class="fc" id="L54">    private val dispatcher: Dispatcher,</span>
<span class="fc" id="L55">    private val postStore: PostStore,</span>
<span class="fc" id="L56">    private val pageStore: PageStore,</span>
<span class="fc" id="L57">    private val siteStore: SiteStore,</span>
<span class="fc" id="L58">    private val uploadActionUseCase: UploadActionUseCase,</span>
<span class="fc" id="L59">    private val tracker: AnalyticsTrackerWrapper,</span>
<span class="fc" id="L60">    @Named(BG_THREAD) private val bgDispatcher: CoroutineDispatcher,</span>
<span class="fc" id="L61">    @Named(IO_THREAD) private val ioDispatcher: CoroutineDispatcher,</span>
<span class="fc" id="L62">    private val uploadServiceFacade: UploadServiceFacade,</span>
<span class="fc" id="L63">    private val networkUtilsWrapper: NetworkUtilsWrapper,</span>
<span class="fc" id="L64">    private val connectionStatus: LiveData&lt;ConnectionStatus&gt;</span>
) : CoroutineScope {
<span class="fc" id="L66">    private val job = Job()</span>

<span class="nc" id="L68">    override val coroutineContext: CoroutineContext get() = job + bgDispatcher</span>

    /**
     * The hook for making this class automatically launch uploads whenever the app is placed in the foreground.
     */
<span class="fc" id="L73">    private val processLifecycleObserver = object : LifecycleObserver {</span>
        @OnLifecycleEvent(Event.ON_START)
        fun onAppComesFromBackground() {
<span class="nc" id="L76">            queueUploadFromAllSites()</span>
<span class="nc" id="L77">        }</span>
    }

    /**
     * Activates the necessary observers for this class to start auto-uploading.
     *
     * This must be called during [org.wordpress.android.WordPress]' creation like so:
     *
     * ```
     * mUploadStarter.activateAutoUploading(ProcessLifecycleOwner.get())
     * ```
     */
    fun activateAutoUploading(processLifecycleOwner: ProcessLifecycleOwner) {
        // We're skipping the first emitted value because the processLifecycleObserver below will also trigger an
        // immediate upload.
<span class="fc" id="L92">        connectionStatus.skip(1).observe(processLifecycleOwner, Observer {</span>
<span class="nc" id="L93">            queueUploadFromAllSites()</span>
<span class="nc" id="L94">        })</span>

<span class="fc" id="L96">        processLifecycleOwner.lifecycle.addObserver(processLifecycleObserver)</span>
<span class="fc" id="L97">    }</span>

<span class="nc" id="L99">    fun queueUploadFromAllSites() = launch {</span>
<span class="nc" id="L100">        val sites = siteStore.sites</span>
<span class="nc" id="L101">        try {</span>
<span class="nc" id="L102">            checkConnectionAndUpload(sites = sites)</span>
<span class="nc" id="L103">        } catch (e: Exception) {</span>
<span class="nc" id="L104">            AppLog.e(T.MEDIA, e)</span>
        }
<span class="nc" id="L106">    }</span>

    /**
     * Upload all local drafts from the given [site].
     */
<span class="nc" id="L111">    fun queueUploadFromSite(site: SiteModel) = launch {</span>
<span class="nc" id="L112">        try {</span>
<span class="nc" id="L113">            checkConnectionAndUpload(sites = listOf(site))</span>
<span class="nc" id="L114">        } catch (e: Exception) {</span>
<span class="nc" id="L115">            AppLog.e(T.MEDIA, e)</span>
        }
<span class="nc" id="L117">    }</span>

    /**
     * If there is an internet connection, uploads all posts with local changes belonging to [sites].
     *
     * This coroutine will suspend until all the [upload] operations have completed. If one of them fails, all query
     * and queuing attempts ([upload]) will be canceled. The exception will be thrown by this method.
     */
<span class="nc bnc" id="L125" title="All 2 branches missed.">    private suspend fun checkConnectionAndUpload(sites: List&lt;SiteModel&gt;) = coroutineScope {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (!networkUtilsWrapper.isNetworkAvailable()) {</span>
<span class="nc" id="L127">            return@coroutineScope</span>
        }

<span class="nc" id="L130">        sites.forEach {</span>
<span class="nc" id="L131">            launch(ioDispatcher) {</span>
<span class="nc" id="L132">                upload(site = it)</span>
<span class="nc" id="L133">            }</span>
<span class="nc" id="L134">        }</span>
<span class="nc" id="L135">    }</span>

    /**
     * This is meant to be used by [checkConnectionAndUpload] only.
     *
     * The method needs to be synchronized from the following reasons. When the app comes to foreground both
     * `queueUploadFromAllSites` and `queueUploadFromSite` are invoked. The problem is that they can run in parallel
     * and `uploadServiceFacade.isPostUploadingOrQueued(it)` might return out-of-date result and a same post is added
     * twice.
     */
    @Synchronized
<span class="nc" id="L146">    private suspend fun upload(site: SiteModel) = coroutineScope {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        val posts = async { postStore.getPostsWithLocalChanges(site) }</span>
<span class="nc" id="L148">        val pages = async { pageStore.getPagesWithLocalChanges(site) }</span>
<span class="nc" id="L149">        val list = posts.await() + pages.await()</span>

<span class="nc" id="L151">        list.asSequence()</span>
<span class="nc" id="L152">                .map { post -&gt;</span>
<span class="nc" id="L153">                    val action = uploadActionUseCase.getAutoUploadAction(post, site)</span>
<span class="nc" id="L154">                    Pair(post, action)</span>
                }
<span class="nc" id="L156">                .filter { (_, action) -&gt;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                    action != DO_NOTHING</span>
                }
<span class="nc" id="L159">                .toList()</span>
<span class="nc" id="L160">                .forEach { (post, action) -&gt;</span>
<span class="nc" id="L161">                    trackAutoUploadAction(action, post.status, post.isPage)</span>
<span class="nc" id="L162">                    AppLog.d(</span>
<span class="nc" id="L163">                            AppLog.T.POSTS,</span>
<span class="nc" id="L164">                            &quot;UploadStarter for post (isPage: ${post.isPage}) title: ${post.title}, action: $action&quot;</span>
                    )
<span class="nc" id="L166">                    dispatcher.dispatch(</span>
<span class="nc" id="L167">                            UploadActionBuilder.newIncrementNumberOfAutoUploadAttemptsAction(</span>
<span class="nc" id="L168">                                    post</span>
                            )
                    )
<span class="nc" id="L171">                    uploadServiceFacade.uploadPost(</span>
<span class="nc" id="L172">                            context = context,</span>
<span class="nc" id="L173">                            post = post,</span>
<span class="nc" id="L174">                            trackAnalytics = false</span>
                    )
<span class="nc" id="L176">                }</span>
<span class="nc" id="L177">    }</span>

    private fun trackAutoUploadAction(
        action: UploadAction,
        status: String,
        isPage: Boolean
    ) {
<span class="nc" id="L184">        tracker.track(</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (isPage) Stat.AUTO_UPLOAD_PAGE_INVOKED else Stat.AUTO_UPLOAD_POST_INVOKED,</span>
<span class="nc" id="L186">                mapOf(</span>
<span class="nc" id="L187">                        &quot;upload_action&quot; to action.toString(),</span>
<span class="nc" id="L188">                        &quot;post_status&quot; to status</span>
                )
        )
<span class="nc" id="L191">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>Generated by the Android Gradle plugin 7.1.1</div></body></html>