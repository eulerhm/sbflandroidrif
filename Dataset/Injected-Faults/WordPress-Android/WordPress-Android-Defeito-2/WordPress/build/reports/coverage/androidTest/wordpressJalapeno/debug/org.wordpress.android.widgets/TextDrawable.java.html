<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextDrawable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">wordpressJalapenoDebug</a> &gt; <a href="index.source.html" class="el_package">org.wordpress.android.widgets</a> &gt; <span class="el_source">TextDrawable.java</span></div><h1>TextDrawable.java</h1><pre class="source lang-java linenums">package org.wordpress.android.widgets;

/**
 * A Drawable object used to display text content.
 * &lt;p&gt;
 * Based on https://github.com/devunwired/textdrawable
 */

import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.text.Layout;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.util.TypedValue;

/**
 * A Drawable object that draws text.
 * A TextDrawable accepts most of the same parameters that can be applied to
 * {@link android.widget.TextView} for displaying and formatting text.
 *
 * Optionally, a {@link Path} may be supplied on which to draw the text.
 *
 * A TextDrawable has an intrinsic size equal to that required to draw all
 * the text it has been supplied, when possible. In cases where a {@link Path}
 * has been supplied, the caller must explicitly call
 * {@link #setBounds(android.graphics.Rect) setBounds()} to provide the Drawable
 * size based on the Path constraints.
 */
public class TextDrawable extends Drawable {
    /* Platform XML constants for typeface */
    private static final int SANS = 1;
    private static final int SERIF = 2;
    private static final int MONOSPACE = 3;

    /* Resources for scaling values to the given device */
    private Resources mResources;
    /* Paint to hold most drawing primitives for the text */
    private TextPaint mTextPaint;
    /* Layout is used to measure and draw the text */
    private StaticLayout mTextLayout;
    /* Alignment of the text inside its bounds */
<span class="nc" id="L52">    private Layout.Alignment mTextAlignment = Layout.Alignment.ALIGN_NORMAL;</span>
    /* Optional path on which to draw the text */
    private Path mTextPath;
    /* Stateful text color list */
    private ColorStateList mTextColors;
    /* Container for the bounds to be reported to widgets */
    private Rect mTextBounds;
    /* Text string to draw */
<span class="nc" id="L60">    private CharSequence mText = &quot;&quot;;</span>

    /* Attribute lists to pull default values from the current theme */
<span class="nc" id="L63">    private static final int[] THEME_ATTRIBUTES = {</span>
            android.R.attr.textAppearance
    };
<span class="nc" id="L66">    private static final int[] APPEARANCE_ATTRIBUTES = {</span>
            android.R.attr.textSize,
            android.R.attr.typeface,
            android.R.attr.textStyle,
            android.R.attr.textColor
    };


    public TextDrawable(Context context) {
<span class="nc" id="L75">        super();</span>
        // Used to load and scale resource items
<span class="nc" id="L77">        mResources = context.getResources();</span>
        // Definition of this drawables size
<span class="nc" id="L79">        mTextBounds = new Rect();</span>
        // Paint to use for the text
<span class="nc" id="L81">        mTextPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);</span>
<span class="nc" id="L82">        mTextPaint.density = mResources.getDisplayMetrics().density;</span>
<span class="nc" id="L83">        mTextPaint.setDither(true);</span>

<span class="nc" id="L85">        int textSize = 15;</span>
<span class="nc" id="L86">        ColorStateList textColor = null;</span>
<span class="nc" id="L87">        int styleIndex = -1;</span>
<span class="nc" id="L88">        int typefaceIndex = -1;</span>

        // Set default parameters from the current theme
<span class="nc" id="L91">        TypedArray a = context.getTheme().obtainStyledAttributes(THEME_ATTRIBUTES);</span>
<span class="nc" id="L92">        int appearanceId = a.getResourceId(0, -1);</span>
<span class="nc" id="L93">        a.recycle();</span>

<span class="nc" id="L95">        TypedArray ap = null;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (appearanceId != -1) {</span>
<span class="nc" id="L97">            ap = context.obtainStyledAttributes(appearanceId, APPEARANCE_ATTRIBUTES);</span>
        }
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (ap != null) {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            for (int i = 0; i &lt; ap.getIndexCount(); i++) {</span>
<span class="nc" id="L101">                int attr = ap.getIndex(i);</span>
<span class="nc bnc" id="L102" title="All 5 branches missed.">                switch (attr) {</span>
                    case 0: // Text Size
<span class="nc" id="L104">                        textSize = a.getDimensionPixelSize(attr, textSize);</span>
<span class="nc" id="L105">                        break;</span>
                    case 1: // Typeface
<span class="nc" id="L107">                        typefaceIndex = a.getInt(attr, typefaceIndex);</span>
<span class="nc" id="L108">                        break;</span>
                    case 2: // Text Style
<span class="nc" id="L110">                        styleIndex = a.getInt(attr, styleIndex);</span>
<span class="nc" id="L111">                        break;</span>
                    case 3: // Text Color
<span class="nc" id="L113">                        textColor = a.getColorStateList(attr);</span>
<span class="nc" id="L114">                        break;</span>
                    default:
                        break;
                }
            }

<span class="nc" id="L120">            ap.recycle();</span>
        }

<span class="nc bnc" id="L123" title="All 2 branches missed.">        setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));</span>
<span class="nc" id="L124">        setRawTextSize(textSize);</span>

<span class="nc" id="L126">        Typeface tf = null;</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">        switch (typefaceIndex) {</span>
            case SANS:
<span class="nc" id="L129">                tf = Typeface.SANS_SERIF;</span>
<span class="nc" id="L130">                break;</span>

            case SERIF:
<span class="nc" id="L133">                tf = Typeface.SERIF;</span>
<span class="nc" id="L134">                break;</span>

            case MONOSPACE:
<span class="nc" id="L137">                tf = Typeface.MONOSPACE;</span>
                break;
        }

<span class="nc" id="L141">        setTypeface(tf, styleIndex);</span>
<span class="nc" id="L142">    }</span>


    public void setText(int text) {
<span class="nc" id="L146">        this.setText(String.valueOf(text));</span>
<span class="nc" id="L147">    }</span>

    /**
     * Set the text that will be displayed
     * @param text Text to display
     */
    public void setText(CharSequence text) {
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L155">            text = &quot;&quot;;</span>
        }

<span class="nc" id="L158">        mText = text;</span>

<span class="nc" id="L160">        measureContent();</span>
<span class="nc" id="L161">    }</span>

    /**
     * Return the text currently being displayed
     */
    public CharSequence getText() {
<span class="nc" id="L167">        return mText;</span>
    }

    /**
     * Return the current text size, in pixels
     */
    public float getTextSize() {
<span class="nc" id="L174">        return mTextPaint.getTextSize();</span>
    }

    /**
     * Set the text size. The value will be interpreted in &quot;sp&quot; units
     * @param size Text size value, in sp
     */
    public void setTextSize(float size) {
<span class="nc" id="L182">        setTextSize(TypedValue.COMPLEX_UNIT_SP, size);</span>
<span class="nc" id="L183">    }</span>

    /**
     * Set the text size, using the supplied complex units
     * @param unit Units for the text size, such as dp or sp
     * @param size Text size value
     */
    public void setTextSize(int unit, float size) {
<span class="nc" id="L191">        float dimension = TypedValue.applyDimension(unit, size,</span>
<span class="nc" id="L192">                                                    mResources.getDisplayMetrics());</span>
<span class="nc" id="L193">        setRawTextSize(dimension);</span>
<span class="nc" id="L194">    }</span>

    /*
     * Set the text size, in raw pixels
     */
    private void setRawTextSize(float size) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (size != mTextPaint.getTextSize()) {</span>
<span class="nc" id="L201">            mTextPaint.setTextSize(size);</span>

<span class="nc" id="L203">            measureContent();</span>
        }
<span class="nc" id="L205">    }</span>

    /**
     * Return the horizontal stretch factor of the text
     */
    public float getTextScaleX() {
<span class="nc" id="L211">        return mTextPaint.getTextScaleX();</span>
    }

    /**
     * Set the horizontal stretch factor of the text
     * @param size Text scale factor
     */
    public void setTextScaleX(float size) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (size != mTextPaint.getTextScaleX()) {</span>
<span class="nc" id="L220">            mTextPaint.setTextScaleX(size);</span>
<span class="nc" id="L221">            measureContent();</span>
        }
<span class="nc" id="L223">    }</span>

    /**
     * Return the current text alignment setting
     */
    public Layout.Alignment getTextAlign() {
<span class="nc" id="L229">        return mTextAlignment;</span>
    }

    /**
     * Set the text alignment. The alignment itself is based on the text layout direction.
     * For LTR text NORMAL is left aligned and OPPOSITE is right aligned.
     * For RTL text, those alignments are reversed.
     * @param align Text alignment value. Should be set to one of:
     *
     * {@link Layout.Alignment#ALIGN_NORMAL},
     * {@link Layout.Alignment#ALIGN_NORMAL},
     * {@link Layout.Alignment#ALIGN_OPPOSITE}.
     */
    public void setTextAlign(Layout.Alignment align) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (mTextAlignment != align) {</span>
<span class="nc" id="L244">            mTextAlignment = align;</span>
<span class="nc" id="L245">            measureContent();</span>
        }
<span class="nc" id="L247">    }</span>

    /**
     * Sets the typeface and style in which the text should be displayed.
     * Note that not all Typeface families actually have bold and italic
     * variants, so you may need to use
     * {@link #setTypeface(Typeface, int)} to get the appearance
     * that you actually want.
     */
    public void setTypeface(Typeface tf) {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (mTextPaint.getTypeface() != tf) {</span>
<span class="nc" id="L258">            mTextPaint.setTypeface(tf);</span>

<span class="nc" id="L260">            measureContent();</span>
        }
<span class="nc" id="L262">    }</span>

    /**
     * Sets the typeface and style in which the text should be displayed,
     * and turns on the fake bold and italic bits in the Paint if the
     * Typeface that you provided does not have all the bits in the
     * style that you specified.
     *
     */
    public void setTypeface(Typeface tf, int style) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (style &gt; 0) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (tf == null) {</span>
<span class="nc" id="L274">                tf = Typeface.defaultFromStyle(style);</span>
            } else {
<span class="nc" id="L276">                tf = Typeface.create(tf, style);</span>
            }

<span class="nc" id="L279">            setTypeface(tf);</span>
            // now compute what (if any) algorithmic styling is needed
<span class="nc bnc" id="L281" title="All 2 branches missed.">            int typefaceStyle = tf != null ? tf.getStyle() : 0;</span>
<span class="nc" id="L282">            int need = style &amp; ~typefaceStyle;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            mTextPaint.setFakeBoldText((need &amp; Typeface.BOLD) != 0);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            mTextPaint.setTextSkewX((need &amp; Typeface.ITALIC) != 0 ? -0.25f : 0);</span>
<span class="nc" id="L285">        } else {</span>
<span class="nc" id="L286">            mTextPaint.setFakeBoldText(false);</span>
<span class="nc" id="L287">            mTextPaint.setTextSkewX(0);</span>
<span class="nc" id="L288">            setTypeface(tf);</span>
        }
<span class="nc" id="L290">    }</span>

    /**
     * Return the current typeface and style that the Paint
     * using for display.
     */
    public Typeface getTypeface() {
<span class="nc" id="L297">        return mTextPaint.getTypeface();</span>
    }

    /**
     * Set a single text color for all states
     * @param color Color value such as {@link Color#WHITE} or {@link Color#argb(int, int, int, int)}
     */
    public void setTextColor(int color) {
<span class="nc" id="L305">        setTextColor(ColorStateList.valueOf(color));</span>
<span class="nc" id="L306">    }</span>

    /**
     * Set the text color as a state list
     * @param colorStateList ColorStateList of text colors, such as inflated from an R.color resource
     */
    public void setTextColor(ColorStateList colorStateList) {
<span class="nc" id="L313">        mTextColors = colorStateList;</span>
<span class="nc" id="L314">        updateTextColors(getState());</span>
<span class="nc" id="L315">    }</span>

    /**
     * Optional Path object on which to draw the text. If this is set,
     * TextDrawable cannot properly measure the bounds this drawable will need.
     * You must call {@link #setBounds(int, int, int, int) setBounds()} before
     * applying this TextDrawable to any View.
     *
     * Calling this method with &lt;code&gt;null&lt;/code&gt; will remove any Path currently attached.
     */
    public void setTextPath(Path path) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (mTextPath != path) {</span>
<span class="nc" id="L327">            mTextPath = path;</span>
<span class="nc" id="L328">            measureContent();</span>
        }
<span class="nc" id="L330">    }</span>

    /**
     * Internal method to take measurements of the current contents and apply
     * the correct bounds when possible.
     */
    private void measureContent() {
        // If drawing to a path, we cannot measure intrinsic bounds
        // We must resly on setBounds being called externally
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (mTextPath != null) {</span>
            // Clear any previous measurement
<span class="nc" id="L341">            mTextLayout = null;</span>
<span class="nc" id="L342">            mTextBounds.setEmpty();</span>
        } else {
            // Measure text bounds
<span class="nc" id="L345">            double desired = Math.ceil(Layout.getDesiredWidth(mText, mTextPaint));</span>
<span class="nc" id="L346">            mTextLayout = new StaticLayout(mText, mTextPaint, (int) desired,</span>
                                           mTextAlignment, 1.0f, 0.0f, false);
<span class="nc" id="L348">            mTextBounds.set(0, 0, mTextLayout.getWidth(), mTextLayout.getHeight());</span>
        }

        // We may need to be redrawn
<span class="nc" id="L352">        invalidateSelf();</span>
<span class="nc" id="L353">    }</span>

    /**
     * Internal method to apply the correct text color based on the drawable's state
     */
    private boolean updateTextColors(int[] stateSet) {
<span class="nc" id="L359">        int newColor = mTextColors.getColorForState(stateSet, Color.WHITE);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (mTextPaint.getColor() != newColor) {</span>
<span class="nc" id="L361">            mTextPaint.setColor(newColor);</span>
<span class="nc" id="L362">            return true;</span>
        }

<span class="nc" id="L365">        return false;</span>
    }

    @Override
    protected void onBoundsChange(Rect bounds) {
        // Update the internal bounds in response to any external requests
<span class="nc" id="L371">        mTextBounds.set(bounds);</span>
<span class="nc" id="L372">    }</span>

    @Override
    public boolean isStateful() {
        /*
         * The drawable's ability to represent state is based on
         * the text color list set
         */
<span class="nc" id="L380">        return mTextColors.isStateful();</span>
    }

    @Override
    protected boolean onStateChange(int[] state) {
        // Upon state changes, grab the correct text color
<span class="nc" id="L386">        return updateTextColors(state);</span>
    }

    @Override
    public int getIntrinsicHeight() {
        // Return the vertical bounds measured, or -1 if none
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (mTextBounds.isEmpty()) {</span>
<span class="nc" id="L393">            return -1;</span>
        } else {
<span class="nc" id="L395">            return (mTextBounds.bottom - mTextBounds.top);</span>
        }
    }

    @Override
    public int getIntrinsicWidth() {
        // Return the horizontal bounds measured, or -1 if none
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (mTextBounds.isEmpty()) {</span>
<span class="nc" id="L403">            return -1;</span>
        } else {
<span class="nc" id="L405">            return (mTextBounds.right - mTextBounds.left);</span>
        }
    }

    @Override
    public void draw(Canvas canvas) {
<span class="nc" id="L411">        final Rect bounds = getBounds();</span>
<span class="nc" id="L412">        final int count = canvas.save();</span>
<span class="nc" id="L413">        canvas.translate(bounds.left, bounds.top);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (mTextPath == null) {</span>
            // Allow the layout to draw the text
<span class="nc" id="L416">            mTextLayout.draw(canvas);</span>
        } else {
            // Draw directly on the canvas using the supplied path
<span class="nc" id="L419">            canvas.drawTextOnPath(mText.toString(), mTextPath, 0, 0, mTextPaint);</span>
        }
<span class="nc" id="L421">        canvas.restoreToCount(count);</span>
<span class="nc" id="L422">    }</span>

    @Override
    public void setAlpha(int alpha) {
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (mTextPaint.getAlpha() != alpha) {</span>
<span class="nc" id="L427">            mTextPaint.setAlpha(alpha);</span>
        }
<span class="nc" id="L429">    }</span>

    @Override
    public int getOpacity() {
<span class="nc" id="L433">        return mTextPaint.getAlpha();</span>
    }

    @Override
    public void setColorFilter(ColorFilter cf) {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (mTextPaint.getColorFilter() != cf) {</span>
<span class="nc" id="L439">            mTextPaint.setColorFilter(cf);</span>
        }
<span class="nc" id="L441">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>Generated by the Android Gradle plugin 7.1.1</div></body></html>