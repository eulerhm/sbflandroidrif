<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ListState.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">wordpressJalapenoDebug</a> &gt; <a href="index.source.html" class="el_package">org.wordpress.android.models.networkresource</a> &gt; <span class="el_source">ListState.kt</span></div><h1>ListState.kt</h1><pre class="source lang-java linenums">package org.wordpress.android.models.networkresource

import androidx.annotation.StringRes
import org.wordpress.android.models.networkresource.ListState.Error
import org.wordpress.android.models.networkresource.ListState.Init
import org.wordpress.android.models.networkresource.ListState.Loading
import org.wordpress.android.models.networkresource.ListState.Ready
import org.wordpress.android.models.networkresource.ListState.Success

/**
 * ListState aims to give a highly structured and easy to use way to manage any list's state.
 *
 * There are 5 different states: [Init], [Ready], [Success], [Loading], [Error]. Check out their documentation to see
 * how each state behaves.
 *
 * @property data is initialized depending on each state and once initialized it can not be altered. In [Ready] and
 * [Success] states, it'll be passed as a parameter. In [Loading] and [Error] states, it'll be initialized from the
 * previous state to make sure the access to the data is not lost. In [Init], an empty list will be passed.
 * In situations where the data needs to be changed outside of a fetch, [transform] can be used
 * to get a new instance by using a transform function.
 */
<span class="nc" id="L22">sealed class ListState&lt;T&gt;(val data: List&lt;T&gt;) {</span>
    /**
     * In some situations the underlying data might change outside of a fetch. Adding a new item, removing one,
     * a single item getting updated would be some typical examples. Since the [data] property can not be altered
     * directly, which is by design, we need a different way to update it.
     *
     * This method can be used to handle any transformation easily while preserving the current state. Any function
     * that takes a [List] and returns a new one can be used as the transformation.
     *
     * @return a new ListState instance that has the transformed data while preserving the state
     */
    abstract fun transform(transformFunc: (List&lt;T&gt;) -&gt; List&lt;T&gt;): ListState&lt;T&gt;

    /**
     * Helper function for checking whether the first page is being loaded. It can be used to either show or hide a
     * [android.support.v4.widget.SwipeRefreshLayout].
     */
<span class="nc bnc" id="L39" title="All 4 branches missed.">    fun isFetchingFirstPage(): Boolean = if (this is Loading) !loadingMore else false</span>

    /**
     * Helper function for checking whether more data is being loaded. It can be used to either show or hide a
     * [android.widget.ProgressBar] for instance, at the bottom of a screen.
     */
<span class="nc bnc" id="L45" title="All 6 branches missed.">    fun isLoadingMore(): Boolean = (this as? Loading)?.loadingMore == true</span>

    /**
     * Helper function to check whether a fetch should occur. If the state is [Loading] fetch is not allowed. Otherwise,
     * the first page can be fetched at any time. Loading more data is only allowed if it's specifically flagged to be
     * possible in [Success] state.
     *
     * @param loadMore should be passed to indicate what kind of fetch is intended: first page or load more
     */
<span class="nc" id="L54">    fun shouldFetch(loadMore: Boolean): Boolean = when (this) {</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">        is Init -&gt; false // Not ready yet</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">        is Loading -&gt; false // Already fetching</span>
<span class="nc bnc" id="L57" title="All 4 branches missed.">        is Success -&gt; if (loadMore) canLoadMore else true // Trying to load more or refreshing</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        else -&gt; !loadMore // First page can be fetched since we are not fetching anything else</span>
<span class="nc" id="L59">    }</span>

    /**
     * This is the state each object should be created in. In this state [data] would be empty and [shouldFetch] will
     * return `false` with the assumption that the caller will need to get ready before fetch can happen. A typical
     * example would be to initialize a resource as a property and then [Ready] it after the necessary setup, such as
     * getting the `SiteModel` from a `Store`.
     */
<span class="nc" id="L67">    class Init&lt;T&gt; : ListState&lt;T&gt;(ArrayList()) {</span>
<span class="nc" id="L68">        override fun transform(transformFunc: (List&lt;T&gt;) -&gt; List&lt;T&gt;) = this</span>
    }

    /**
     * Ready state signifies that this resource can start being used.
     *
     * @param data This is one of 2 places where the data can be directly passed in. In most cases, it will be set
     * using the cached version of the data, for example from its `Store`.
     */
<span class="nc" id="L77">    class Ready&lt;T&gt;(data: List&lt;T&gt;) : ListState&lt;T&gt;(data) {</span>
<span class="nc" id="L78">        override fun transform(transformFunc: (List&lt;T&gt;) -&gt; List&lt;T&gt;) = Ready(transformFunc(data))</span>
    }

    /**
     * This state means that a network request has been started to fetch either the first page or more data.
     *
     * @param data can not be passed directly to [Loading] state as it's prevented by a private constructor.
     * It's initialized either from the previous state or from the transformed data using
     * [ListState.transform].
     *
     * @param loadingMore flag is used to indicate whether the first page or more data is being fetched. It's default
     * value is `false` which should be useful in situations where pagination is not available.
     */
<span class="nc" id="L91">    class Loading&lt;T&gt; private constructor(data: List&lt;T&gt;, val loadingMore: Boolean) : ListState&lt;T&gt;(data) {</span>
<span class="nc" id="L92">        constructor(previous: ListState&lt;T&gt;, loadingMore: Boolean = false) : this(previous.data, loadingMore)</span>

        override fun transform(transformFunc: (List&lt;T&gt;) -&gt; List&lt;T&gt;) =
<span class="nc" id="L95">                Loading(transformFunc(data), loadingMore)</span>
    }

    /** This state means that at least one fetch has successfully completed.
     *
     * @param data This is the second and final state where the data can be passed in directly.
     *
     * @param canLoadMore For resources where pagination is available, this flag can be used to indicate if more data
     * can be fetched. It's default value is `false` which should be useful in situations where pagination is not
     * available.
     */
<span class="nc" id="L106">    class Success&lt;T&gt;(data: List&lt;T&gt;, val canLoadMore: Boolean = false) : ListState&lt;T&gt;(data) {</span>
        override fun transform(transformFunc: (List&lt;T&gt;) -&gt; List&lt;T&gt;) =
<span class="nc" id="L108">                Success(transformFunc(data), canLoadMore)</span>
<span class="nc" id="L109">    }</span>

    /**
     * This state means that at least one fetch has resulted in error.
     *
     * @param data can not be passed directly to [Error] state as it's prevented by a private constructor.
     * It's initialized either from the previous state or from the transformed data using
     * [ListState.transform].
     *
     * @param errorMessage will be the error string received from the API.
     * @param errorMessageResId can be used to propagate error resourceIds from ViewModels to Views.
     */
<span class="nc" id="L121">    class Error&lt;T&gt; private constructor(</span>
        data: List&lt;T&gt;,
<span class="nc" id="L123">        val errorMessage: String? = null,</span>
<span class="nc" id="L124">        @StringRes val errorMessageResId: Int? = null</span>
<span class="nc" id="L125">    ) : ListState&lt;T&gt;(data) {</span>
<span class="nc" id="L126">        constructor(</span>
            previous: ListState&lt;T&gt;,
<span class="nc" id="L128">            errorMessage: String? = null,</span>
<span class="nc" id="L129">            @StringRes errorMessageResId: Int? = null</span>
<span class="nc" id="L130">        ) : this(previous.data, errorMessage, errorMessageResId)</span>

        override fun transform(transformFunc: (List&lt;T&gt;) -&gt; List&lt;T&gt;) =
<span class="nc" id="L133">                Error(transformFunc(data), errorMessage, errorMessageResId)</span>
<span class="nc" id="L134">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>Generated by the Android Gradle plugin 7.1.1</div></body></html>