<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EditActivity.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prodDebug</a> &gt; <a href="index.source.html" class="el_package">fr.free.nrw.commons.edit</a> &gt; <span class="el_source">EditActivity.kt</span></div><h1>EditActivity.kt</h1><pre class="source lang-java linenums">package fr.free.nrw.commons.edit

import android.animation.Animator
import android.animation.Animator.AnimatorListener
import android.animation.ValueAnimator
import android.content.Intent
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.graphics.drawable.BitmapDrawable
import android.media.ExifInterface
import android.os.Bundle
import android.util.Log
import android.view.animation.AccelerateDecelerateInterpolator
import android.widget.ImageView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.graphics.rotationMatrix
import androidx.core.graphics.scaleMatrix
import androidx.core.net.toUri
import androidx.lifecycle.ViewModelProvider
import fr.free.nrw.commons.R
import kotlinx.android.synthetic.main.activity_edit.btn_save
import kotlinx.android.synthetic.main.activity_edit.iv
import kotlinx.android.synthetic.main.activity_edit.rotate_btn
import timber.log.Timber
import java.io.File

/**
 * An activity class for editing and rotating images using LLJTran with EXIF attribute preservation.
 *
 * This activity allows loads an image, allows users to rotate it by 90-degree increments, and
 * save the edited image while preserving its EXIF attributes. The class includes methods
 * for initializing the UI, animating image rotations, copying EXIF data, and handling
 * the image-saving process.
 */
<span class="nc" id="L36">class EditActivity : AppCompatActivity() {</span>
<span class="nc" id="L37">    private var imageUri = &quot;&quot;</span>
    private lateinit var vm: EditViewModel
<span class="nc" id="L39">    private val sourceExifAttributeList = mutableListOf&lt;Pair&lt;String, String?&gt;&gt;()</span>

    override fun onCreate(savedInstanceState: Bundle?) {
<span class="nc" id="L42">        super.onCreate(savedInstanceState)</span>
<span class="nc" id="L43">        setContentView(R.layout.activity_edit)</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">        supportActionBar?.title = &quot;&quot;</span>
<span class="nc" id="L45">        val intent = intent</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        imageUri = intent.getStringExtra(&quot;image&quot;) ?: &quot;&quot;</span>
<span class="nc" id="L47">        vm = ViewModelProvider(this).get(EditViewModel::class.java)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">        val sourceExif = imageUri.toUri().path?.let { ExifInterface(it) }</span>
<span class="nc" id="L49">        val exifTags = arrayOf(</span>
<span class="nc" id="L50">            ExifInterface.TAG_APERTURE,</span>
<span class="nc" id="L51">            ExifInterface.TAG_DATETIME,</span>
<span class="nc" id="L52">            ExifInterface.TAG_EXPOSURE_TIME,</span>
<span class="nc" id="L53">            ExifInterface.TAG_FLASH,</span>
<span class="nc" id="L54">            ExifInterface.TAG_FOCAL_LENGTH,</span>
<span class="nc" id="L55">            ExifInterface.TAG_GPS_ALTITUDE,</span>
<span class="nc" id="L56">            ExifInterface.TAG_GPS_ALTITUDE_REF,</span>
<span class="nc" id="L57">            ExifInterface.TAG_GPS_DATESTAMP,</span>
<span class="nc" id="L58">            ExifInterface.TAG_GPS_LATITUDE,</span>
<span class="nc" id="L59">            ExifInterface.TAG_GPS_LATITUDE_REF,</span>
<span class="nc" id="L60">            ExifInterface.TAG_GPS_LONGITUDE,</span>
<span class="nc" id="L61">            ExifInterface.TAG_GPS_LONGITUDE_REF,</span>
<span class="nc" id="L62">            ExifInterface.TAG_GPS_PROCESSING_METHOD,</span>
<span class="nc" id="L63">            ExifInterface.TAG_GPS_TIMESTAMP,</span>
<span class="nc" id="L64">            ExifInterface.TAG_IMAGE_LENGTH,</span>
<span class="nc" id="L65">            ExifInterface.TAG_IMAGE_WIDTH,</span>
<span class="nc" id="L66">            ExifInterface.TAG_ISO,</span>
<span class="nc" id="L67">            ExifInterface.TAG_MAKE,</span>
<span class="nc" id="L68">            ExifInterface.TAG_MODEL,</span>
<span class="nc" id="L69">            ExifInterface.TAG_ORIENTATION,</span>
<span class="nc" id="L70">            ExifInterface.TAG_WHITE_BALANCE,</span>
<span class="nc" id="L71">            ExifInterface.WHITEBALANCE_AUTO,</span>
<span class="nc" id="L72">            ExifInterface.WHITEBALANCE_MANUAL</span>
        )
<span class="nc bnc" id="L74" title="All 2 branches missed.">        for (tag in exifTags) {</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">            val attribute = sourceExif?.getAttribute(tag.toString())</span>
<span class="nc" id="L76">            sourceExifAttributeList.add(Pair(tag.toString(), attribute))</span>
        }

<span class="nc" id="L79">        init()</span>
<span class="nc" id="L80">    }</span>

    /**
     * Initializes the ImageView and associated UI elements.
     *
     * This function sets up the ImageView for displaying an image, adjusts its view bounds,
     * and scales the initial image to fit within the ImageView. It also sets click listeners
     * for the &quot;Rotate&quot; and &quot;Save&quot; buttons.
     */
    private fun init() {
<span class="nc" id="L90">        iv.adjustViewBounds = true</span>
<span class="nc" id="L91">        iv.scaleType = ImageView.ScaleType.MATRIX</span>
<span class="nc" id="L92">        iv.post(Runnable {</span>
<span class="nc" id="L93">            val options = BitmapFactory.Options()</span>
<span class="nc" id="L94">            options.inJustDecodeBounds = true</span>
<span class="nc" id="L95">            BitmapFactory.decodeFile(imageUri, options)</span>

<span class="nc" id="L97">            val bitmapWidth = options.outWidth</span>
<span class="nc" id="L98">            val bitmapHeight = options.outHeight</span>

            // Check if the bitmap dimensions exceed a certain threshold
<span class="nc" id="L101">            val maxBitmapSize = 2000 // Set your maximum size here</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">            if (bitmapWidth &gt; maxBitmapSize || bitmapHeight &gt; maxBitmapSize) {</span>
<span class="nc" id="L103">                val scaleFactor = calculateScaleFactor(bitmapWidth, bitmapHeight, maxBitmapSize)</span>
<span class="nc" id="L104">                options.inSampleSize = scaleFactor</span>
<span class="nc" id="L105">                options.inJustDecodeBounds = false</span>
<span class="nc" id="L106">                val scaledBitmap = BitmapFactory.decodeFile(imageUri, options)</span>
<span class="nc" id="L107">                iv.setImageBitmap(scaledBitmap)</span>
                // Update the ImageView with the scaled bitmap
<span class="nc" id="L109">                val scale = iv.measuredWidth.toFloat() / scaledBitmap.width.toFloat()</span>
<span class="nc" id="L110">                iv.layoutParams.height = (scale * scaledBitmap.height).toInt()</span>
<span class="nc" id="L111">                iv.imageMatrix = scaleMatrix(scale, scale)</span>
            } else {

<span class="nc" id="L114">                options.inJustDecodeBounds = false</span>
<span class="nc" id="L115">                val bitmap = BitmapFactory.decodeFile(imageUri, options)</span>
<span class="nc" id="L116">                iv.setImageBitmap(bitmap)</span>

<span class="nc" id="L118">                val scale = iv.measuredWidth.toFloat() / bitmapWidth.toFloat()</span>
<span class="nc" id="L119">                iv.layoutParams.height = (scale * bitmapHeight).toInt()</span>
<span class="nc" id="L120">                iv.imageMatrix = scaleMatrix(scale, scale)</span>
            }
<span class="nc" id="L122">        })</span>
<span class="nc" id="L123">        rotate_btn.setOnClickListener {</span>
<span class="nc" id="L124">            animateImageHeight()</span>
<span class="nc" id="L125">        }</span>
<span class="nc" id="L126">        btn_save.setOnClickListener {</span>
<span class="nc" id="L127">            getRotatedImage()</span>
<span class="nc" id="L128">        }</span>
<span class="nc" id="L129">    }</span>

<span class="nc" id="L131">    var imageRotation = 0</span>

    /**
     * Animates the height, rotation, and scale of an ImageView to provide a smooth
     * transition effect when rotating an image by 90 degrees.
     *
     * This function calculates the new height, rotation, and scale for the ImageView
     * based on the current image rotation angle and animates the changes using a
     * ValueAnimator. It also disables a rotate button during the animation to prevent
     * further rotation actions.
     */
    private fun animateImageHeight() {
<span class="nc" id="L143">        val drawableWidth: Float = iv.getDrawable().getIntrinsicWidth().toFloat()</span>
<span class="nc" id="L144">        val drawableHeight: Float = iv.getDrawable().getIntrinsicHeight().toFloat()</span>
<span class="nc" id="L145">        val viewWidth: Float = iv.getMeasuredWidth().toFloat()</span>
<span class="nc" id="L146">        val viewHeight: Float = iv.getMeasuredHeight().toFloat()</span>
<span class="nc" id="L147">        val rotation = imageRotation % 360</span>
<span class="nc" id="L148">        val newRotation = rotation + 90</span>

        val newViewHeight: Int
        val imageScale: Float
        val newImageScale: Float

<span class="nc" id="L154">        Timber.d(&quot;Rotation $rotation&quot;)</span>
<span class="nc" id="L155">        Timber.d(&quot;new Rotation $newRotation&quot;)</span>


<span class="nc bnc" id="L158" title="All 3 branches missed.">        if (rotation == 0 || rotation == 180) {</span>
<span class="nc" id="L159">            imageScale = viewWidth / drawableWidth</span>
<span class="nc" id="L160">            newImageScale = viewWidth / drawableHeight</span>
<span class="nc" id="L161">            newViewHeight = (drawableWidth * newImageScale).toInt()</span>
        } else if (rotation == 90 || rotation == 270) {
<span class="nc" id="L163">            imageScale = viewWidth / drawableHeight</span>
<span class="nc" id="L164">            newImageScale = viewWidth / drawableWidth</span>
<span class="nc" id="L165">            newViewHeight = (drawableHeight * newImageScale).toInt()</span>
        } else {
<span class="nc" id="L167">            throw UnsupportedOperationException(&quot;rotation can 0, 90, 180 or 270. \${rotation} is unsupported&quot;)</span>
        }

<span class="nc" id="L170">        val animator = ValueAnimator.ofFloat(0f, 1f).setDuration(1000L)</span>

<span class="nc" id="L172">        animator.interpolator = AccelerateDecelerateInterpolator()</span>

<span class="nc" id="L174">        animator.addListener(object : AnimatorListener {</span>
            override fun onAnimationStart(animation: Animator) {
<span class="nc" id="L176">                rotate_btn.setEnabled(false)</span>
<span class="nc" id="L177">            }</span>

            override fun onAnimationEnd(animation: Animator) {
<span class="nc" id="L180">                imageRotation = newRotation % 360</span>
<span class="nc" id="L181">                rotate_btn.setEnabled(true)</span>
<span class="nc" id="L182">            }</span>

            override fun onAnimationCancel(animation: Animator) {
<span class="nc" id="L185">            }</span>

            override fun onAnimationRepeat(animation: Animator) {
<span class="nc" id="L188">            }</span>

        })

<span class="nc" id="L192">        animator.addUpdateListener { animation -&gt;</span>
<span class="nc" id="L193">            val animVal = animation.animatedValue as Float</span>
<span class="nc" id="L194">            val complementaryAnimVal = 1 - animVal</span>
<span class="nc" id="L195">            val animatedHeight =</span>
<span class="nc" id="L196">                (complementaryAnimVal * viewHeight + animVal * newViewHeight).toInt()</span>
<span class="nc" id="L197">            val animatedScale = complementaryAnimVal * imageScale + animVal * newImageScale</span>
<span class="nc" id="L198">            val animatedRotation = complementaryAnimVal * rotation + animVal * newRotation</span>
<span class="nc" id="L199">            iv.getLayoutParams().height = animatedHeight</span>
<span class="nc" id="L200">            val matrix: Matrix = rotationMatrix(</span>
<span class="nc" id="L201">                animatedRotation,</span>
<span class="nc" id="L202">                drawableWidth / 2,</span>
<span class="nc" id="L203">                drawableHeight / 2</span>
            )
<span class="nc" id="L205">            matrix.postScale(</span>
<span class="nc" id="L206">                animatedScale,</span>
<span class="nc" id="L207">                animatedScale,</span>
<span class="nc" id="L208">                drawableWidth / 2,</span>
<span class="nc" id="L209">                drawableHeight / 2</span>
            )
<span class="nc" id="L211">            matrix.postTranslate(</span>
<span class="nc" id="L212">                -(drawableWidth - iv.getMeasuredWidth()) / 2,</span>
<span class="nc" id="L213">                -(drawableHeight - iv.getMeasuredHeight()) / 2</span>
            )
<span class="nc" id="L215">            iv.setImageMatrix(matrix)</span>
<span class="nc" id="L216">            iv.requestLayout()</span>
<span class="nc" id="L217">        }</span>

<span class="nc" id="L219">        animator.start()</span>
<span class="nc" id="L220">    }</span>

    /**
     * Rotates and edits the current image, copies EXIF data, and returns the edited image path.
     *
     * This function retrieves the path of the current image specified by `imageUri`,
     * rotates it based on the `imageRotation` angle using the `rotateImage` method
     * from the `vm`, and updates the EXIF attributes of the
     * rotated image based on the `sourceExifAttributeList`. It then copies the EXIF data
     * using the `copyExifData` method, creates an Intent to return the edited image's file path
     * as a result, and finishes the current activity.
     */
    fun getRotatedImage() {

<span class="nc" id="L234">        val filePath = imageUri.toUri().path</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        val file = filePath?.let { File(it) }</span>


<span class="nc bnc" id="L238" title="All 4 branches missed.">        val rotatedImage = file?.let { vm.rotateImage(imageRotation, it) }</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (rotatedImage == null) {</span>
<span class="nc" id="L240">            Toast.makeText(this, &quot;Failed to rotate to image&quot;, Toast.LENGTH_LONG).show()</span>
        }
<span class="nc bnc" id="L242" title="All 4 branches missed.">        val editedImageExif = rotatedImage?.path?.let { ExifInterface(it) }</span>
<span class="nc" id="L243">        copyExifData(editedImageExif)</span>
<span class="nc" id="L244">        val resultIntent = Intent()</span>
<span class="nc bnc" id="L245" title="All 6 branches missed.">        resultIntent.putExtra(&quot;editedImageFilePath&quot;, rotatedImage?.toUri()?.path ?: &quot;Error&quot;);</span>
<span class="nc" id="L246">        setResult(RESULT_OK, resultIntent);</span>
<span class="nc" id="L247">        finish();</span>
<span class="nc" id="L248">    }</span>

    /**
     * Copies EXIF data from sourceExifAttributeList to the provided ExifInterface object.
     *
     * This function iterates over the `sourceExifAttributeList` and sets the EXIF attributes
     * on the provided `editedImageExif` object.
     *
     * @param editedImageExif The ExifInterface object for the edited image.
     */
    private fun copyExifData(editedImageExif: ExifInterface?) {

<span class="nc bnc" id="L260" title="All 2 branches missed.">        for (attr in sourceExifAttributeList) {</span>
<span class="nc" id="L261">            Log.d(&quot;Tag is  ${attr.first}&quot;, &quot;Value is ${attr.second}&quot;)</span>
<span class="nc" id="L262">            editedImageExif!!.setAttribute(attr.first, attr.second)</span>
<span class="nc" id="L263">            Log.d(&quot;Tag is ${attr.first}&quot;, &quot;Value is ${attr.second}&quot;)</span>
        }

<span class="nc bnc" id="L266" title="All 2 branches missed.">        editedImageExif?.saveAttributes()</span>
<span class="nc" id="L267">    }</span>

    /**
     * Calculates the scale factor to be used for scaling down a bitmap based on its original
     *  dimensions and the maximum allowed size.
     * @param originalWidth  The original width of the bitmap.
     * @param originalHeight The original height of the bitmap.
     * @param maxSize        The maximum allowed size for either width or height.
     * @return The scale factor to be used for scaling down the bitmap.
     *         If the bitmap is smaller than or equal to the maximum size in both dimensions,
     *         the scale factor is 1.
     *         If the bitmap is larger than the maximum size in either dimension,
     *         the scale factor is calculated as the largest power of 2 that is less than or equal
     *         to the ratio of the original dimension to the maximum size.
     *         The scale factor ensures that the scaled bitmap will fit within the maximum size
     *         while maintaining aspect ratio.
     */
    private fun calculateScaleFactor(originalWidth: Int, originalHeight: Int, maxSize: Int): Int {
<span class="nc" id="L285">        var scaleFactor = 1</span>

<span class="nc bnc" id="L287" title="All 4 branches missed.">        if (originalWidth &gt; maxSize || originalHeight &gt; maxSize) {</span>
            // Calculate the largest power of 2 that is less than or equal to the desired width and height
<span class="nc" id="L289">            val widthRatio = Math.ceil((originalWidth.toDouble() / maxSize.toDouble())).toInt()</span>
<span class="nc" id="L290">            val heightRatio = Math.ceil((originalHeight.toDouble() / maxSize.toDouble())).toInt()</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">            scaleFactor = if (widthRatio &gt; heightRatio) widthRatio else heightRatio</span>
        }

<span class="nc" id="L295">        return scaleFactor</span>
    }



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.0.2</div></body></html>