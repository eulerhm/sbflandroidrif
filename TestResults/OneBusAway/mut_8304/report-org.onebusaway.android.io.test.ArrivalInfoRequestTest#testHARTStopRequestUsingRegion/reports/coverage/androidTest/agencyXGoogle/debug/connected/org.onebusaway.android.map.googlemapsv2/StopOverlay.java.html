<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StopOverlay.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">agencyXGoogleDebug</a> &gt; <a href="index.source.html" class="el_package">org.onebusaway.android.map.googlemapsv2</a> &gt; <span class="el_source">StopOverlay.java</span></div><h1>StopOverlay.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014 University of South Florida (sjbarbeau@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onebusaway.android.map.googlemapsv2;

import android.app.Activity;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Point;
import android.graphics.Shader;
import android.graphics.drawable.Drawable;
import android.location.Location;
import android.os.Build;
import android.os.Handler;
import android.os.SystemClock;
import android.util.Log;
import android.view.animation.BounceInterpolator;
import android.view.animation.Interpolator;
import android.widget.Toast;

import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.Projection;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.MarkerOptions;

import org.onebusaway.android.BuildConfig;
import org.onebusaway.android.R;
import org.onebusaway.android.app.Application;
import org.onebusaway.android.io.elements.ObaReferences;
import org.onebusaway.android.io.elements.ObaRoute;
import org.onebusaway.android.io.elements.ObaStop;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import androidx.core.content.ContextCompat;

public class StopOverlay implements MarkerListeners {

    private static final String TAG = &quot;StopOverlay&quot;;

    private GoogleMap mMap;

    private MarkerData mMarkerData;

    private final Activity mActivity;

    private static final String NORTH = &quot;N&quot;;

    private static final String NORTH_WEST = &quot;NW&quot;;

    private static final String WEST = &quot;W&quot;;

    private static final String SOUTH_WEST = &quot;SW&quot;;

    private static final String SOUTH = &quot;S&quot;;

    private static final String SOUTH_EAST = &quot;SE&quot;;

    private static final String EAST = &quot;E&quot;;

    private static final String NORTH_EAST = &quot;NE&quot;;

    private static final String NO_DIRECTION = &quot;null&quot;;

    private static final int NUM_DIRECTIONS = 9; // 8 directions + undirected mStops

<span class="nc" id="L94">    private static Bitmap[] bus_stop_icons = new Bitmap[NUM_DIRECTIONS];</span>

    private static int mPx; // Bus stop icon size

    // Bus icon arrow attributes - by default assume we're not going to add a direction arrow
<span class="nc" id="L99">    private static float mArrowWidthPx = 0;</span>

<span class="nc" id="L101">    private static float mArrowHeightPx = 0;</span>

<span class="nc" id="L103">    private static float mBuffer = 0;  // Add this to the icon size to get the Bitmap size</span>

<span class="nc" id="L105">    private static float mPercentOffset = 0.5f;</span>
    // % offset to position the stop icon, so the selection marker hits the middle of the circle

    private static Paint mArrowPaintStroke;
    // Stroke color used for outline of directional arrows on stops

    OnFocusChangedListener mOnFocusChangedListener;

    @Override
    public boolean markerClicked(Marker marker) {
<span class="nc" id="L115">        long startTime = Long.MAX_VALUE, endTime = Long.MAX_VALUE;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {</span>
<span class="nc" id="L117">            startTime = SystemClock.elapsedRealtimeNanos();</span>
        }

<span class="nc" id="L120">        ObaStop stop = mMarkerData.getStopFromMarker(marker);</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {</span>
<span class="nc" id="L123">            endTime = SystemClock.elapsedRealtimeNanos();</span>
<span class="nc" id="L124">            Log.d(TAG, &quot;Stop HashMap read time: &quot; + TimeUnit.MILLISECONDS</span>
<span class="nc" id="L125">                    .convert(endTime - startTime, TimeUnit.NANOSECONDS) + &quot;ms&quot;);</span>
        }

<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (stop == null) {</span>
            // The marker isn't a stop that is contained in this StopOverlay - return unhandled
<span class="nc" id="L130">            return false;</span>
        }

<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (BuildConfig.DEBUG) {</span>
            // Show the stop_id in a toast for debug purposes
<span class="nc" id="L135">            Toast.makeText(mActivity, stop.getId(), Toast.LENGTH_SHORT).show();</span>
        }

<span class="nc" id="L138">        doFocusChange(stop);</span>

<span class="nc" id="L140">        return true;</span>
    }

    @Override
    public void removeMarkerClicked(LatLng location) {
<span class="nc" id="L145">        Log.d(TAG, &quot;Map clicked&quot;);</span>
<span class="nc" id="L146">        removeFocus(location);</span>
<span class="nc" id="L147">    }</span>


    public interface OnFocusChangedListener {

        /**
         * Called when a stop on the map is clicked (i.e., tapped), which sets focus to a stop,
         * or when the user taps on an area away from the map for the first time after a stop
         * is already selected, which removes focus.  Clearly the focused stop can also be triggered
         * programmatically via a call to setFocus() with a stop of null - in that case, because
         * the user did not touch the map, location will be null.
         *
         * @param stop     the ObaStop that obtained focus, or null if no stop is in focus
         * @param routes   a HashMap of all route display names that serve this stop - key is
         *                 routeId
         * @param location the user touch location on the map, or null if the focus was changed
         *                 programmatically without the user tapping on the map
         */
        void onFocusChanged(ObaStop stop, HashMap&lt;String, ObaRoute&gt; routes, Location location);
    }

<span class="nc" id="L168">    public StopOverlay(Activity activity, GoogleMap map) {</span>
<span class="nc" id="L169">        mActivity = activity;</span>
<span class="nc" id="L170">        mMap = map;</span>
<span class="nc" id="L171">        loadIcons();</span>
<span class="nc" id="L172">    }</span>

    public void setOnFocusChangeListener(OnFocusChangedListener onFocusChangedListener) {
<span class="nc" id="L175">        mOnFocusChangedListener = onFocusChangedListener;</span>
<span class="nc" id="L176">    }</span>

    public synchronized void populateStops(List&lt;ObaStop&gt; stops, ObaReferences refs) {
<span class="nc" id="L179">        populate(stops, refs.getRoutes());</span>
<span class="nc" id="L180">    }</span>

    public synchronized void populateStops(List&lt;ObaStop&gt; stops, List&lt;ObaRoute&gt; routes) {
<span class="nc" id="L183">        populate(stops, routes);</span>
<span class="nc" id="L184">    }</span>

    private void populate(List&lt;ObaStop&gt; stops, List&lt;ObaRoute&gt; routes) {
        // Make sure that the MarkerData has been initialized
<span class="nc" id="L188">        setupMarkerData();</span>
<span class="nc" id="L189">        mMarkerData.populate(stops, routes);</span>
<span class="nc" id="L190">    }</span>

    public synchronized int size() {
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (mMarkerData != null) {</span>
<span class="nc" id="L194">            return mMarkerData.size();</span>
        } else {
<span class="nc" id="L196">            return 0;</span>
        }
    }

    /**
     * Clears any stop markers from the map
     * @param clearFocusedStop true to clear the currently focused stop, false to leave it on map
     */
    public synchronized void clear(boolean clearFocusedStop) {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (mMarkerData != null) {</span>
<span class="nc" id="L206">            mMarkerData.clear(clearFocusedStop);</span>
        }
<span class="nc" id="L208">    }</span>

    /**
     * Cache the BitmapDescriptors that hold the images used for icons
     */
    private static final void loadIcons() {
        // Initialize variables used for all marker icons
<span class="nc" id="L215">        Resources r = Application.get().getResources();</span>
<span class="nc" id="L216">        mPx = r.getDimensionPixelSize(R.dimen.map_stop_shadow_size_6);</span>
<span class="nc" id="L217">        mArrowWidthPx = mPx / 2f; // half the stop icon size</span>
<span class="nc" id="L218">        mArrowHeightPx = mPx / 3f; // 1/3 the stop icon size</span>
<span class="nc" id="L219">        float arrowSpacingReductionPx = mPx / 10f;</span>
<span class="nc" id="L220">        mBuffer = mArrowHeightPx - arrowSpacingReductionPx;</span>

        // Set offset used to position the image for markers (see getX/YPercentOffsetForDirection())
        // This allows the current selection marker to land on the middle of the stop marker circle
<span class="nc" id="L224">        mPercentOffset = (mBuffer / (mPx + mBuffer)) * 0.5f;</span>

<span class="nc" id="L226">        mArrowPaintStroke = new Paint();</span>
<span class="nc" id="L227">        mArrowPaintStroke.setColor(Color.WHITE);</span>
<span class="nc" id="L228">        mArrowPaintStroke.setStyle(Paint.Style.STROKE);</span>
<span class="nc" id="L229">        mArrowPaintStroke.setStrokeWidth(1.0f);</span>
<span class="nc" id="L230">        mArrowPaintStroke.setAntiAlias(true);</span>

<span class="nc" id="L232">        bus_stop_icons[0] = createBusStopIcon(NORTH);</span>
<span class="nc" id="L233">        bus_stop_icons[1] = createBusStopIcon(NORTH_WEST);</span>
<span class="nc" id="L234">        bus_stop_icons[2] = createBusStopIcon(WEST);</span>
<span class="nc" id="L235">        bus_stop_icons[3] = createBusStopIcon(SOUTH_WEST);</span>
<span class="nc" id="L236">        bus_stop_icons[4] = createBusStopIcon(SOUTH);</span>
<span class="nc" id="L237">        bus_stop_icons[5] = createBusStopIcon(SOUTH_EAST);</span>
<span class="nc" id="L238">        bus_stop_icons[6] = createBusStopIcon(EAST);</span>
<span class="nc" id="L239">        bus_stop_icons[7] = createBusStopIcon(NORTH_EAST);</span>
<span class="nc" id="L240">        bus_stop_icons[8] = createBusStopIcon(NO_DIRECTION);</span>
<span class="nc" id="L241">    }</span>

    /**
     * Creates a bus stop icon with the given direction arrow, or without a direction arrow if
     * the direction is NO_DIRECTION
     *
     * @param direction Bus stop direction, obtained from ObaStop.getDirection() and defined in
     *                  constants in this class, or NO_DIRECTION if the stop icon shouldn't have a
     *                  direction arrow
     * @return a bus stop icon bitmap with the arrow pointing the given direction, or with no arrow
     * if direction is NO_DIRECTION
     */
    private static Bitmap createBusStopIcon(String direction) throws NullPointerException {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (direction == null) {</span>
<span class="nc" id="L255">            throw new IllegalArgumentException(direction);</span>
        }

<span class="nc" id="L258">        Resources r = Application.get().getResources();</span>
<span class="nc" id="L259">        Context context = Application.get();</span>

<span class="nc" id="L261">        Float directionAngle = null;  // 0-360 degrees</span>
        Bitmap bm;
        Canvas c;
        Drawable shape;
<span class="nc" id="L265">        Float rotationX = null, rotationY = null;  // Point around which to rotate the arrow</span>

<span class="nc" id="L267">        Paint arrowPaintFill = new Paint();</span>
<span class="nc" id="L268">        arrowPaintFill.setStyle(Paint.Style.FILL);</span>
<span class="nc" id="L269">        arrowPaintFill.setAntiAlias(true);</span>

<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (direction.equals(NO_DIRECTION)) {</span>
            // Don't draw the arrow
<span class="nc" id="L273">            bm = Bitmap.createBitmap(mPx, mPx, Bitmap.Config.ARGB_8888);</span>
<span class="nc" id="L274">            c = new Canvas(bm);</span>
<span class="nc" id="L275">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L276">            shape.setBounds(0, 0, bm.getWidth(), bm.getHeight());</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        } else if (direction.equals(NORTH)) {</span>
<span class="nc" id="L278">            directionAngle = 0f;</span>
<span class="nc" id="L279">            bm = Bitmap.createBitmap(mPx, (int) (mPx + mBuffer), Bitmap.Config.ARGB_8888);</span>
<span class="nc" id="L280">            c = new Canvas(bm);</span>
<span class="nc" id="L281">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L282">            shape.setBounds(0, (int) mBuffer, mPx, bm.getHeight());</span>
            // Shade with darkest color at tip of arrow
<span class="nc" id="L284">            arrowPaintFill.setShader(</span>
<span class="nc" id="L285">                    new LinearGradient(bm.getWidth() / 2, 0, bm.getWidth() / 2, mArrowHeightPx,</span>
<span class="nc" id="L286">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
            // For NORTH, no rotation occurs - use center of image anyway so we have some value
<span class="nc" id="L289">            rotationX = bm.getWidth() / 2f;</span>
<span class="nc" id="L290">            rotationY = bm.getHeight() / 2f;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        } else if (direction.equals(NORTH_WEST)) {</span>
<span class="nc" id="L292">            directionAngle = 315f;  // Arrow is drawn N, rotate 315 degrees</span>
<span class="nc" id="L293">            bm = Bitmap.createBitmap((int) (mPx + mBuffer),</span>
                    (int) (mPx + mBuffer), Bitmap.Config.ARGB_8888);
<span class="nc" id="L295">            c = new Canvas(bm);</span>
<span class="nc" id="L296">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L297">            shape.setBounds((int) mBuffer, (int) mBuffer, bm.getWidth(), bm.getHeight());</span>
            // Shade with darkest color at tip of arrow
<span class="nc" id="L299">            arrowPaintFill.setShader(</span>
                    new LinearGradient(0, 0, mBuffer, mBuffer,
<span class="nc" id="L301">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
            // Rotate around below coordinates (trial and error)
<span class="nc" id="L304">            rotationX = mPx / 2f + mBuffer / 2f;</span>
<span class="nc" id="L305">            rotationY = bm.getHeight() / 2f - mBuffer / 2f;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        } else if (direction.equals(WEST)) {</span>
<span class="nc" id="L307">            directionAngle = 0f;  // Arrow is drawn pointing West, so no rotation</span>
<span class="nc" id="L308">            bm = Bitmap.createBitmap((int) (mPx + mBuffer), mPx, Bitmap.Config.ARGB_8888);</span>
<span class="nc" id="L309">            c = new Canvas(bm);</span>
<span class="nc" id="L310">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L311">            shape.setBounds((int) mBuffer, 0, bm.getWidth(), bm.getHeight());</span>
<span class="nc" id="L312">            arrowPaintFill.setShader(</span>
<span class="nc" id="L313">                    new LinearGradient(0, bm.getHeight() / 2, mArrowHeightPx, bm.getHeight() / 2,</span>
<span class="nc" id="L314">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
            // For WEST
<span class="nc" id="L317">            rotationX = bm.getHeight() / 2f;</span>
<span class="nc" id="L318">            rotationY = bm.getHeight() / 2f;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_WEST)) {</span>
<span class="nc" id="L320">            directionAngle = 225f;  // Arrow is drawn N, rotate 225 degrees</span>
<span class="nc" id="L321">            bm = Bitmap.createBitmap((int) (mPx + mBuffer),</span>
                    (int) (mPx + mBuffer), Bitmap.Config.ARGB_8888);
<span class="nc" id="L323">            c = new Canvas(bm);</span>
<span class="nc" id="L324">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L325">            shape.setBounds((int) mBuffer, 0, bm.getWidth(), mPx);</span>
<span class="nc" id="L326">            arrowPaintFill.setShader(</span>
<span class="nc" id="L327">                    new LinearGradient(0, bm.getHeight(), mBuffer, bm.getHeight() - mBuffer,</span>
<span class="nc" id="L328">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
            // Rotate around below coordinates (trial and error)
<span class="nc" id="L331">            rotationX = bm.getWidth() / 2f - mBuffer / 4f;</span>
<span class="nc" id="L332">            rotationY = mPx / 2f + mBuffer / 4f;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        } else if (direction.equals(SOUTH)) {</span>
<span class="nc" id="L334">            directionAngle = 180f;  // Arrow is drawn N, rotate 180 degrees</span>
<span class="nc" id="L335">            bm = Bitmap.createBitmap(mPx, (int) (mPx + mBuffer), Bitmap.Config.ARGB_8888);</span>
<span class="nc" id="L336">            c = new Canvas(bm);</span>
<span class="nc" id="L337">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L338">            shape.setBounds(0, 0, bm.getWidth(), (int) (bm.getHeight() - mBuffer));</span>
<span class="nc" id="L339">            arrowPaintFill.setShader(</span>
<span class="nc" id="L340">                    new LinearGradient(bm.getWidth() / 2, bm.getHeight(), bm.getWidth() / 2,</span>
<span class="nc" id="L341">                            bm.getHeight() - mArrowHeightPx,</span>
<span class="nc" id="L342">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
<span class="nc" id="L344">            rotationX = bm.getWidth() / 2f;</span>
<span class="nc" id="L345">            rotationY = bm.getHeight() / 2f;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_EAST)) {</span>
<span class="nc" id="L347">            directionAngle = 135f;  // Arrow is drawn N, rotate 135 degrees</span>
<span class="nc" id="L348">            bm = Bitmap.createBitmap((int) (mPx + mBuffer),</span>
                    (int) (mPx + mBuffer), Bitmap.Config.ARGB_8888);
<span class="nc" id="L350">            c = new Canvas(bm);</span>
<span class="nc" id="L351">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L352">            shape.setBounds(0, 0, mPx, mPx);</span>
<span class="nc" id="L353">            arrowPaintFill.setShader(</span>
<span class="nc" id="L354">                    new LinearGradient(bm.getWidth(), bm.getHeight(), bm.getWidth() - mBuffer,</span>
<span class="nc" id="L355">                            bm.getHeight() - mBuffer,</span>
<span class="nc" id="L356">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
            // Rotate around below coordinates (trial and error)
<span class="nc" id="L359">            rotationX = (mPx + mBuffer / 2) / 2f;</span>
<span class="nc" id="L360">            rotationY = bm.getHeight() / 2f;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        } else if (direction.equals(EAST)) {</span>
<span class="nc" id="L362">            directionAngle = 180f;  // Arrow is drawn pointing West, so rotate 180</span>
<span class="nc" id="L363">            bm = Bitmap.createBitmap((int) (mPx + mBuffer), mPx, Bitmap.Config.ARGB_8888);</span>
<span class="nc" id="L364">            c = new Canvas(bm);</span>
<span class="nc" id="L365">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L366">            shape.setBounds(0, 0, mPx, bm.getHeight());</span>
<span class="nc" id="L367">            arrowPaintFill.setShader(</span>
<span class="nc" id="L368">                    new LinearGradient(bm.getWidth(), bm.getHeight() / 2,</span>
<span class="nc" id="L369">                            bm.getWidth() - mArrowHeightPx, bm.getHeight() / 2,</span>
<span class="nc" id="L370">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
<span class="nc" id="L372">            rotationX = bm.getWidth() / 2f;</span>
<span class="nc" id="L373">            rotationY = bm.getHeight() / 2f;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        } else if (direction.equals(NORTH_EAST)) {</span>
<span class="nc" id="L375">            directionAngle = 45f;  // Arrow is drawn pointing N, so rotate 45 degrees</span>
<span class="nc" id="L376">            bm = Bitmap.createBitmap((int) (mPx + mBuffer),</span>
                    (int) (mPx + mBuffer), Bitmap.Config.ARGB_8888);
<span class="nc" id="L378">            c = new Canvas(bm);</span>
<span class="nc" id="L379">            shape = ContextCompat.getDrawable(context, R.drawable.map_stop_icon);</span>
<span class="nc" id="L380">            shape.setBounds(0, (int) mBuffer, mPx, bm.getHeight());</span>
            // Shade with darkest color at tip of arrow
<span class="nc" id="L382">            arrowPaintFill.setShader(</span>
<span class="nc" id="L383">                    new LinearGradient(bm.getWidth(), 0, bm.getWidth() - mBuffer, mBuffer,</span>
<span class="nc" id="L384">                            r.getColor(R.color.theme_primary), r.getColor(R.color.theme_accent),</span>
                            Shader.TileMode.MIRROR));
            // Rotate around middle of circle
<span class="nc" id="L387">            rotationX = (float) mPx / 2;</span>
<span class="nc" id="L388">            rotationY = bm.getHeight() - (float) mPx / 2;</span>
        } else {
<span class="nc" id="L390">            throw new IllegalArgumentException(direction);</span>
        }

<span class="nc" id="L393">        shape.draw(c);</span>

<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (direction.equals(NO_DIRECTION)) {</span>
            // Everything after this point is for drawing the arrow image, so return the bitmap as-is for no arrow
<span class="nc" id="L397">            return bm;</span>
        }

        /**
         * Draw the arrow - all dimensions should be relative to px so the arrow is drawn the same
         * size for all orientations
         */
        // Height of the cutout in the bottom of the triangle that makes it an arrow (0=triangle)
<span class="nc" id="L405">        final float CUTOUT_HEIGHT = mPx / 12;</span>
<span class="nc" id="L406">        Path path = new Path();</span>
<span class="nc" id="L407">        float x1 = 0, y1 = 0;  // Tip of arrow</span>
<span class="nc" id="L408">        float x2 = 0, y2 = 0;  // lower left</span>
<span class="nc" id="L409">        float x3 = 0, y3 = 0; // cutout in arrow bottom</span>
<span class="nc" id="L410">        float x4 = 0, y4 = 0; // lower right</span>

<span class="nc bnc" id="L412" title="All 4 branches missed.">        if (direction.equals(NORTH) || direction.equals(SOUTH) ||</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">                direction.equals(NORTH_EAST) || direction.equals(SOUTH_EAST) ||</span>
<span class="nc bnc" id="L414" title="All 4 branches missed.">                direction.equals(NORTH_WEST) || direction.equals(SOUTH_WEST)) {</span>
            // Arrow is drawn pointing NORTH
            // Tip of arrow
<span class="nc" id="L417">            x1 = mPx / 2;</span>
<span class="nc" id="L418">            y1 = 0;</span>

            // lower left
<span class="nc" id="L421">            x2 = (mPx / 2) - (mArrowWidthPx / 2);</span>
<span class="nc" id="L422">            y2 = mArrowHeightPx;</span>

            // cutout in arrow bottom
<span class="nc" id="L425">            x3 = mPx / 2;</span>
<span class="nc" id="L426">            y3 = mArrowHeightPx - CUTOUT_HEIGHT;</span>

            // lower right
<span class="nc" id="L429">            x4 = (mPx / 2) + (mArrowWidthPx / 2);</span>
<span class="nc" id="L430">            y4 = mArrowHeightPx;</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">        } else if (direction.equals(EAST) || direction.equals(WEST)) {</span>
            // Arrow is drawn pointing WEST
            // Tip of arrow
<span class="nc" id="L434">            x1 = 0;</span>
<span class="nc" id="L435">            y1 = mPx / 2;</span>

            // lower left
<span class="nc" id="L438">            x2 = mArrowHeightPx;</span>
<span class="nc" id="L439">            y2 = (mPx / 2) - (mArrowWidthPx / 2);</span>

            // cutout in arrow bottom
<span class="nc" id="L442">            x3 = mArrowHeightPx - CUTOUT_HEIGHT;</span>
<span class="nc" id="L443">            y3 = mPx / 2;</span>

            // lower right
<span class="nc" id="L446">            x4 = mArrowHeightPx;</span>
<span class="nc" id="L447">            y4 = (mPx / 2) + (mArrowWidthPx / 2);</span>
        }

<span class="nc" id="L450">        path.setFillType(Path.FillType.EVEN_ODD);</span>
<span class="nc" id="L451">        path.moveTo(x1, y1);</span>
<span class="nc" id="L452">        path.lineTo(x2, y2);</span>
<span class="nc" id="L453">        path.lineTo(x3, y3);</span>
<span class="nc" id="L454">        path.lineTo(x4, y4);</span>
<span class="nc" id="L455">        path.lineTo(x1, y1);</span>
<span class="nc" id="L456">        path.close();</span>

        // Rotate arrow around (rotationX, rotationY) point
<span class="nc" id="L459">        Matrix matrix = new Matrix();</span>
<span class="nc" id="L460">        matrix.postRotate(directionAngle, rotationX, rotationY);</span>
<span class="nc" id="L461">        path.transform(matrix);</span>

<span class="nc" id="L463">        c.drawPath(path, arrowPaintFill);</span>
<span class="nc" id="L464">        c.drawPath(path, mArrowPaintStroke);</span>

<span class="nc" id="L466">        return bm;</span>
    }

    /**
     * Gets the % X offset used for the bus stop icon, for the given direction
     *
     * @param direction Bus stop direction, obtained from ObaStop.getDirection() and defined in
     *                  constants in this class
     * @return percent offset X for the bus stop icon that should be used for that direction
     */
    private static float getXPercentOffsetForDirection(String direction) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (direction.equals(NORTH)) {</span>
            // Middle of icon
<span class="nc" id="L479">            return 0.5f;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        } else if (direction.equals(NORTH_WEST)) {</span>
<span class="nc" id="L481">            return 0.5f + mPercentOffset;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        } else if (direction.equals(WEST)) {</span>
<span class="nc" id="L483">            return 0.5f + mPercentOffset;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_WEST)) {</span>
<span class="nc" id="L485">            return 0.5f + mPercentOffset;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        } else if (direction.equals(SOUTH)) {</span>
            // Middle of icon
<span class="nc" id="L488">            return 0.5f;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_EAST)) {</span>
<span class="nc" id="L490">            return 0.5f - mPercentOffset;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        } else if (direction.equals(EAST)) {</span>
<span class="nc" id="L492">            return 0.5f - mPercentOffset;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        } else if (direction.equals(NORTH_EAST)) {</span>
<span class="nc" id="L494">            return 0.5f - mPercentOffset;</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        } else if (direction.equals(NO_DIRECTION)) {</span>
            // Middle of icon
<span class="nc" id="L497">            return 0.5f;</span>
        } else {
            // Assume middle of icon
<span class="nc" id="L500">            return 0.5f;</span>
        }
    }

    /**
     * Gets the % Y offset used for the bus stop icon, for the given direction
     *
     * @param direction Bus stop direction, obtained from ObaStop.getDirection() and defined in
     *                  constants in this class
     * @return percent offset Y for the bus stop icon that should be used for that direction
     */
    private static float getYPercentOffsetForDirection(String direction) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (direction.equals(NORTH)) {</span>
<span class="nc" id="L513">            return 0.5f + mPercentOffset;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">        } else if (direction.equals(NORTH_WEST)) {</span>
<span class="nc" id="L515">            return 0.5f + mPercentOffset;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">        } else if (direction.equals(WEST)) {</span>
            // Middle of icon
<span class="nc" id="L518">            return 0.5f;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_WEST)) {</span>
<span class="nc" id="L520">            return 0.5f - mPercentOffset;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        } else if (direction.equals(SOUTH)) {</span>
<span class="nc" id="L522">            return 0.5f - mPercentOffset;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_EAST)) {</span>
<span class="nc" id="L524">            return 0.5f - mPercentOffset;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        } else if (direction.equals(EAST)) {</span>
            // Middle of icon
<span class="nc" id="L527">            return 0.5f;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        } else if (direction.equals(NORTH_EAST)) {</span>
<span class="nc" id="L529">            return 0.5f + mPercentOffset;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        } else if (direction.equals(NO_DIRECTION)) {</span>
            // Middle of icon
<span class="nc" id="L532">            return 0.5f;</span>
        } else {
            // Assume middle of icon
<span class="nc" id="L535">            return 0.5f;</span>
        }
    }

    /**
     * Returns the BitMapDescriptor for a particular bus stop icon, based on the stop direction
     *
     * @param direction Bus stop direction, obtained from ObaStop.getDirection() and defined in
     *                  constants in this class
     * @return BitmapDescriptor for the bus stop icon that should be used for that direction
     */
    private static BitmapDescriptor getBitmapDescriptorForBusStopDirection(String direction) {
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (direction.equals(NORTH)) {</span>
<span class="nc" id="L548">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[0]);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        } else if (direction.equals(NORTH_WEST)) {</span>
<span class="nc" id="L550">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[1]);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        } else if (direction.equals(WEST)) {</span>
<span class="nc" id="L552">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[2]);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_WEST)) {</span>
<span class="nc" id="L554">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[3]);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        } else if (direction.equals(SOUTH)) {</span>
<span class="nc" id="L556">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[4]);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        } else if (direction.equals(SOUTH_EAST)) {</span>
<span class="nc" id="L558">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[5]);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        } else if (direction.equals(EAST)) {</span>
<span class="nc" id="L560">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[6]);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        } else if (direction.equals(NORTH_EAST)) {</span>
<span class="nc" id="L562">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[7]);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        } else if (direction.equals(NO_DIRECTION)) {</span>
<span class="nc" id="L564">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[8]);</span>
        } else {
<span class="nc" id="L566">            return BitmapDescriptorFactory.fromBitmap(bus_stop_icons[8]);</span>
        }
    }

    /**
     * Returns the currently focused stop, or null if no stop is in focus
     *
     * @return the currently focused stop, or null if no stop is in focus
     */
    public ObaStop getFocus() {
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (mMarkerData != null) {</span>
<span class="nc" id="L577">            return mMarkerData.getFocus();</span>
        }

<span class="nc" id="L580">        return null;</span>
    }

    /**
     * Sets focus to a particular stop, or pass in null for the stop to clear the focus
     *
     * @param stop   ObaStop to focus on, or null to clear the focus
     * @param routes a list of all route display names that serve this stop
     */
    public void setFocus(ObaStop stop, List&lt;ObaRoute&gt; routes) {
        // Make sure that the MarkerData has been initialized
<span class="nc" id="L591">        setupMarkerData();</span>

<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (stop == null) {</span>
            // Clear the focus
<span class="nc" id="L595">            removeFocus(null);</span>
<span class="nc" id="L596">            return;</span>
        }

        /**
         * If mMarkerData exists before this method is called, the stop reference passed into this
         * method might not match any existing stop reference in our HashMaps, since this stop came
         * from an external REST API call - is this a problem???
         *
         * If so, we'll need to keep another HashMap mapping stopIds to ObaStops so we can pull out
         * an internal reference to an ObaStop object that has the same stopId as the ObaStop object
         * passed into this method.  Then, we would use that internal reference in place of the
         * ObaStop passed into this method.  We don't want to maintain Yet Another HashMap for
         * memory/performance reasons if we don't have to.  For now, I think we can get away with
         * a separate reference that doesn't match the internal HashMaps, since we don't need to
         * match the references.
         */

        /**
         * Make sure that this stop is added to the overlay.  If an intent/orientation change started
         * the map fragment to focus on a stop, no markers may exist on the map
         */
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (!mMarkerData.containsStop(stop)) {</span>
<span class="nc" id="L618">            ArrayList&lt;ObaStop&gt; l = new ArrayList&lt;ObaStop&gt;();</span>
<span class="nc" id="L619">            l.add(stop);</span>
<span class="nc" id="L620">            populateStops(l, routes);</span>
        }

        // Add the focus marker to the map by setting focus to this stop
<span class="nc" id="L624">        doFocusChange(stop);</span>
<span class="nc" id="L625">    }</span>


    private void doFocusChange(ObaStop stop) {
<span class="nc" id="L629">        mMarkerData.setFocus(stop);</span>
<span class="nc" id="L630">        HashMap&lt;String, ObaRoute&gt; routes = mMarkerData.getCachedRoutes();</span>

        // Notify listener
<span class="nc" id="L633">        mOnFocusChangedListener.onFocusChanged(stop, routes, stop.getLocation());</span>
<span class="nc" id="L634">    }</span>

    /**
     * Removes the stop focus and notify listener
     *
     * @param latLng the location on the map where the user tapped if the focus change was
     *               triggered
     *               by the user tapping on the map, or null if the focus change was otherwise
     *               triggered programmatically.
     */
    private void removeFocus(LatLng latLng) {
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (mMarkerData.getFocus() != null) {</span>
<span class="nc" id="L646">            mMarkerData.removeFocus();</span>
        }

         // Set map clicked location, if it exists
<span class="nc" id="L650">         Location location = null;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">         if (latLng != null) {</span>
<span class="nc" id="L652">             location = MapHelpV2.makeLocation(latLng);</span>
         }
         // Notify focus changed every time the map is clicked away from a stop marker
<span class="nc" id="L655">         mOnFocusChangedListener.onFocusChanged(null, null, location);</span>
<span class="nc" id="L656">    }</span>

    private void setupMarkerData() {
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (mMarkerData == null) {</span>
<span class="nc" id="L660">            mMarkerData = new MarkerData();</span>
        }
<span class="nc" id="L662">    }</span>

    /**
     * Data structures to track what stops/markers are currently shown on the map
     */
    class MarkerData {

        /**
         * Stops-for-location REST API endpoint returns 100 markers per call by default
         * (see http://goo.gl/tzvrLb), so we'll support showing max results of around 2 calls
         * before
         * we completely clear the map and start over.  Note that this is a fuzzy max, since we
         * don't
         * want to clear the overlay in the middle of processing an API response and remove markers
         * in
         * the current view
         */
        private static final int FUZZY_MAX_MARKER_COUNT = 200;

        /**
         * A cached set of markers currently shown on the map, up to roughly
         * FUZZY_MAX_MARKER_COUNT in size.  This is needed to add/remove markers from the map.
         * StopId is the key.
         */
        private HashMap&lt;String, Marker&gt; mStopMarkers;

        /**
         * A cached set of ObaStops that are currently shown on the map, up to roughly
         * FUZZY_MAX_MARKER_COUNT in size.  Since onMarkerClick() provides a marker, we need a
         * mapping of that marker to the ObaStop.
         * Marker that represents an ObaStop is the key.
         */
        private HashMap&lt;Marker, ObaStop&gt; mStops;

        /**
         * A cached set of ObaRoutes that serve the currently cached ObaStops.  This is
         * needed to retrieve the route display names that serve a particular stop.
         * RouteId is the key.
         */
        private HashMap&lt;String, ObaRoute&gt; mStopRoutes;

        /**
         * Marker and stop used to indicate which bus stop has focus (i.e., was last
         * clicked/tapped)
         */
        private Marker mCurrentFocusMarker;

        private ObaStop mCurrentFocusStop;

        /**
         * Keep a copy of ObaRoute references for stops have have had focus, so we can reconstruct
         * the mStopRoutes HashMap after clearing the cache
         */
        private List&lt;ObaRoute&gt; mFocusedRoutes;

<span class="nc" id="L717">        MarkerData() {</span>
<span class="nc" id="L718">            mStopMarkers = new HashMap&lt;String, Marker&gt;();</span>
<span class="nc" id="L719">            mStops = new HashMap&lt;Marker, ObaStop&gt;();</span>
<span class="nc" id="L720">            mStopRoutes = new HashMap&lt;String, ObaRoute&gt;();</span>
<span class="nc" id="L721">            mFocusedRoutes = new LinkedList&lt;ObaRoute&gt;();</span>
<span class="nc" id="L722">        }</span>

        synchronized void populate(List&lt;ObaStop&gt; stops, List&lt;ObaRoute&gt; routes) {
<span class="nc" id="L725">            int count = 0;</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">            if (mStopMarkers.size() &gt;= FUZZY_MAX_MARKER_COUNT) {</span>
                // We've exceed our max, so clear the current marker cache and start over
<span class="nc" id="L729">                Log.d(TAG, &quot;Exceed max marker cache of &quot; + FUZZY_MAX_MARKER_COUNT</span>
                        + &quot;, clearing cache&quot;);
<span class="nc" id="L731">                removeMarkersFromMap();</span>
<span class="nc" id="L732">                mStopMarkers.clear();</span>
<span class="nc" id="L733">                mStops.clear();</span>

                // Make sure the currently focused stop still exists on the map
<span class="nc bnc" id="L736" title="All 4 branches missed.">                if (mCurrentFocusStop != null &amp;&amp; mFocusedRoutes != null) {</span>
<span class="nc" id="L737">                    addMarkerToMap(mCurrentFocusStop, mFocusedRoutes);</span>
<span class="nc" id="L738">                    count++;</span>
                }
            }

<span class="nc bnc" id="L742" title="All 2 branches missed.">            for (ObaStop stop : stops) {</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                if (!mStopMarkers.containsKey(stop.getId())) {</span>
<span class="nc" id="L744">                    addMarkerToMap(stop, routes);</span>
<span class="nc" id="L745">                    count++;</span>
                }
<span class="nc" id="L747">            }</span>

<span class="nc" id="L749">            Log.d(TAG, &quot;Added &quot; + count + &quot; markers, total markers = &quot; + mStopMarkers.size());</span>
<span class="nc" id="L750">        }</span>

        /**
         * Places a marker on the map for this stop, and adds it to our marker HashMap
         *
         * @param stop   ObaStop that should be shown on the map
         * @param routes A list of ObaRoutes that serve this stop
         */
        private void addMarkerToMap(ObaStop stop, List&lt;ObaRoute&gt; routes) {
<span class="nc" id="L759">            Marker m = mMap.addMarker(new MarkerOptions()</span>
<span class="nc" id="L760">                            .position(MapHelpV2.makeLatLng(stop.getLocation()))</span>
<span class="nc" id="L761">                            .icon(getBitmapDescriptorForBusStopDirection(stop.getDirection()))</span>
<span class="nc" id="L762">                            .flat(true)</span>
<span class="nc" id="L763">                            .anchor(getXPercentOffsetForDirection(stop.getDirection()),</span>
<span class="nc" id="L764">                                    getYPercentOffsetForDirection(stop.getDirection()))</span>
            );
<span class="nc" id="L766">            mStopMarkers.put(stop.getId(), m);</span>
<span class="nc" id="L767">            mStops.put(m, stop);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            for (ObaRoute route : routes) {</span>
                // ObaRoutes may have already been added for other stops, so check before adding
<span class="nc bnc" id="L770" title="All 2 branches missed.">                if (!mStopRoutes.containsKey(route.getId())) {</span>
<span class="nc" id="L771">                    mStopRoutes.put(route.getId(), route);</span>
                }
<span class="nc" id="L773">            }</span>
<span class="nc" id="L774">        }</span>

        synchronized ObaStop getStopFromMarker(Marker marker) {
<span class="nc" id="L777">            return mStops.get(marker);</span>
        }

        /**
         * Returns true if this overlay contains the provided ObaStop
         *
         * @param stop ObaStop to check for
         * @return true if this overlay contains the provided ObaStop, false if it does not
         */
        synchronized boolean containsStop(ObaStop stop) {
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (stop != null) {</span>
<span class="nc" id="L788">                return containsStop(stop.getId());</span>
            } else {
<span class="nc" id="L790">                return false;</span>
            }
        }

        /**
         * Returns true if this overlay contains the provided stopId
         *
         * @param stopId stopId to check for
         * @return true if this overlay contains the provided stopId, false if it does not
         */
        synchronized boolean containsStop(String stopId) {
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (mStopMarkers != null) {</span>
<span class="nc" id="L802">                return mStopMarkers.containsKey(stopId);</span>
            } else {
<span class="nc" id="L804">                return false;</span>
            }
        }

        /**
         * Gets the ObaRoute objects that have been cached
         *
         * @return a copy of the HashMap containing the ObaRoutes that have been cached, with the
         * routeId as key
         */
        synchronized HashMap&lt;String, ObaRoute&gt; getCachedRoutes() {
<span class="nc" id="L815">            return new HashMap&lt;String, ObaRoute&gt;(mStopRoutes);</span>
        }

        /**
         * Sets the current focus to a particular stop
         *
         * @param stop ObaStop that should have focus
         */
        void setFocus(ObaStop stop) {
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (mCurrentFocusMarker != null) {</span>
                // Remove the current focus marker from map
<span class="nc" id="L826">                mCurrentFocusMarker.remove();</span>
            }
<span class="nc" id="L828">            mCurrentFocusStop = stop;</span>

            // Save a copy of ObaRoute references for this stop, so we have them when clearing cache
<span class="nc" id="L831">            mFocusedRoutes.clear();</span>
<span class="nc" id="L832">            String[] routeIds = stop.getRouteIds();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            for (int i = 0; i &lt; routeIds.length; i++) {</span>
<span class="nc" id="L834">                ObaRoute route = mStopRoutes.get(routeIds[i]);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                if (route != null) {</span>
<span class="nc" id="L836">                    mFocusedRoutes.add(route);</span>
                }
            }

            // Reduce focus marker latitude by small amount to ensure it is always on top of the
            // corresponding stop marker (i.e., so its not identical to stop marker latitude)
<span class="nc" id="L842">            LatLng latLng = new LatLng(stop.getLatitude() - 0.000001, stop.getLongitude());</span>

<span class="nc" id="L844">            mCurrentFocusMarker = mMap.addMarker(new MarkerOptions()</span>
<span class="nc" id="L845">                            .position(latLng)</span>
            );

            // TODO - This doesn't look good since when bouncing, the focus marker is drawn behind
            // the bus stop marker.  Maybe fix with new z-order property?
            // animateMarker(mCurrentFocusMarker);
<span class="nc" id="L851">        }</span>

        /**
         * Give the marker a slight bounce effect
         *
         * @param marker marker to animate
         */
        private void animateMarker(final Marker marker) {
<span class="nc" id="L859">            final Handler handler = new Handler();</span>

<span class="nc" id="L861">            final long startTime = SystemClock.uptimeMillis();</span>
<span class="nc" id="L862">            final long duration = 300; // ms</span>

<span class="nc" id="L864">            Projection proj = mMap.getProjection();</span>
<span class="nc" id="L865">            final LatLng markerLatLng = marker.getPosition();</span>
<span class="nc" id="L866">            Point startPoint = proj.toScreenLocation(markerLatLng);</span>
<span class="nc" id="L867">            startPoint.offset(0, -10);</span>
<span class="nc" id="L868">            final LatLng startLatLng = proj.fromScreenLocation(startPoint);</span>

<span class="nc" id="L870">            final Interpolator interpolator = new BounceInterpolator();</span>

<span class="nc" id="L872">            handler.post(new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L875">                    long elapsed = SystemClock.uptimeMillis() - startTime;</span>
<span class="nc" id="L876">                    float t = interpolator.getInterpolation((float) elapsed / duration);</span>
<span class="nc" id="L877">                    double lng = t * markerLatLng.longitude + (1 - t) * startLatLng.longitude;</span>
<span class="nc" id="L878">                    double lat = t * markerLatLng.latitude + (1 - t) * startLatLng.latitude;</span>
<span class="nc" id="L879">                    marker.setPosition(new LatLng(lat, lng));</span>

<span class="nc bnc" id="L881" title="All 2 branches missed.">                    if (t &lt; 1.0) {</span>
                        // Post again 16ms later (60fps)
<span class="nc" id="L883">                        handler.postDelayed(this, 16);</span>
                    }
<span class="nc" id="L885">                }</span>
            });
<span class="nc" id="L887">        }</span>

        /**
         * Returns the last focused stop, or null if no stop is in focus
         *
         * @return last focused stop, or null if no stop is in focus
         */
        ObaStop getFocus() {
<span class="nc" id="L895">            return mCurrentFocusStop;</span>
        }

        /**
         * Remove focus of a stop on the map
         */
        void removeFocus() {
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (mCurrentFocusMarker != null) {</span>
                // Remove the current focus marker from map
<span class="nc" id="L904">                mCurrentFocusMarker.remove();</span>
<span class="nc" id="L905">                mCurrentFocusMarker = null;</span>
            }
<span class="nc" id="L907">            mFocusedRoutes.clear();</span>
<span class="nc" id="L908">            mCurrentFocusStop = null;</span>
<span class="nc" id="L909">        }</span>

        private void removeMarkersFromMap() {
<span class="nc bnc" id="L912" title="All 2 branches missed.">            for (Map.Entry&lt;String, Marker&gt; entry : mStopMarkers.entrySet()) {</span>
<span class="nc" id="L913">                entry.getValue().remove();</span>
<span class="nc" id="L914">            }</span>
<span class="nc" id="L915">        }</span>

        /**
         * Clears any stop markers from the map
         * @param clearFocusedStop true to clear the currently focused stop, false to leave it on map
         */
        synchronized void clear(boolean clearFocusedStop) {
<span class="nc bnc" id="L922" title="All 2 branches missed.">            if (mStopMarkers != null) {</span>
                // Clear all markers from the map
<span class="nc" id="L924">                removeMarkersFromMap();</span>

                // Clear the data structures
<span class="nc" id="L927">                mStopMarkers.clear();</span>
            }
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (mStops != null) {</span>
<span class="nc" id="L930">                mStops.clear();</span>
            }
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (mStopRoutes != null) {</span>
<span class="nc" id="L933">                mStopRoutes.clear();</span>
            }
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (clearFocusedStop) {</span>
<span class="nc" id="L936">                removeFocus();</span>
            } else {
                // Make sure the currently focused stop still exists on the map
<span class="nc bnc" id="L939" title="All 4 branches missed.">                if (mCurrentFocusStop != null &amp;&amp; mFocusedRoutes != null) {</span>
<span class="nc" id="L940">                    addMarkerToMap(mCurrentFocusStop, mFocusedRoutes);</span>
                }
            }
<span class="nc" id="L943">        }</span>

        synchronized int size() {
<span class="nc" id="L946">            return mStopMarkers.size();</span>
        }
    }

//    @Override
//    public boolean onTrackballEvent(MotionEvent event, MapView view) {
//        final int action = event.getAction();
//        OverlayItem next = null;
//        //Log.d(TAG, &quot;MotionEvent: &quot; + event);
//
//        if (action == MotionEvent.ACTION_MOVE) {
//            final float xDiff = event.getX();
//            final float yDiff = event.getY();
//            // Up
//            if (yDiff &lt;= -1) {
//                next = findNext(getFocus(), true, true);
//            }
//            // Down
//            else if (yDiff &gt;= 1) {
//                next = findNext(getFocus(), true, false);
//            }
//            // Right
//            else if (xDiff &gt;= 1) {
//                next = findNext(getFocus(), false, true);
//            }
//            // Left
//            else if (xDiff &lt;= -1) {
//                next = findNext(getFocus(), false, false);
//            }
//            if (next != null) {
//                setFocus(next);
//                view.postInvalidate();
//            }
//        } else if (action == MotionEvent.ACTION_UP) {
//            final OverlayItem focus = getFocus();
//            if (focus != null) {
//                ArrivalsListActivity.start(mActivity, ((StopOverlayItem) focus).getStop());
//            }
//        }
//        return true;
//    }

//    @Override
//    public boolean onKeyDown(int keyCode, KeyEvent event, MapView view) {
//        //Log.d(TAG, &quot;KeyEvent: &quot; + event);
//        OverlayItem next = null;
//        switch (keyCode) {
//            case KeyEvent.KEYCODE_DPAD_UP:
//                next = findNext(getFocus(), true, true);
//                break;
//            case KeyEvent.KEYCODE_DPAD_DOWN:
//                next = findNext(getFocus(), true, false);
//                break;
//            case KeyEvent.KEYCODE_DPAD_RIGHT:
//                next = findNext(getFocus(), false, true);
//                break;
//            case KeyEvent.KEYCODE_DPAD_LEFT:
//                next = findNext(getFocus(), false, false);
//                break;
//            case KeyEvent.KEYCODE_DPAD_CENTER:
//                final OverlayItem focus = getFocus();
//                if (focus != null) {
//                    ArrivalsListActivity.start(mActivity, ((StopOverlayItem) focus).getStop());
//                }
//                break;
//            default:
//                return false;
//        }
//        if (next != null) {
//            setFocus(next);
//            view.postInvalidate();
//        }
//        return true;
//    }

//    boolean setFocusById(String id) {
//        final int size = size();
//        for (int i = 0; i &lt; size; ++i) {
//            StopOverlayItem item = (StopOverlayItem) getItem(i);
//            if (id.equals(item.getStop().getId())) {
//                setFocus(item);
//                return true;
//            }
//        }
//        return false;
//    }
//
//    String getFocusedId() {
//        final OverlayItem focus = getFocus();
//        if (focus != null) {
//            return ((StopOverlayItem) focus).getStop().getId();
//        }
//        return null;
//    }

//    @Override
//    protected boolean onTap(int index) {
//        final OverlayItem item = getItem(index);
//        if (item.equals(getFocus())) {
//            ObaStop stop = mStops.get(index);
//            ArrivalsListActivity.start(mActivity, stop);
//        } else {
//            setFocus(item);
//            // fix odd behavior where previously selected item is not re-highlighted
//            setLastFocusedIndex(-1);
//        }
//        return true;
//    }

    // The find next routines find the closest item along the specified axis.

//    OverlayItem findNext(OverlayItem initial, boolean lat, boolean positive) {
//        if (initial == null) {
//            return null;
//        }
//        final int size = size();
//        final GeoPoint initialPoint = initial.getPoint();
//        OverlayItem min = initial;
//        int minDist = Integer.MAX_VALUE;
//
//        for (int i = 0; i &lt; size; ++i) {
//            OverlayItem item = getItem(i);
//            GeoPoint point = item.getPoint();
//            final int distX = point.getLongitudeE6() - initialPoint.getLongitudeE6();
//            final int distY = point.getLatitudeE6() - initialPoint.getLatitudeE6();
//
//            // We have to eliminate anything that's going in the wrong direction,
//            // or doesn't change in the correct axis (including the initial point)
//            if (lat) {
//                if (positive) {
//                    // Distance must be positive.
//                    if (distY &lt;= 0) {
//                        continue;
//                    }
//                }
//                // Distance must to be negative.
//                else if (distY &gt;= 0) {
//                    continue;
//                }
//            } else {
//                if (positive) {
//                    // Distance must be positive
//                    if (distX &lt;= 0) {
//                        continue;
//                    }
//                }
//                // Distance must be negative
//                else if (distX &gt;= 0) {
//                    continue;
//                }
//            }
//
//            final int distSq = distX * distX + distY * distY;
//
//            if (distSq &lt; minDist) {
//                min = item;
//                minDist = distSq;
//            }
//        }
//        return min;
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.2.0</div></body></html>