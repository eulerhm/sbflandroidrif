<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VehicleOverlay.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">agencyXGoogleDebug</a> &gt; <a href="index.source.html" class="el_package">org.onebusaway.android.map.googlemapsv2</a> &gt; <span class="el_source">VehicleOverlay.java</span></div><h1>VehicleOverlay.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014 University of South Florida (sjbarbeau@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onebusaway.android.map.googlemapsv2;

import android.app.Activity;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.GradientDrawable;
import android.location.Location;
import android.os.Handler;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.collection.LruCache;
import androidx.core.content.ContextCompat;

import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.MarkerOptions;

import org.onebusaway.android.R;
import org.onebusaway.android.app.Application;
import org.onebusaway.android.io.elements.ObaRoute;
import org.onebusaway.android.io.elements.ObaTrip;
import org.onebusaway.android.io.elements.ObaTripDetails;
import org.onebusaway.android.io.elements.ObaTripStatus;
import org.onebusaway.android.io.elements.OccupancyState;
import org.onebusaway.android.io.elements.Status;
import org.onebusaway.android.io.request.ObaTripsForRouteResponse;
import org.onebusaway.android.ui.TripDetailsActivity;
import org.onebusaway.android.ui.TripDetailsListFragment;
import org.onebusaway.android.util.ArrivalInfoUtils;
import org.onebusaway.android.util.MathUtils;
import org.onebusaway.android.util.UIUtils;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * A map overlay that shows vehicle positions on the map
 */
public class VehicleOverlay implements GoogleMap.OnInfoWindowClickListener, MarkerListeners  {

    interface Controller {
        String getFocusedStopId();
    }

    private static final String TAG = &quot;VehicleOverlay&quot;;

    private GoogleMap mMap;

    private MarkerData mMarkerData;

    private final Activity mActivity;

    private ObaTripsForRouteResponse mLastResponse;

    private CustomInfoWindowAdapter mCustomInfoWindowAdapter;

    private Controller mController;

    private static final int NORTH = 0;  // directions are clockwise, consistent with MathUtils class

    private static final int NORTH_EAST = 1;

    private static final int EAST = 2;

    private static final int SOUTH_EAST = 3;

    private static final int SOUTH = 4;

    private static final int SOUTH_WEST = 5;

    private static final int WEST = 6;

    private static final int NORTH_WEST = 7;

    private static final int NO_DIRECTION = 8;

    private static final int NUM_DIRECTIONS = 9; // 8 directions + undirected mVehicles

    private static final int DEFAULT_VEHICLE_TYPE = ObaRoute.TYPE_BUS; // fall back on bus

    // Vehicle type (if available) -&gt; icon set
    private static LruCache&lt;String, Bitmap&gt; mVehicleUncoloredIcons;

    private static LruCache&lt;String, Bitmap&gt; mVehicleColoredIconCache;
    // Colored versions of vehicle_icons

    /**
     * If a vehicle moves less than this distance (in meters), it will be animated, otherwise it
     * will just disappear and then re-appear
     */
    private static final double MAX_VEHICLE_ANIMATION_DISTANCE = 400;

    /**
     * z-index used to show vehicle markers on top of stop markers (default marker z-index is 0)
     */
    private static final float VEHICLE_MARKER_Z_INDEX = 1;

<span class="nc" id="L126">    public VehicleOverlay(Activity activity, GoogleMap map) {</span>
<span class="nc" id="L127">        mActivity = activity;</span>
<span class="nc" id="L128">        mMap = map;</span>
<span class="nc" id="L129">        loadIcons();</span>
        // Set adapter for custom info window that appears when tapping on vehicle markers
<span class="nc" id="L131">        mCustomInfoWindowAdapter = new CustomInfoWindowAdapter(mActivity);</span>
<span class="nc" id="L132">        setupInfoWindow();</span>
<span class="nc" id="L133">    }</span>

    private void setupInfoWindow() {
<span class="nc" id="L136">        mMap.setInfoWindowAdapter(mCustomInfoWindowAdapter);</span>
<span class="nc" id="L137">        mMap.setOnInfoWindowClickListener(this);</span>
<span class="nc" id="L138">    }</span>

    public void setController(Controller controller) {
<span class="nc" id="L141">        mController = controller;</span>
<span class="nc" id="L142">    }</span>

    /**
     * Updates vehicles for the provided routeIds from the status info from the given
     * ObaTripsForRouteResponse
     *
     * @param routeIds routeIds for which to add vehicle markers to the map.  If a vehicle is
     *                 running a route that is not contained in this list, the vehicle won't be
     *                 shown on the map.
     * @param response response that contains the real-time status info
     */
    public void updateVehicles(HashSet&lt;String&gt; routeIds, ObaTripsForRouteResponse response) {
        // Make sure that the MarkerData has been initialized
<span class="nc" id="L155">        setupMarkerData();</span>
        // Cache the response, so when a marker is tapped we can look up route names from routeIds, etc.
<span class="nc" id="L157">        mLastResponse = response;</span>
        // Show the markers on the map
<span class="nc" id="L159">        mMarkerData.populate(routeIds, response);</span>
<span class="nc" id="L160">    }</span>

    public synchronized int size() {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (mMarkerData != null) {</span>
<span class="nc" id="L164">            return mMarkerData.size();</span>
        } else {
<span class="nc" id="L166">            return 0;</span>
        }
    }

    /**
     * Clears any vehicle markers from the map
     */
    public synchronized void clear() {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (mMarkerData != null) {</span>
<span class="nc" id="L175">            mMarkerData.clear();</span>
<span class="nc" id="L176">            mMarkerData = null;</span>
        }
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (mCustomInfoWindowAdapter != null) {</span>
<span class="nc" id="L179">            mCustomInfoWindowAdapter.cancelUpdates();</span>
        }
<span class="nc" id="L181">    }</span>

    /**
     * Cache the core black template Bitmaps used for vehicle icons
     */
    private static final void loadIcons() {
        /**
         * Cache for colored versions of the vehicle icons.  Total possible number of entries is
         * 9 directions * 4 color types (early, ontime, delayed, scheduled) = 36.  In a test,
         * the RouteMapController used around 15 bitmaps over a 30 min period for 4 vehicles on the
         * map at 10 sec refresh rate.  This can be more depending on the route configuration (if
         * the route has lots of curves) and number of vehicles.  To conserve memory, we'll set the
         * max cache size at 15.
         */
<span class="nc" id="L195">        final int MAX_CACHE_SIZE = 15;</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (mVehicleUncoloredIcons == null) {</span>
<span class="nc" id="L198">            mVehicleUncoloredIcons = new LruCache&lt;&gt;(MAX_CACHE_SIZE);</span>
        }

<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (mVehicleColoredIconCache == null) {</span>
<span class="nc" id="L202">            mVehicleColoredIconCache = new LruCache&lt;&gt;(MAX_CACHE_SIZE);</span>
        }
<span class="nc" id="L204">    }</span>

    /**
     * Gets the icon, ready to color for the given direction and vehicle type
     *
     * @param halfWind    an index between 0 and numHalfWinds-1 that can be used to retrieve
     *                    the direction name for that heading (known as &quot;boxing the compass&quot;, down to the half-wind
     *                    level).
     * @param vehicleType type as defined by GTFS spec. Acceptable values contained in OBARoute.TYPE_*
     *
     * @return the icon ready to color
     */
    private static Bitmap getIcon(int halfWind, int vehicleType) {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (!supportedVehicleType(vehicleType)) {</span>
<span class="nc" id="L218">            vehicleType = DEFAULT_VEHICLE_TYPE;</span>
        }

<span class="nc" id="L221">        String cacheKey = String.format(&quot;%d %d&quot;, halfWind, vehicleType);</span>

<span class="nc" id="L223">        Bitmap b = mVehicleUncoloredIcons.get(cacheKey);</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (b == null) {  // cache miss</span>
<span class="nc bnc" id="L226" title="All 6 branches missed.">            switch (vehicleType) {</span>
                case ObaRoute.TYPE_BUS:
<span class="nc" id="L228">                    b = createBusIcon(halfWind);</span>
<span class="nc" id="L229">                    break;</span>
                case ObaRoute.TYPE_FERRY:
<span class="nc" id="L231">                    b = createFerryIcon(halfWind);</span>
<span class="nc" id="L232">                    break;</span>
                case ObaRoute.TYPE_TRAM:
<span class="nc" id="L234">                    b = createTramIcon(halfWind);</span>
<span class="nc" id="L235">                    break;</span>
                case ObaRoute.TYPE_SUBWAY:
<span class="nc" id="L237">                    b = createSubwayIcon(halfWind);</span>
<span class="nc" id="L238">                    break;</span>
                case ObaRoute.TYPE_RAIL:
<span class="nc" id="L240">                    b = createRailIcon(halfWind);</span>
                    break;
                // default: not needed, since supported vehicles are checked prior
            }
        }

<span class="nc" id="L246">        mVehicleUncoloredIcons.put(cacheKey, b);</span>

<span class="nc" id="L248">        return b;</span>
    }

    private static boolean supportedVehicleType(int vehicleType) {
<span class="nc bnc" id="L252" title="All 10 branches missed.">        return vehicleType == ObaRoute.TYPE_BUS ||</span>
                vehicleType == ObaRoute.TYPE_FERRY ||
                vehicleType == ObaRoute.TYPE_TRAM ||
                vehicleType == ObaRoute.TYPE_SUBWAY ||
                vehicleType == ObaRoute.TYPE_RAIL;

    }

    /**
     * Create the bus icon with the given direction arrows or without a direction arrow
     * for direction of NO_DIRECTION.  Color is black so they can be tinted later.
     *
     * @return vehicle icon bitmap with the arrow pointing the appropriate direction, or with
     * no arrow for NO_DIRECTION
     */
    private static Bitmap createBusIcon(int halfWind) {
<span class="nc" id="L268">        Resources r = Application.get().getResources();</span>
<span class="nc bnc" id="L269" title="All 9 branches missed.">        switch (halfWind) {</span>
            case NORTH:
<span class="nc" id="L271">                return BitmapFactory</span>
<span class="nc" id="L272">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_north_inside);</span>
            case NORTH_EAST:
<span class="nc" id="L274">                return BitmapFactory</span>
<span class="nc" id="L275">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_north_east_inside);</span>
            case EAST:
<span class="nc" id="L277">                return BitmapFactory</span>
<span class="nc" id="L278">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_east_inside);</span>
            case SOUTH_EAST:
<span class="nc" id="L280">                return BitmapFactory</span>
<span class="nc" id="L281">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_south_east_inside);</span>
            case SOUTH:
<span class="nc" id="L283">                return BitmapFactory</span>
<span class="nc" id="L284">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_south_inside);</span>
            case SOUTH_WEST:
<span class="nc" id="L286">                return BitmapFactory</span>
<span class="nc" id="L287">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_south_west_inside);</span>
            case WEST:
<span class="nc" id="L289">                return BitmapFactory</span>
<span class="nc" id="L290">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_west_inside);</span>
            case NORTH_WEST:
<span class="nc" id="L292">                return BitmapFactory</span>
<span class="nc" id="L293">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_north_west_inside);</span>
            default:
<span class="nc" id="L295">                return BitmapFactory</span>
<span class="nc" id="L296">                        .decodeResource(r, R.drawable.ic_marker_with_bus_smaller_none_inside);</span>

        }
    }

    /**
     * Create the tram icon with the given direction arrows or without a direction arrow
     * for direction of NO_DIRECTION.  Color is black so they can be tinted later.
     *
     * @return vehicle icon bitmap with the arrow pointing the appropriate direction, or with
     * no arrow for NO_DIRECTION
     */
    private static Bitmap createTramIcon(int halfWind) {
<span class="nc" id="L309">        Resources r = Application.get().getResources();</span>
<span class="nc bnc" id="L310" title="All 9 branches missed.">        switch (halfWind) {</span>
            case NORTH:
<span class="nc" id="L312">                return BitmapFactory</span>
<span class="nc" id="L313">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_north_inside);</span>
            case NORTH_EAST:
<span class="nc" id="L315">                return BitmapFactory</span>
<span class="nc" id="L316">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_north_east_inside);</span>
            case EAST:
<span class="nc" id="L318">                return BitmapFactory</span>
<span class="nc" id="L319">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_east_inside);</span>
            case SOUTH_EAST:
<span class="nc" id="L321">                return BitmapFactory</span>
<span class="nc" id="L322">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_south_east_inside);</span>
            case SOUTH:
<span class="nc" id="L324">                return BitmapFactory</span>
<span class="nc" id="L325">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_south_inside);</span>
            case SOUTH_WEST:
<span class="nc" id="L327">                return BitmapFactory</span>
<span class="nc" id="L328">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_south_west_inside);</span>
            case WEST:
<span class="nc" id="L330">                return BitmapFactory</span>
<span class="nc" id="L331">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_west_inside);</span>
            case NORTH_WEST:
<span class="nc" id="L333">                return BitmapFactory</span>
<span class="nc" id="L334">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_north_west_inside);</span>
            default:
<span class="nc" id="L336">                return BitmapFactory</span>
<span class="nc" id="L337">                        .decodeResource(r, R.drawable.ic_marker_with_tram_smaller_none_inside);</span>
        }
    }

    /**
     * Create the rail icon with the given direction arrows or without a direction arrow
     * for direction of NO_DIRECTION.  Color is black so they can be tinted later.
     *
     * @return vehicle icon bitmap with the arrow pointing the appropriate direction, or with
     * no arrow for NO_DIRECTION
     */
    private static Bitmap createRailIcon(int halfWind) {
<span class="nc" id="L349">        Resources r = Application.get().getResources();</span>
<span class="nc bnc" id="L350" title="All 9 branches missed.">        switch (halfWind) {</span>
            case NORTH:
<span class="nc" id="L352">                return BitmapFactory</span>
<span class="nc" id="L353">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_north_inside);</span>
            case NORTH_EAST:
<span class="nc" id="L355">                return BitmapFactory</span>
<span class="nc" id="L356">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_north_east_inside);</span>
            case EAST:
<span class="nc" id="L358">                return BitmapFactory</span>
<span class="nc" id="L359">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_east_inside);</span>
            case SOUTH_EAST:
<span class="nc" id="L361">                return BitmapFactory</span>
<span class="nc" id="L362">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_south_east_inside);</span>
            case SOUTH:
<span class="nc" id="L364">                return BitmapFactory</span>
<span class="nc" id="L365">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_south_inside);</span>
            case SOUTH_WEST:
<span class="nc" id="L367">                return BitmapFactory</span>
<span class="nc" id="L368">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_south_west_inside);</span>
            case WEST:
<span class="nc" id="L370">                return BitmapFactory</span>
<span class="nc" id="L371">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_west_inside);</span>
            case NORTH_WEST:
<span class="nc" id="L373">                return BitmapFactory</span>
<span class="nc" id="L374">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_north_west_inside);</span>
            default:
<span class="nc" id="L376">                return BitmapFactory</span>
<span class="nc" id="L377">                        .decodeResource(r, R.drawable.ic_marker_with_train_smaller_none_inside);</span>
        }
    }

    /**
     * Create the ferry icon with the given direction arrows or without a direction arrow
     * for direction of NO_DIRECTION.  Color is black so they can be tinted later.
     *
     * @return vehicle icon bitmap with the arrow pointing the appropriate direction, or with
     * no arrow for NO_DIRECTION
     */
    private static Bitmap createFerryIcon(int halfWind) {
<span class="nc" id="L389">        Resources r = Application.get().getResources();</span>
<span class="nc bnc" id="L390" title="All 9 branches missed.">        switch (halfWind) {</span>
            case NORTH:
<span class="nc" id="L392">                return BitmapFactory</span>
<span class="nc" id="L393">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_north_inside);</span>
            case NORTH_EAST:
<span class="nc" id="L395">                return BitmapFactory</span>
<span class="nc" id="L396">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_north_east_inside);</span>
            case EAST:
<span class="nc" id="L398">                return BitmapFactory</span>
<span class="nc" id="L399">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_east_inside);</span>
            case SOUTH_EAST:
<span class="nc" id="L401">                return BitmapFactory</span>
<span class="nc" id="L402">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_south_east_inside);</span>
            case SOUTH:
<span class="nc" id="L404">                return BitmapFactory</span>
<span class="nc" id="L405">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_south_inside);</span>
            case SOUTH_WEST:
<span class="nc" id="L407">                return BitmapFactory</span>
<span class="nc" id="L408">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_south_west_inside);</span>
            case WEST:
<span class="nc" id="L410">                return BitmapFactory</span>
<span class="nc" id="L411">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_west_inside);</span>
            case NORTH_WEST:
<span class="nc" id="L413">                return BitmapFactory</span>
<span class="nc" id="L414">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_north_west_inside);</span>
            default:
<span class="nc" id="L416">                return BitmapFactory</span>
<span class="nc" id="L417">                        .decodeResource(r, R.drawable.ic_marker_with_boat_smaller_none_inside);</span>
        }
    }

    /**
     * Create the subway icon with the given direction arrows or without a direction arrow
     * for direction of NO_DIRECTION.  Color is black so they can be tinted later.
     *
     * @return vehicle icon bitmap with the arrow pointing the appropriate direction, or with
     * no arrow for NO_DIRECTION
     */
    private static Bitmap createSubwayIcon(int halfWind) {
<span class="nc" id="L429">        Resources r = Application.get().getResources();</span>
<span class="nc bnc" id="L430" title="All 9 branches missed.">        switch (halfWind) {</span>
            case NORTH:
<span class="nc" id="L432">                return BitmapFactory</span>
<span class="nc" id="L433">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_north_inside);</span>
            case NORTH_EAST:
<span class="nc" id="L435">                return BitmapFactory</span>
<span class="nc" id="L436">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_north_east_inside);</span>
            case EAST:
<span class="nc" id="L438">                return BitmapFactory</span>
<span class="nc" id="L439">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_east_inside);</span>
            case SOUTH_EAST:
<span class="nc" id="L441">                return BitmapFactory</span>
<span class="nc" id="L442">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_south_east_inside);</span>
            case SOUTH:
<span class="nc" id="L444">                return BitmapFactory</span>
<span class="nc" id="L445">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_south_inside);</span>
            case SOUTH_WEST:
<span class="nc" id="L447">                return BitmapFactory</span>
<span class="nc" id="L448">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_south_west_inside);</span>
            case WEST:
<span class="nc" id="L450">                return BitmapFactory</span>
<span class="nc" id="L451">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_west_inside);</span>
            case NORTH_WEST:
<span class="nc" id="L453">                return BitmapFactory</span>
<span class="nc" id="L454">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_north_west_inside);</span>
            default:
<span class="nc" id="L456">                return BitmapFactory</span>
<span class="nc" id="L457">                        .decodeResource(r, R.drawable.ic_marker_with_subway_smaller_none_inside);</span>
        }
    }

    /**
     * Add a Bitmap for a colored vehicle icon to the cache
     *
     * @param key    Key for the Bitmap to be added, created by createBitmapCacheKey(halfWind, colorResource)
     * @param bitmap Bitmap to be added that is a colored version of the core black vehicle icons
     */
    private void addBitmapToCache(String key, Bitmap bitmap) {
        // Only add if its not already in the cache
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (getBitmapFromCache(key) == null) {</span>
<span class="nc" id="L470">            mVehicleColoredIconCache.put(key, bitmap);</span>
        }
<span class="nc" id="L472">    }</span>

    /**
     * Get a Bitmap for a colored vehicle icon from the cache
     *
     * @param key Key for the Bitmap, created by createBitmapCacheKey(halfWind, colorResource)
     * @return Bitmap that is a colored version of the core black vehicle icons corresponding to the given key
     */
    private Bitmap getBitmapFromCache(String key) {
<span class="nc" id="L481">        return mVehicleColoredIconCache.get(key);</span>
    }

    /**
     * Creates a key for the vehicle colored icons cache, based on the halfWind (direction) and
     * colorResource
     *
     * @param vehicleType   The type of vehicle based on the GTFS value
     *
     * @param halfWind      an index between 0 and numHalfWinds-1 that can be used to retrieve
     *                      the direction name for that heading (known as &quot;boxing the compass&quot;, down to the half-wind
     *                      level).
     * @param colorResource the color resource ID for the schedule deviation
     * @return a String key for this direction and color vehicle bitmap icon
     */
    private String createBitmapCacheKey(int vehicleType, int halfWind, int colorResource) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (!supportedVehicleType(vehicleType)) {</span>
<span class="nc" id="L498">            vehicleType = DEFAULT_VEHICLE_TYPE;</span>
        }

<span class="nc" id="L501">        return String.valueOf(vehicleType) + &quot; &quot; + String.valueOf(halfWind) + &quot; &quot; + String.valueOf(colorResource);</span>
    }

    /**
     * Get the bitmap, using the cache where possible
     * @param vehicleType the vehicle type, as defined by the GTFS value
     * @param colorResource color resource ID for schedule deviation
     * @param halfWind the direction pointed for the icon
     * @return The bitmap representing the vehicle type with the color and direction
     */
    private Bitmap getBitmap(int vehicleType, int colorResource, int halfWind) {
<span class="nc" id="L512">        int color = ContextCompat.getColor(mActivity, colorResource);</span>

        // Use tram icon for cablecar
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (vehicleType == ObaRoute.TYPE_CABLECAR) {</span>
<span class="nc" id="L516">            vehicleType = ObaRoute.TYPE_TRAM;</span>
        }

<span class="nc" id="L519">        String key = createBitmapCacheKey(vehicleType, halfWind, colorResource);</span>
<span class="nc" id="L520">        Bitmap b = getBitmapFromCache(key);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (b == null) {</span>
            // Cache miss - create Bitmap and add to cache
<span class="nc" id="L523">            b = UIUtils.colorBitmap(getIcon(halfWind, vehicleType), color);</span>
<span class="nc" id="L524">            addBitmapToCache(key, b);</span>
        }
<span class="nc" id="L526">        return b;</span>
    }

    @Override
    public void onInfoWindowClick(Marker marker) {
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (mMarkerData != null) {</span>
            // Show trip details screen for the vehicle associated with this marker
<span class="nc" id="L533">            ObaTripStatus status = mMarkerData.getStatusFromMarker(marker);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (status != null) {</span>
                // Stop any callbacks to refresh the vehicle marker popup balloons
<span class="nc" id="L536">                mCustomInfoWindowAdapter.cancelUpdates();</span>

<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (status != null) {</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">                    if (mController != null &amp;&amp; mController.getFocusedStopId() != null) {</span>
<span class="nc" id="L540">                        TripDetailsActivity.start(mActivity, status.getActiveTripId(),</span>
<span class="nc" id="L541">                                mController.getFocusedStopId(), TripDetailsListFragment.SCROLL_MODE_VEHICLE);</span>
                    } else {
<span class="nc" id="L543">                        TripDetailsActivity.start(mActivity, status.getActiveTripId(),</span>
                                TripDetailsListFragment.SCROLL_MODE_VEHICLE);
                    }
                }
            }
        }
<span class="nc" id="L549">    }</span>

    private void setupMarkerData() {
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (mMarkerData == null) {</span>
<span class="nc" id="L553">            mMarkerData = new MarkerData();</span>
        }
<span class="nc" id="L555">    }</span>


    @Override
    public boolean markerClicked(Marker marker) {
<span class="nc" id="L560">        ObaTripStatus status = mMarkerData.getStatusFromMarker(marker);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (status != null) {</span>
<span class="nc" id="L562">            setupInfoWindow();</span>
<span class="nc" id="L563">            marker.showInfoWindow();</span>
<span class="nc" id="L564">            return true;</span>
        }
<span class="nc" id="L566">        return false;</span>
    }

    @Override
    public void removeMarkerClicked(LatLng latLng) {

<span class="nc" id="L572">    }</span>

    /**
     * Data structures to track what vehicles are currently shown on the map
     */
    class MarkerData {

        /**
         * A cached set of vehicles that are currently shown on the map.  Since onMarkerClick()
         * provides a marker, we need a mapping of that marker to a vehicle/trip.
         * Marker that represents a vehicle is the key, and value is the status for the vehicle.
         */
        private HashMap&lt;Marker, ObaTripStatus&gt; mVehicles;

        /**
         * A cached set of vehicle markers currently shown on the map.  This is needed to
         * add/remove markers from the map.  activeTripId is the key - we can't use vehicleId
         * because we want to show an interpolated position (based on schedule data) for trips
         * without real-time data, and those statuses do not have vehicleIds associated with them,
         * but do have activeTripIds.
         */
        private HashMap&lt;String, Marker&gt; mVehicleMarkers;

        private static final int INITIAL_HASHMAP_SIZE = 5;

<span class="nc" id="L597">        MarkerData() {</span>
<span class="nc" id="L598">            mVehicles = new HashMap&lt;&gt;(INITIAL_HASHMAP_SIZE);</span>
<span class="nc" id="L599">            mVehicleMarkers = new HashMap&lt;&gt;(INITIAL_HASHMAP_SIZE);</span>
<span class="nc" id="L600">        }</span>

        /**
         * Updates markers for the provided routeIds from the status info from the given
         * ObaTripsForRouteResponse
         *
         * @param routeIds markers representing real-time positions for the provided routeIds will
         *                 be
         *                 added to the map.  The response may contain status info for other routes
         *                 as well - we'll only show markers for the routeIds in this HashSet.
         * @param response response that contains the real-time status info
         */
        synchronized void populate(HashSet&lt;String&gt; routeIds, ObaTripsForRouteResponse response) {
<span class="nc" id="L613">            int added = 0;</span>
<span class="nc" id="L614">            int updated = 0;</span>
<span class="nc" id="L615">            ObaTripDetails[] trips = response.getTrips();</span>

            // Keep track of the activeTripIds that should be shown on the map, so we don't need
            // to iterate again later for this same info
<span class="nc" id="L619">            HashSet&lt;String&gt; activeTripIds = new HashSet&lt;&gt;();</span>

            // Add or move markers for vehicles included in response
<span class="nc bnc" id="L622" title="All 2 branches missed.">            for (ObaTripDetails trip : trips) {</span>
<span class="nc" id="L623">                ObaTripStatus status = trip.getStatus();</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (status != null) {</span>
                    // Check if this vehicle is running a route we're interested in and isn't CANCELED
<span class="nc" id="L626">                    String activeRoute = response.getTrip(status.getActiveTripId()).getRouteId();</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">                    if (routeIds.contains(activeRoute) &amp;&amp; !Status.CANCELED.equals(status.getStatus())) {</span>
<span class="nc" id="L628">                        Location l = status.getLastKnownLocation();</span>
<span class="nc" id="L629">                        boolean isRealtime = true;</span>

<span class="nc bnc" id="L631" title="All 2 branches missed.">                        if (l == null) {</span>
                            // If a potentially extrapolated location isn't available, use last position
<span class="nc" id="L633">                            l = status.getPosition();</span>
<span class="nc" id="L634">                            isRealtime = false;</span>
                        }
<span class="nc bnc" id="L636" title="All 2 branches missed.">                        if (!status.isPredicted()) {</span>
<span class="nc" id="L637">                            isRealtime = false;</span>
                        }

<span class="nc" id="L640">                        Marker m = mVehicleMarkers.get(status.getActiveTripId());</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">                        if (m == null) {</span>
                            // New activeTripId
<span class="nc" id="L644">                            addMarkerToMap(l, isRealtime, status, response);</span>
<span class="nc" id="L645">                            added++;</span>
                        } else {
<span class="nc" id="L647">                            updateMarker(m, l, isRealtime, status, response);</span>
<span class="nc" id="L648">                            updated++;</span>
                        }
<span class="nc" id="L650">                        activeTripIds.add(status.getActiveTripId());</span>
                    }
                }
            }
            // Remove markers for any previously added tripIds that aren't in the current response
<span class="nc" id="L655">            int removed = removeInactiveMarkers(activeTripIds);</span>

<span class="nc" id="L657">            Log.d(TAG,</span>
                    &quot;Added &quot; + added + &quot;, updated &quot; + updated + &quot;, removed &quot; + removed
                            + &quot;, total vehicle markers = &quot;
<span class="nc" id="L660">                            + mVehicleMarkers.size());</span>
<span class="nc" id="L661">            Log.d(TAG, &quot;Vehicle LRU cache size=&quot; + mVehicleColoredIconCache.size() + &quot;, hits=&quot;</span>
<span class="nc" id="L662">                    + mVehicleColoredIconCache.hitCount() + &quot;, misses=&quot; + mVehicleColoredIconCache</span>
<span class="nc" id="L663">                    .missCount());</span>

<span class="nc" id="L665">            Log.d(TAG, String.format(&quot;Raw uncolored vehicle LRU cache size=%d, hits=%d, misses=%d&quot;,</span>
<span class="nc" id="L666">                    mVehicleUncoloredIcons.size(),</span>
<span class="nc" id="L667">                    mVehicleUncoloredIcons.hitCount(),</span>
<span class="nc" id="L668">                    mVehicleUncoloredIcons.missCount()));</span>
<span class="nc" id="L669">        }</span>

        /**
         * Places a marker on the map for this vehicle, and adds it to our marker HashMap
         *
         * @param l          Location to add the marker at
         * @param isRealtime true if the marker shown indicate real-time info, false if it should indicate schedule
         * @param status     the vehicles status to add to the map
         * @param response   the response which contained the provided status
         */
        private void addMarkerToMap(Location l, boolean isRealtime, ObaTripStatus status,
                                    ObaTripsForRouteResponse response) {

<span class="nc" id="L682">            Marker m = mMap.addMarker(new MarkerOptions()</span>
<span class="nc" id="L683">                    .position(MapHelpV2.makeLatLng(l))</span>
<span class="nc" id="L684">                    .title(status.getVehicleId())</span>
<span class="nc" id="L685">                    .icon(getVehicleIcon(isRealtime, status, response))</span>
            );
<span class="nc" id="L687">            ProprietaryMapHelpV2.setZIndex(m, VEHICLE_MARKER_Z_INDEX);</span>
<span class="nc" id="L688">            mVehicleMarkers.put(status.getActiveTripId(), m);</span>
<span class="nc" id="L689">            mVehicles.put(m, status);</span>
<span class="nc" id="L690">        }</span>

        /**
         * Update an existing marker on the map with the current vehicle status
         *
         * @param m          Marker to update
         * @param l          Location to add the marker at
         * @param isRealtime true if the marker shown indicate real-time info, false if it should
         *                   indicate schedule
         * @param status     real-time status of the vehicle
         * @param response   response containing the provided status
         */
        private void updateMarker(Marker m, Location l, boolean isRealtime, ObaTripStatus status,
                                  ObaTripsForRouteResponse response) {
<span class="nc" id="L704">            boolean showInfo = m.isInfoWindowShown();</span>
<span class="nc" id="L705">            m.setIcon(getVehicleIcon(isRealtime, status, response));</span>
            // Update Hashmap with newest status - needed to show info when tapping on marker
<span class="nc" id="L707">            mVehicles.put(m, status);</span>
            // Update vehicle position
<span class="nc" id="L709">            Location markerLoc = MapHelpV2.makeLocation(m.getPosition());</span>
            // If its a small distance, animate the movement
<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (l.distanceTo(markerLoc) &lt; MAX_VEHICLE_ANIMATION_DISTANCE) {</span>
<span class="nc" id="L712">                AnimationUtil.animateMarkerTo(m, MapHelpV2.makeLatLng(l));</span>
            } else {
                // Just snap the marker to the new location - large animations look weird
<span class="nc" id="L715">                m.setPosition(MapHelpV2.makeLatLng(l));</span>
            }
            // If the info window was shown, make sure its open (changing the icon could have closed it)
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (showInfo) {</span>
<span class="nc" id="L719">                m.showInfoWindow();</span>
            }
<span class="nc" id="L721">        }</span>

        /**
         * Removes any markers that don't currently represent active vehicles running a route
         *
         * @param activeTripIds a set of active tripIds that are currently running the routes.  Any
         *                      markers for tripIds that aren't in this set will be removed
         *                      from the map.
         * @return the number of removed markers
         */
        private int removeInactiveMarkers(HashSet&lt;String&gt; activeTripIds) {
<span class="nc" id="L732">            int removed = 0;</span>
            // Loop using an Iterator, since per Oracle Iterator.remove() is the only safe way
            // to remove an item from a Collection during iteration:
            // http://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html
            try {
<span class="nc" id="L737">                Iterator&lt;Map.Entry&lt;String, Marker&gt;&gt; iterator = mVehicleMarkers.entrySet()</span>
<span class="nc" id="L738">                        .iterator();</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                while (iterator.hasNext()) {</span>
<span class="nc" id="L740">                    Map.Entry&lt;String, Marker&gt; entry = iterator.next();</span>
<span class="nc" id="L741">                    String tripId = entry.getKey();</span>
<span class="nc" id="L742">                    Marker m = entry.getValue();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                    if (!activeTripIds.contains(tripId)) {</span>
                        // Remove the marker from map and data structures
<span class="nc" id="L745">                        entry.getValue().remove();</span>
<span class="nc" id="L746">                        mVehicles.remove(m);</span>
<span class="nc" id="L747">                        iterator.remove();</span>
<span class="nc" id="L748">                        removed++;</span>
                    }
<span class="nc" id="L750">                }</span>
<span class="nc" id="L751">            } catch (UnsupportedOperationException e) {</span>
<span class="nc" id="L752">                Log.w(TAG, &quot;Problem removing vehicle from HashMap using iterator: &quot; + e);</span>
                //The platform apparently didn't like the &quot;efficient&quot; way to do this, so we'll just
                //loop through a copy and remove what we don't want from the original
<span class="nc" id="L755">                HashMap&lt;String, Marker&gt; copy = new HashMap&lt;&gt;(mVehicleMarkers);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">                for (Map.Entry&lt;String, Marker&gt; entry : copy.entrySet()) {</span>
<span class="nc" id="L757">                    String tripId = entry.getKey();</span>
<span class="nc" id="L758">                    Marker m = entry.getValue();</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                    if (!activeTripIds.contains(tripId)) {</span>
                        // Remove the marker from map and data structures
<span class="nc" id="L761">                        entry.getValue().remove();</span>
<span class="nc" id="L762">                        mVehicles.remove(m);</span>
<span class="nc" id="L763">                        mVehicleMarkers.remove(tripId);</span>
<span class="nc" id="L764">                        removed++;</span>
                    }
<span class="nc" id="L766">                }</span>
<span class="nc" id="L767">            }</span>
<span class="nc" id="L768">            return removed;</span>
        }

        /**
         * Returns an icon for the vehicle that should be shown on the map
         *
         * @param isRealtime true if the marker shown indicate real-time info, false if it should
         *                   indicate schedule
         * @param status     the vehicles status to add to the map
         * @param response   the response which contained the provided status
         * @return an icon for the vehicle that should be shown on the map
         */
        private BitmapDescriptor getVehicleIcon(boolean isRealtime, ObaTripStatus status,
                                                ObaTripsForRouteResponse response) {
<span class="nc" id="L782">            String routeId = response.getTrip(status.getActiveTripId()).getRouteId();</span>
<span class="nc" id="L783">            ObaRoute route = response.getRoute(routeId);</span>
<span class="nc" id="L784">            int vehicleType = route.getType();</span>

            int colorResource;

<span class="nc bnc" id="L788" title="All 2 branches missed.">            if (isRealtime) {</span>
<span class="nc" id="L789">                long deviationMin = TimeUnit.SECONDS.toMinutes(status.getScheduleDeviation());</span>
<span class="nc" id="L790">                colorResource = ArrivalInfoUtils.computeColorFromDeviation(deviationMin);</span>
<span class="nc" id="L791">            } else {</span>
<span class="nc" id="L792">                colorResource = R.color.stop_info_scheduled_time;</span>
            }
<span class="nc" id="L794">            double direction = MathUtils.toDirection(status.getOrientation());</span>
<span class="nc" id="L795">            int halfWind = MathUtils.getHalfWindIndex((float) direction, NUM_DIRECTIONS - 1);</span>
            //Log.d(TAG, &quot;VehicleId=&quot; + status.getVehicleId() + &quot;, orientation= &quot; + status.getOrientation() + &quot;, direction=&quot; + direction + &quot;, halfWind= &quot; + halfWind + &quot;, deviation=&quot; + status.getScheduleDeviation());

<span class="nc" id="L798">            Bitmap b = getBitmap(vehicleType, colorResource, halfWind);</span>
<span class="nc" id="L799">            return BitmapDescriptorFactory.fromBitmap(b);</span>
        }

        synchronized ObaTripStatus getStatusFromMarker(Marker marker) {
<span class="nc" id="L803">            return mVehicles.get(marker);</span>
        }

        private void removeMarkersFromMap() {
<span class="nc bnc" id="L807" title="All 2 branches missed.">            for (Map.Entry&lt;String, Marker&gt; entry : mVehicleMarkers.entrySet()) {</span>
<span class="nc" id="L808">                entry.getValue().remove();</span>
<span class="nc" id="L809">            }</span>
<span class="nc" id="L810">        }</span>

        /**
         * Clears any stop markers from the map
         */
        synchronized void clear() {
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (mVehicleMarkers != null) {</span>
                // Clear all markers from the map
<span class="nc" id="L818">                removeMarkersFromMap();</span>

                // Clear the data structures
<span class="nc" id="L821">                mVehicleMarkers.clear();</span>
<span class="nc" id="L822">                mVehicleMarkers = null;</span>
            }
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (mVehicles != null) {</span>
<span class="nc" id="L825">                mVehicles.clear();</span>
<span class="nc" id="L826">                mVehicles = null;</span>
            }
<span class="nc" id="L828">        }</span>

        synchronized int size() {
<span class="nc" id="L831">            return mVehicleMarkers.size();</span>
        }
    }

    /**
     * Returns true if there is real-time location information for the given status, false if there
     * is not
     *
     * @param status The trip status information that includes location information
     * @return true if there is real-time location information for the given status, false if there
     * is not
     */
    protected static boolean isLocationRealtime(ObaTripStatus status) {
<span class="nc" id="L844">        boolean isRealtime = true;</span>
<span class="nc" id="L845">        Location l = status.getLastKnownLocation();</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L847">            isRealtime = false;</span>
        }
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (!status.isPredicted()) {</span>
<span class="nc" id="L850">            isRealtime = false;</span>
        }
<span class="nc" id="L852">        return isRealtime;</span>
    }

    /**
     * Adapter to show custom info windows when tapping on vehicle markers
     */
    class CustomInfoWindowAdapter implements GoogleMap.InfoWindowAdapter {

        private LayoutInflater mInflater;

        private Context mContext;

        private Marker mCurrentFocusVehicleMarker;

<span class="nc" id="L866">        public CustomInfoWindowAdapter(Context context) {</span>
<span class="nc" id="L867">            this.mInflater = LayoutInflater.from(context);</span>
<span class="nc" id="L868">            this.mContext = context;</span>
<span class="nc" id="L869">        }</span>

        @Override
        public View getInfoWindow(Marker marker) {
<span class="nc" id="L873">            return null;</span>
        }

        @Override
        public View getInfoContents(Marker marker) {
<span class="nc bnc" id="L878" title="All 2 branches missed.">            if (mMarkerData == null) {</span>
                // Markers haven't been initialized yet - use default rendering
<span class="nc" id="L880">                return null;</span>
            }
<span class="nc" id="L882">            ObaTripStatus status = mMarkerData.getStatusFromMarker(marker);</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (status == null) {</span>
                // Marker that the user tapped on wasn't a vehicle - use default rendering
<span class="nc" id="L885">                mCurrentFocusVehicleMarker = null;</span>
<span class="nc" id="L886">                return null;</span>
            }
<span class="nc" id="L888">            mCurrentFocusVehicleMarker = marker;</span>
<span class="nc" id="L889">            View view = mInflater.inflate(R.layout.vehicle_info_window, null);</span>
<span class="nc" id="L890">            Resources r = mContext.getResources();</span>
<span class="nc" id="L891">            TextView routeView = (TextView) view.findViewById(R.id.route_and_destination);</span>
<span class="nc" id="L892">            TextView statusView = (TextView) view.findViewById(R.id.status);</span>
<span class="nc" id="L893">            TextView lastUpdatedView = (TextView) view.findViewById(R.id.last_updated);</span>
<span class="nc" id="L894">            ImageView moreView = (ImageView) view.findViewById(R.id.trip_more_info);</span>
<span class="nc" id="L895">            moreView.setColorFilter(r.getColor(R.color.switch_thumb_normal_material_dark));</span>
<span class="nc" id="L896">            ViewGroup occupancyView = view.findViewById(R.id.occupancy);</span>

            // Get route/trip details
<span class="nc" id="L899">            ObaTrip trip = mLastResponse.getTrip(status.getActiveTripId());</span>
<span class="nc" id="L900">            ObaRoute route = mLastResponse.getRoute(trip.getRouteId());</span>

<span class="nc" id="L902">            routeView.setText(UIUtils.getRouteDisplayName(route) + &quot; &quot; +</span>
<span class="nc" id="L903">                    mContext.getString(R.string.trip_info_separator) + &quot; &quot; + UIUtils</span>
<span class="nc" id="L904">                    .formatDisplayText(trip.getHeadsign()));</span>

<span class="nc" id="L906">            boolean isRealtime = isLocationRealtime(status);</span>

<span class="nc" id="L908">            statusView.setBackgroundResource(R.drawable.round_corners_style_b_status);</span>
<span class="nc" id="L909">            GradientDrawable d = (GradientDrawable) statusView.getBackground();</span>

            // Set padding on status view
<span class="nc" id="L912">            int pSides = UIUtils.dpToPixels(mContext, 5);</span>
<span class="nc" id="L913">            int pTopBottom = UIUtils.dpToPixels(mContext, 2);</span>

            int statusColor;

<span class="nc bnc" id="L917" title="All 2 branches missed.">            if (isRealtime) {</span>
<span class="nc" id="L918">                long deviationMin = TimeUnit.SECONDS.toMinutes(status.getScheduleDeviation());</span>
<span class="nc" id="L919">                String statusString = ArrivalInfoUtils.computeArrivalLabelFromDelay(r, deviationMin);</span>
<span class="nc" id="L920">                statusView.setText(statusString);</span>
<span class="nc" id="L921">                statusColor = ArrivalInfoUtils.computeColorFromDeviation(deviationMin);</span>
<span class="nc" id="L922">                d.setColor(r.getColor(statusColor));</span>
<span class="nc" id="L923">                statusView.setPadding(pSides, pTopBottom, pSides, pTopBottom);</span>
<span class="nc" id="L924">            } else {</span>
                // Scheduled info
<span class="nc" id="L926">                statusView.setText(r.getString(R.string.stop_info_scheduled));</span>
<span class="nc" id="L927">                statusColor = R.color.stop_info_scheduled_time;</span>
<span class="nc" id="L928">                d.setColor(r.getColor(statusColor));</span>
<span class="nc" id="L929">                lastUpdatedView.setText(r.getString(R.string.vehicle_last_updated_scheduled));</span>
<span class="nc" id="L930">                statusView.setPadding(pSides, pTopBottom, pSides, pTopBottom);</span>

                // Hide occupancy by setting null value
<span class="nc" id="L933">                UIUtils.setOccupancyVisibilityAndColor(occupancyView, null, OccupancyState.HISTORICAL);</span>
<span class="nc" id="L934">                UIUtils.setOccupancyContentDescription(occupancyView, null, OccupancyState.HISTORICAL);</span>

<span class="nc" id="L936">                return view;</span>
            }

            // Update last updated time (only shown for real-time info)
<span class="nc" id="L940">            long now = System.currentTimeMillis();</span>
            long lastUpdateTime;
            // Use the last updated time for the position itself, if its available
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (status.getLastLocationUpdateTime() != 0) {</span>
<span class="nc" id="L944">                lastUpdateTime = status.getLastLocationUpdateTime();</span>
            } else {
                // Use the status timestamp for last updated time
<span class="nc" id="L947">                lastUpdateTime = status.getLastUpdateTime();</span>
            }
<span class="nc" id="L949">            long elapsedSec = TimeUnit.MILLISECONDS.toSeconds(now - lastUpdateTime);</span>
<span class="nc" id="L950">            long elapsedMin = TimeUnit.SECONDS.toMinutes(elapsedSec);</span>
<span class="nc" id="L951">            long secMod60 = elapsedSec % 60;</span>

            String lastUpdated;
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (elapsedSec &lt; 60) {</span>
<span class="nc" id="L955">                lastUpdated = r.getString(R.string.vehicle_last_updated_sec,</span>
<span class="nc" id="L956">                        elapsedSec);</span>
            } else {
<span class="nc" id="L958">                lastUpdated = r.getString(R.string.vehicle_last_updated_min_and_sec,</span>
<span class="nc" id="L959">                        elapsedMin, secMod60);</span>
            }
<span class="nc" id="L961">            lastUpdatedView.setText(lastUpdated);</span>

<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (mMarkerRefreshHandler != null) {</span>
<span class="nc" id="L964">                mMarkerRefreshHandler.removeCallbacks(mMarkerRefresh);</span>
<span class="nc" id="L965">                mMarkerRefreshHandler.postDelayed(mMarkerRefresh, MARKER_REFRESH_PERIOD);</span>
            }

<span class="nc bnc" id="L968" title="All 2 branches missed.">            if (status.getOccupancyStatus() != null) {</span>
                // Real-time occupancy data
<span class="nc" id="L970">                UIUtils.setOccupancyVisibilityAndColor(occupancyView, status.getOccupancyStatus(), OccupancyState.REALTIME);</span>
<span class="nc" id="L971">                UIUtils.setOccupancyContentDescription(occupancyView, status.getOccupancyStatus(), OccupancyState.REALTIME);</span>
            } else {
                // Hide occupancy by setting null value
<span class="nc" id="L974">                UIUtils.setOccupancyVisibilityAndColor(occupancyView, null, OccupancyState.REALTIME);</span>
<span class="nc" id="L975">                UIUtils.setOccupancyContentDescription(occupancyView, null, OccupancyState.REALTIME);</span>
            }

<span class="nc" id="L978">            return view;</span>
        }

<span class="nc" id="L981">        private final long MARKER_REFRESH_PERIOD = TimeUnit.SECONDS.toMillis(1);</span>

<span class="nc" id="L983">        private final Handler mMarkerRefreshHandler = new Handler();</span>

<span class="nc" id="L985">        private final Runnable mMarkerRefresh = new Runnable() {</span>
            public void run() {
<span class="nc bnc" id="L987" title="All 2 branches missed.">                if (mCurrentFocusVehicleMarker != null &amp;&amp;</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                        mCurrentFocusVehicleMarker.isInfoWindowShown()) {</span>
                    // Force an update of the marker balloon, so &quot;last updated&quot; time ticks up
<span class="nc" id="L990">                    mCurrentFocusVehicleMarker.showInfoWindow();</span>
                }
<span class="nc" id="L992">            }</span>
        };

        /**
         * Cancels any pending updates of the marker balloon contents
         */
        public void cancelUpdates() {
<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (mMarkerRefreshHandler != null) {</span>
<span class="nc" id="L1000">                mMarkerRefreshHandler.removeCallbacks(mMarkerRefresh);</span>
            }
<span class="nc" id="L1002">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.2.0</div></body></html>