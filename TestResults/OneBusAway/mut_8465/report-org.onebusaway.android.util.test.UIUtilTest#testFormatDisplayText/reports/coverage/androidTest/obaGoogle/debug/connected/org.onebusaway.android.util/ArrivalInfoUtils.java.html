<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrivalInfoUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">obaGoogleDebug</a> &gt; <a href="index.source.html" class="el_package">org.onebusaway.android.util</a> &gt; <span class="el_source">ArrivalInfoUtils.java</span></div><h1>ArrivalInfoUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 University of South Florida (sjbarbeau@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onebusaway.android.util;

import android.content.Context;
import android.content.res.Resources;

import org.onebusaway.android.R;
import org.onebusaway.android.app.Application;
import org.onebusaway.android.io.elements.ObaArrivalInfo;
import org.onebusaway.android.ui.ArrivalInfo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

<span class="nc" id="L31">public class ArrivalInfoUtils {</span>

<span class="fc" id="L33">    final static class InfoComparator implements Comparator&lt;ArrivalInfo&gt; {</span>

        public int compare(ArrivalInfo lhs, ArrivalInfo rhs) {
<span class="fc" id="L36">            return (int) (lhs.getEta() - rhs.getEta());</span>
        }
    }

    /**
     * Converts the ObaArrivalInfo array received from the server to an ArrayList for the adapter
     *
     * @param context
     * @param arrivalInfo
     * @param filter                               routeIds to filter for
     * @param ms                                   current time in milliseconds
     * @param includeArrivalDepartureInStatusLabel true if the arrival/departure label should be
     *                                             included in the status label, false if it should
     *                                             not
     * @return ArrayList of arrival info to be used with the adapter
     */
    public static ArrayList&lt;ArrivalInfo&gt; convertObaArrivalInfo(Context context,
                                                               ObaArrivalInfo[] arrivalInfo,
                                                               ArrayList&lt;String&gt; filter, long ms,
                                                               boolean includeArrivalDepartureInStatusLabel) {
<span class="fc" id="L56">        final int len = arrivalInfo.length;</span>
<span class="fc" id="L57">        ArrayList&lt;ArrivalInfo&gt; result = new ArrayList&lt;ArrivalInfo&gt;(len);</span>
<span class="pc bpc" id="L58" title="1 of 4 branches missed.">        if (filter != null &amp;&amp; filter.size() &gt; 0) {</span>
            // Only add routes that haven't been filtered out
<span class="nc bnc" id="L60" title="All 2 branches missed.">            for (ObaArrivalInfo arrival : arrivalInfo) {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">                if (filter.contains(arrival.getRouteId())) {</span>
<span class="nc" id="L62">                    ArrivalInfo info = new ArrivalInfo(context, arrival, ms,</span>
                            includeArrivalDepartureInStatusLabel);
<span class="nc bnc" id="L64" title="All 2 branches missed.">                    if (shouldAddEta(info)) {</span>
<span class="nc" id="L65">                        result.add(info);</span>
                    }
                }
            }
        } else {
            // Add arrivals for all routes
<span class="fc bfc" id="L71" title="All 2 branches covered.">            for (ObaArrivalInfo obaArrivalInfo : arrivalInfo) {</span>
<span class="fc" id="L72">                ArrivalInfo info = new ArrivalInfo(context, obaArrivalInfo, ms,</span>
                        includeArrivalDepartureInStatusLabel);
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                if (shouldAddEta(info)) {</span>
<span class="fc" id="L75">                    result.add(info);</span>
                }
            }
        }

        // Sort by ETA
<span class="fc" id="L81">        Collections.sort(result, new InfoComparator());</span>
<span class="fc" id="L82">        return result;</span>
    }

    /**
     * Returns true if this ETA should be added based on the user preference for adding negative
     * arrival times, and false if it should not
     *
     * @param info info that includes the ETA to be evaluated
     * @return true if this ETA should be added based on the user preference for adding negative
     * arrival times, and false if it should not
     */
    private static boolean shouldAddEta(ArrivalInfo info) {
<span class="fc" id="L94">        boolean showNegativeArrivals = Application.getPrefs()</span>
<span class="fc" id="L95">                .getBoolean(Application.get().getResources()</span>
<span class="fc" id="L96">                        .getString(R.string.preference_key_show_negative_arrivals), true);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (info.getEta() &gt;= 0) {</span>
            // Always add positive ETAs
<span class="fc" id="L99">            return true;</span>
        } else {
            // Only add negative ETAs based on setting
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            if (showNegativeArrivals) {</span>
<span class="fc" id="L103">                return true;</span>
            }
        }
<span class="nc" id="L106">        return false;</span>
    }

    /**
     * Returns the index in the provided infoList for the first non-negative arrival ETA in the
     * list, or -1 if no non-negative ETAs exist in the list
     *
     * @param infoList list to search for non-negative arrival times, ordered by relative ETA from
     *                 negative infinity to positive infinity
     * @return the index in the provided infoList for the first non-negative arrival ETA in the
     * list, or -1 if no non-negative ETAs exist in the list
     */
    public static int findFirstNonNegativeArrival(ArrayList&lt;ArrivalInfo&gt; infoList) {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        for (int i = 0; i &lt; infoList.size(); i++) {</span>
<span class="fc" id="L120">            ArrivalInfo info = infoList.get(i);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (info.getEta() &gt;= 0) {</span>
<span class="fc" id="L122">                return i;</span>
            }
        }
        // We didn't find any non-negative ETAs
<span class="nc" id="L126">        return -1;</span>
    }

    /**
     * Returns the indexes in the provided infoList for the preferred route/headsign combinations
     * to be prioritized for displayed in the header, or null if no non-negative ETAs exist in the
     * list.  If no route/headsign combinations are favorited, the indexes returned may simply be
     * the indexes of the first (and second, if it exists) non-negative arrival times.
     *
     * @param infoList list to search for non-negative arrival times, ordered by relative ETA from
     *                 negative infinity to positive infinity
     * @return the indexes in the provided infoList for the preferred route/headsign combinations
     * to be prioritized for displayed in the header, or null if no non-negative ETAs exist in the
     * list
     */
    public static ArrayList&lt;Integer&gt; findPreferredArrivalIndexes(ArrayList&lt;ArrivalInfo&gt; infoList) {
        // Start by getting the index of the first non-negative arrival time
<span class="fc" id="L143">        int firstIndex = findFirstNonNegativeArrival(infoList);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (firstIndex == -1) {</span>
<span class="nc" id="L145">            return null;</span>
        }
        // Find any favorites
<span class="fc" id="L148">        ArrayList&lt;Integer&gt; preferredIndexes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (int i = firstIndex; i &lt; infoList.size(); i++) {</span>
<span class="fc" id="L150">            ArrivalInfo info = infoList.get(i);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (info.isRouteAndHeadsignFavorite()) {</span>
<span class="fc" id="L152">                preferredIndexes.add(i);</span>
            }
        }

        // If we have at least two favorites, that's enough to fill the header - return them
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (preferredIndexes.size() &gt;= 2) {</span>
<span class="fc" id="L158">            return preferredIndexes;</span>
        }

        // If we have one favorite, and the index is different from the firstIndex, then add the firstIndex and return
<span class="pc bpc" id="L162" title="3 of 4 branches missed.">        if (preferredIndexes.size() == 1 &amp;&amp; preferredIndexes.get(0) != firstIndex) {</span>
<span class="nc" id="L163">            preferredIndexes.add(firstIndex);</span>
        }

        // If we have no preferred indexes (i.e., starred route/headsigns) at this point, then add the firstIndex
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (preferredIndexes.size() == 0) {</span>
<span class="fc" id="L168">            preferredIndexes.add(firstIndex);</span>

            // If there is another non-negative arrival time, then add it too
<span class="fc" id="L171">            int secondIndex = firstIndex + 1;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            if (secondIndex &lt; infoList.size()) {</span>
<span class="fc" id="L173">                preferredIndexes.add(secondIndex);</span>
            }
        }

<span class="fc" id="L177">        return preferredIndexes;</span>
    }

    /**
     * Returns the status color to be used, depending on whether the vehicle is running early,
     * late,
     * ontime,
     * or if we don't have real-time info (i.e., scheduled)
     *
     * @param scheduled the scheduled time, in minutes past unix epoch
     * @param predicted the predicted time, in minutes past unix epoch
     * @return the status color to be used, depending on whether the vehicle is running early, late,
     * ontime,
     * or if we don't have real-time info (i.e., scheduled)
     */
    public static int computeColor(final long scheduled, final long predicted) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (predicted != 0) {</span>
<span class="fc" id="L194">            return computeColorFromDeviation(predicted - scheduled);</span>
        } else {
            // Use scheduled color
<span class="fc" id="L197">            return R.color.stop_info_scheduled_time;</span>
        }
    }

    /**
     * Returns the status color to be used, depending on whether the vehicle is running early,
     * late,
     * ontime,
     * or if we don't have real-time info (i.e., scheduled)
     *
     * @param delay the deviation from the scheduled time, in minutes - positive means bus is
     *              running late,
     *              negative means early
     * @return the status color to be used, depending on whether the vehicle is running early, late,
     * ontime,
     * or if we don't have real-time info (i.e., scheduled)
     */
    public static int computeColorFromDeviation(final long delay) {
        // Bus is arriving
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (delay &gt; 0) {</span>
            // Arriving delayed
<span class="fc" id="L218">            return R.color.stop_info_delayed;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        } else if (delay &lt; 0) {</span>
            // Arriving early
<span class="fc" id="L221">            return R.color.stop_info_early;</span>
        } else {
            // Arriving on time
<span class="fc" id="L224">            return R.color.stop_info_ontime;</span>
        }
    }

    /**
     * Computes the arrival status label from the delay (i.e., schedule deviation), where positive
     * means the bus is running late and negative means the bus is running ahead of schedule
     *
     * @param delay schedule deviation, in minutes, for this vehicle where positive
     *              means the bus is running late and negative means the bus is running ahead of
     *              schedule
     * @return the arrival status label based on the deviation
     */
    public static String computeArrivalLabelFromDelay(Resources res, long delay) {
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (delay &gt; 0) {</span>
            // Arriving delayed
<span class="fc" id="L240">            return res.getQuantityString(</span>
                    R.plurals.stop_info_arrive_delayed, (int) delay,
<span class="fc" id="L242">                    delay);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        } else if (delay &lt; 0) {</span>
            // Arriving early
<span class="fc" id="L245">            delay = -delay;</span>
<span class="fc" id="L246">            return res</span>
<span class="fc" id="L247">                    .getQuantityString(</span>
                            R.plurals.stop_info_arrive_early,
<span class="fc" id="L249">                            (int) delay, delay);</span>
        } else {
            // Arriving on time
<span class="fc" id="L252">            return res.getString(R.string.stop_info_ontime);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.2.0</div></body></html>