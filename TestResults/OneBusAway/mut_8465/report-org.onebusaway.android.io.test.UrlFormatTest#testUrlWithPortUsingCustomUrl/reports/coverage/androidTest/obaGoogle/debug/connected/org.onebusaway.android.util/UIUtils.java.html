<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UIUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">obaGoogleDebug</a> &gt; <a href="index.source.html" class="el_package">org.onebusaway.android.util</a> &gt; <span class="el_source">UIUtils.java</span></div><h1>UIUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2010-2017 Paul Watts (paulcwatts@gmail.com),
 * University of South  Florida (sjbarbeau@gmail.com), Microsoft Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onebusaway.android.util;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.SearchManager;
import android.content.ActivityNotFoundException;
import android.content.ContentQueryMap;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.ColorStateList;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.PorterDuff;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.location.Location;
import android.media.ExifInterface;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.SystemClock;
import android.provider.Settings;
import android.text.Spannable;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.text.method.LinkMovementMethod;
import android.text.style.ClickableSpan;
import android.util.Log;
import android.util.TypedValue;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.DrawableRes;
import androidx.annotation.NonNull;
import androidx.appcompat.app.ActionBar;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.app.AppCompatDelegate;
import androidx.appcompat.widget.SearchView;
import androidx.core.content.ContextCompat;
import androidx.core.content.pm.ShortcutInfoCompat;
import androidx.core.content.pm.ShortcutManagerCompat;
import androidx.core.content.res.ResourcesCompat;
import androidx.core.graphics.drawable.DrawableCompat;
import androidx.core.graphics.drawable.IconCompat;
import androidx.core.util.Pair;
import androidx.core.view.MenuItemCompat;
import androidx.core.widget.ImageViewCompat;
import androidx.fragment.app.Fragment;

import com.google.android.gms.common.GoogleApiAvailability;
import com.google.firebase.analytics.FirebaseAnalytics;

import org.onebusaway.android.R;
import org.onebusaway.android.app.Application;
import org.onebusaway.android.io.ObaAnalytics;
import org.onebusaway.android.io.ObaApi;
import org.onebusaway.android.io.elements.ObaArrivalInfo;
import org.onebusaway.android.io.elements.ObaRegion;
import org.onebusaway.android.io.elements.ObaRoute;
import org.onebusaway.android.io.elements.ObaSituation;
import org.onebusaway.android.io.elements.ObaStop;
import org.onebusaway.android.io.elements.Occupancy;
import org.onebusaway.android.io.elements.OccupancyState;
import org.onebusaway.android.io.request.ObaArrivalInfoResponse;
import org.onebusaway.android.map.MapParams;
import org.onebusaway.android.provider.ObaContract;
import org.onebusaway.android.ui.ArrivalsListActivity;
import org.onebusaway.android.ui.HomeActivity;
import org.onebusaway.android.ui.RouteInfoActivity;
import org.onebusaway.android.view.RealtimeIndicatorView;
import org.onebusaway.util.comparators.AlphanumComparator;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * A class containing utility methods related to the user interface
 */
<span class="nc" id="L130">public final class UIUtils {</span>

    private static final String TAG = &quot;UIHelp&quot;;

    public static void setupActionBar(AppCompatActivity activity) {
<span class="nc" id="L135">        ActionBar bar = activity.getSupportActionBar();</span>
<span class="nc" id="L136">        bar.setIcon(android.R.color.transparent);</span>
<span class="nc" id="L137">        bar.setDisplayShowTitleEnabled(true);</span>

        // HomeActivity is the root for all other activities
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (!(activity instanceof HomeActivity)) {</span>
<span class="nc" id="L141">            bar.setDisplayHomeAsUpEnabled(true);</span>
        }
<span class="nc" id="L143">    }</span>

    /**
     * Sets up the search view in the action bar
     */
    public static void setupSearch(Activity activity, Menu menu) {
<span class="nc" id="L149">        SearchManager searchManager =</span>
<span class="nc" id="L150">                (SearchManager) activity.getSystemService(Context.SEARCH_SERVICE);</span>
<span class="nc" id="L151">        final MenuItem searchMenu = menu.findItem(R.id.action_search);</span>
<span class="nc" id="L152">        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchMenu);</span>
<span class="nc" id="L153">        searchView.setSearchableInfo(</span>
<span class="nc" id="L154">                searchManager.getSearchableInfo(activity.getComponentName()));</span>
        // Close the keyboard and SearchView at same time when the back button is pressed
<span class="nc" id="L156">        searchView.setOnQueryTextFocusChangeListener(new View.OnFocusChangeListener() {</span>
            @Override
            public void onFocusChange(View view, boolean queryTextFocused) {
<span class="nc bnc" id="L159" title="All 2 branches missed.">                if (!queryTextFocused) {</span>
<span class="nc" id="L160">                    MenuItemCompat.collapseActionView(searchMenu);</span>
                }
<span class="nc" id="L162">            }</span>
        });
<span class="nc" id="L164">    }</span>

    public static void showProgress(Fragment fragment, boolean visible) {
<span class="nc" id="L167">        AppCompatActivity act = (AppCompatActivity) fragment.getActivity();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (act != null) {</span>
<span class="nc" id="L169">            act.setSupportProgressBarIndeterminateVisibility(visible);</span>
        }
<span class="nc" id="L171">    }</span>

    public static void setClickableSpan(TextView v, ClickableSpan span) {
<span class="nc" id="L174">        Spannable text = (Spannable) v.getText();</span>
<span class="nc" id="L175">        text.setSpan(span, 0, text.length(), 0);</span>
<span class="nc" id="L176">        v.setMovementMethod(LinkMovementMethod.getInstance());</span>
<span class="nc" id="L177">    }</span>

    public static void removeAllClickableSpans(TextView v) {
<span class="nc" id="L180">        Spannable text = (Spannable) v.getText();</span>
<span class="nc" id="L181">        ClickableSpan[] spans = text.getSpans(0, text.length(), ClickableSpan.class);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (ClickableSpan cs : spans) {</span>
<span class="nc" id="L183">            text.removeSpan(cs);</span>
        }
<span class="nc" id="L185">    }</span>

    public static int getStopDirectionText(String direction) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (direction.equals(&quot;N&quot;)) {</span>
<span class="nc" id="L189">            return R.string.direction_n;</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        } else if (direction.equals(&quot;NW&quot;)) {</span>
<span class="nc" id="L191">            return R.string.direction_nw;</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        } else if (direction.equals(&quot;W&quot;)) {</span>
<span class="nc" id="L193">            return R.string.direction_w;</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        } else if (direction.equals(&quot;SW&quot;)) {</span>
<span class="nc" id="L195">            return R.string.direction_sw;</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        } else if (direction.equals(&quot;S&quot;)) {</span>
<span class="fc" id="L197">            return R.string.direction_s;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        } else if (direction.equals(&quot;SE&quot;)) {</span>
<span class="nc" id="L199">            return R.string.direction_se;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        } else if (direction.equals(&quot;E&quot;)) {</span>
<span class="nc" id="L201">            return R.string.direction_e;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        } else if (direction.equals(&quot;NE&quot;)) {</span>
<span class="nc" id="L203">            return R.string.direction_ne;</span>
        } else {
<span class="nc" id="L205">            return R.string.direction_none;</span>
        }
    }

    public static String getRouteDisplayName(String routeShortName, String routeLongName) {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if (!TextUtils.isEmpty(routeShortName)) {</span>
<span class="fc" id="L211">            return routeShortName;</span>
        }
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (!TextUtils.isEmpty(routeLongName)) {</span>
<span class="nc" id="L214">            return routeLongName;</span>
        }
        // Just so we never return null.
<span class="nc" id="L217">        return &quot;&quot;;</span>
    }

    public static String getRouteDisplayName(ObaRoute route) {
<span class="fc" id="L221">        return getRouteDisplayName(route.getShortName(), route.getLongName());</span>
    }

    public static String getRouteDisplayName(ObaArrivalInfo arrivalInfo) {
<span class="fc" id="L225">        return getRouteDisplayName(arrivalInfo.getShortName(), arrivalInfo.getRouteLongName());</span>
    }

    public static String getRouteDescription(ObaRoute route) {
<span class="nc" id="L229">        String shortName = route.getShortName();</span>
<span class="nc" id="L230">        String longName = route.getLongName();</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (TextUtils.isEmpty(shortName)) {</span>
<span class="nc" id="L233">            shortName = longName;</span>
        }
<span class="nc bnc" id="L235" title="All 4 branches missed.">        if (TextUtils.isEmpty(longName) || shortName.equals(longName)) {</span>
<span class="nc" id="L236">            longName = route.getDescription();</span>
        }
<span class="nc" id="L238">        return UIUtils.formatDisplayText(longName);</span>
    }

    /**
     * Returns a formatted displayText for displaying in the UI for stops, routes, and headsigns, or
     * null if the displayText is null.  If the displayText IS ALL CAPS and more than one word and
     * does not contain SPLC (see #883), it will be converted to title case (Is All Caps), otherwise
     * the returned string will match the input.
     *
     * @param displayText displayText to be formatted
     * @return formatted text for stop, route, and heasigns for displaying in the UI, or null if the
     * displayText is null.  If the displayText IS ALL CAPS and more than one word and does not
     * contain SPLC (see #883), it will be converted to title case (Is All Caps), otherwise the
     * returned string will match the input.
     */
    public static String formatDisplayText(String displayText) {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (displayText == null) {</span>
<span class="nc" id="L255">            return null;</span>
        }
        // See #883 for &quot;SPLC&quot; logic
<span class="fc bfc" id="L258" title="All 6 branches covered.">        if (MyTextUtils.isAllCaps(displayText) &amp;&amp; displayText.contains(&quot; &quot;) &amp;&amp; !displayText.contains(&quot;SPLC&quot;)) {</span>
<span class="fc" id="L259">            return MyTextUtils.toTitleCase(displayText);</span>
        } else {
<span class="fc" id="L261">            return displayText;</span>
        }
    }

    // Shows or hides the view, depending on whether or not the direction is
    // available.
    public static void setStopDirection(View v, String direction, boolean show) {
<span class="nc" id="L268">        final TextView text = (TextView) v;</span>
<span class="nc" id="L269">        final int directionText = UIUtils.getStopDirectionText(direction);</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">        if ((directionText != R.string.direction_none) || show) {</span>
<span class="nc" id="L271">            text.setText(directionText);</span>
<span class="nc" id="L272">            text.setVisibility(View.VISIBLE);</span>
        } else {
<span class="nc" id="L274">            text.setVisibility(View.GONE);</span>
        }
<span class="nc" id="L276">    }</span>

    // Common code to set a route list item view
    public static void setRouteView(View view, ObaRoute route) {
<span class="nc" id="L280">        TextView shortNameText = (TextView) view.findViewById(R.id.short_name);</span>
<span class="nc" id="L281">        TextView longNameText = (TextView) view.findViewById(R.id.long_name);</span>

<span class="nc" id="L283">        String shortName = route.getShortName();</span>
<span class="nc" id="L284">        String longName = UIUtils.formatDisplayText(route.getLongName());</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (TextUtils.isEmpty(shortName)) {</span>
<span class="nc" id="L287">            shortName = longName;</span>
        }
<span class="nc bnc" id="L289" title="All 4 branches missed.">        if (TextUtils.isEmpty(longName) || shortName.equals(longName)) {</span>
<span class="nc" id="L290">            longName = UIUtils.formatDisplayText(route.getDescription());</span>
        }

<span class="nc" id="L293">        shortNameText.setText(shortName);</span>
<span class="nc" id="L294">        longNameText.setText(longName);</span>
<span class="nc" id="L295">    }</span>

<span class="fc" id="L297">    private static final String[] STOP_USER_PROJECTION = {</span>
            ObaContract.Stops._ID,
            ObaContract.Stops.FAVORITE,
            ObaContract.Stops.USER_NAME
    };

    public static class StopUserInfoMap {

        private final ContentQueryMap mMap;

<span class="nc" id="L307">        public StopUserInfoMap(Context context) {</span>
<span class="nc" id="L308">            ContentResolver cr = context.getContentResolver();</span>
<span class="nc" id="L309">            Cursor c = cr.query(ObaContract.Stops.CONTENT_URI, STOP_USER_PROJECTION, &quot;(&quot;</span>
                    + ObaContract.Stops.USER_NAME + &quot; IS NOT NULL)&quot; + &quot;OR (&quot;
                    + ObaContract.Stops.FAVORITE + &quot;=1)&quot;, null, null);
<span class="nc" id="L312">            mMap = new ContentQueryMap(c, ObaContract.Stops._ID, true, null);</span>
<span class="nc" id="L313">        }</span>

        public void close() {
<span class="nc" id="L316">            mMap.close();</span>
<span class="nc" id="L317">        }</span>

        public void requery() {
<span class="nc" id="L320">            mMap.requery();</span>
<span class="nc" id="L321">        }</span>

        public void setView(View stopRoot, String stopId, String stopName) {
<span class="nc" id="L324">            TextView nameView = (TextView) stopRoot.findViewById(R.id.stop_name);</span>
<span class="nc" id="L325">            setView2(nameView, stopId, stopName, true);</span>
<span class="nc" id="L326">        }</span>

        /**
         * This should be used with compound drawables
         */
        public void setView2(TextView nameView, String stopId, String stopName, boolean showIcon) {
<span class="nc" id="L332">            ContentValues values = mMap.getValues(stopId);</span>
<span class="nc" id="L333">            int icon = 0;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (values != null) {</span>
<span class="nc" id="L335">                Integer i = values.getAsInteger(ObaContract.Stops.FAVORITE);</span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">                final boolean favorite = (i != null) &amp;&amp; (i == 1);</span>
<span class="nc" id="L337">                final String userName = values.getAsString(ObaContract.Stops.USER_NAME);</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">                nameView.setText(TextUtils.isEmpty(userName) ?</span>
<span class="nc" id="L340">                        UIUtils.formatDisplayText(stopName) : userName);</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">                icon = favorite &amp;&amp; showIcon ? R.drawable.ic_toggle_star : 0;</span>
<span class="nc" id="L342">            } else {</span>
<span class="nc" id="L343">                nameView.setText(UIUtils.formatDisplayText(stopName));</span>
            }
<span class="nc" id="L345">            nameView.setCompoundDrawablesWithIntrinsicBounds(icon, 0, 0, 0);</span>
<span class="nc" id="L346">        }</span>
    }

    /**
     * Returns a comma-delimited list of route display names that serve a stop
     * &lt;p/&gt;
     * For example, if a stop was served by &quot;14&quot; and &quot;54&quot;, this method will return &quot;14,54&quot;
     *
     * @param stop   the stop for which the route display names should be serialized
     * @param routes a HashMap containing all routes that serve this stop, with the routeId as the
     *               key.
     *               Note that for efficiency this routes HashMap may contain routes that don't
     *               serve this stop as well -
     *               the routes for the stop are referenced via stop.getRouteDisplayNames()
     * @return comma-delimited list of route display names that serve a stop
     */
    public static String serializeRouteDisplayNames(ObaStop stop,
            HashMap&lt;String, ObaRoute&gt; routes) {
<span class="fc" id="L364">        StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L365">        String[] routeIds = stop.getRouteIds();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int i = 0; i &lt; routeIds.length; i++) {</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (routes != null) {</span>
<span class="fc" id="L368">                ObaRoute route = routes.get(routeIds[i]);</span>
<span class="fc" id="L369">                sb.append(getRouteDisplayName(route));</span>
<span class="fc" id="L370">            } else {</span>
                // We don't have route mappings - use routeIds
<span class="nc" id="L372">                sb.append(routeIds[i]);</span>
            }

<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (i != routeIds.length - 1) {</span>
<span class="fc" id="L376">                sb.append(&quot;,&quot;);</span>
            }
        }

<span class="fc" id="L380">        return sb.toString();</span>
    }

    /**
     * Returns a list of route display names from a serialized list of route display names
     * &lt;p/&gt;
     * See {@link #serializeRouteDisplayNames(ObaStop, java.util.HashMap)}
     *
     * @param serializedRouteDisplayNames comma-separate list of routeIds from serializeRouteDisplayNames()
     * @return list of route display names
     */
    public static List&lt;String&gt; deserializeRouteDisplayNames(String serializedRouteDisplayNames) {
<span class="fc" id="L392">        String[] routes = serializedRouteDisplayNames.split(&quot;,&quot;);</span>
<span class="fc" id="L393">        return Arrays.asList(routes);</span>
    }

    /**
     * Returns a formatted and sorted list of route display names for presentation in a single line
     * &lt;p/&gt;
     * For example, the following list:
     * &lt;p/&gt;
     * 11,1,15, 8b
     * &lt;p/&gt;
     * ...would be formatted as:
     * &lt;p/&gt;
     * 4, 8b, 11, 15
     *
     * @param routeDisplayNames          list of route display names
     * @param nextArrivalRouteShortNames the short route names of the next X arrivals at the stop
     *                                   that are the same.  These will be highlighted in the
     *                                   results.
     * @return a formatted and sorted list of route display names for presentation in a single line
     */
    public static String formatRouteDisplayNames(List&lt;String&gt; routeDisplayNames,
            List&lt;String&gt; nextArrivalRouteShortNames) {
<span class="fc" id="L415">        Collections.sort(routeDisplayNames, new AlphanumComparator());</span>
<span class="fc" id="L416">        StringBuffer sb = new StringBuffer();</span>

<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (int i = 0; i &lt; routeDisplayNames.size(); i++) {</span>
<span class="fc" id="L419">            boolean match = false;</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">            for (String nextArrivalRouteShortName : nextArrivalRouteShortNames) {</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">                if (routeDisplayNames.get(i).equalsIgnoreCase(nextArrivalRouteShortName)) {</span>
<span class="fc" id="L423">                    match = true;</span>
<span class="fc" id="L424">                    break;</span>
                }
<span class="fc" id="L426">            }</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (match) {</span>
                // If this route name matches a route name for the next X arrivals that are the same, highlight this route in the text
<span class="fc" id="L430">                sb.append(routeDisplayNames.get(i) + &quot;*&quot;);</span>
            } else {
                // Just append the normally-formatted route name
<span class="fc" id="L433">                sb.append(routeDisplayNames.get(i));</span>
            }

<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (i != routeDisplayNames.size() - 1) {</span>
<span class="fc" id="L437">                sb.append(&quot;, &quot;);</span>
            }
        }
<span class="fc" id="L440">        return sb.toString();</span>
    }

    /**
     * Generates the dialog text that is used to show detailed information about a particular stop
     *
     * @return a pair of Strings consisting of the &lt;dialog title, dialog message&gt;
     */
    public static Pair&lt;String, String&gt; createStopDetailsDialogText(Context context, String stopName,
            String stopUserName, String stopCode, String stopDirection,
            List&lt;String&gt; routeDisplayNames) {
<span class="fc" id="L451">        final String newLine = &quot;\n&quot;;</span>
<span class="fc" id="L452">        String title = &quot;&quot;;</span>
<span class="fc" id="L453">        StringBuilder message = new StringBuilder();</span>

<span class="fc bfc" id="L455" title="All 2 branches covered.">        if (!TextUtils.isEmpty(stopUserName)) {</span>
<span class="fc" id="L456">            title = stopUserName;</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (stopName != null) {</span>
                // Show official stop name in addition to user name
<span class="fc" id="L459">                message.append(</span>
<span class="fc" id="L460">                        context.getString(R.string.stop_info_official_stop_name_label, stopName))</span>
<span class="fc" id="L461">                        .append(newLine);</span>
            }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        } else if (stopName != null) {</span>
<span class="fc" id="L464">            title = stopName;</span>
        }

<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (stopCode != null) {</span>
<span class="fc" id="L468">            message.append(context.getString(R.string.stop_details_code, stopCode) + newLine);</span>
        }

        // Routes that serve this stop
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (routeDisplayNames != null) {</span>
<span class="fc" id="L473">            String routes = context.getString(R.string.stop_info_route_ids_label) + &quot; &quot; + UIUtils</span>
<span class="fc" id="L474">                    .formatRouteDisplayNames(routeDisplayNames, new ArrayList&lt;String&gt;());</span>
<span class="fc" id="L475">            message.append(routes);</span>
        }

<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (!TextUtils.isEmpty(stopDirection)) {</span>
<span class="fc" id="L479">            message.append(newLine)</span>
<span class="fc" id="L480">                    .append(context.getString(UIUtils.getStopDirectionText(stopDirection)));</span>
        }
<span class="fc" id="L482">        return new Pair(title, message.toString());</span>
    }

    /**
     * Builds an AlertDialog with the given title and message
     *
     * @return an AlertDialog with the given title and message
     */
    public static AlertDialog buildAlertDialog(Context context, String title, String message) {
<span class="nc" id="L491">        AlertDialog.Builder builder = new AlertDialog.Builder(context);</span>
<span class="nc" id="L492">        builder.setTitle(title);</span>
<span class="nc" id="L493">        builder.setMessage(message);</span>
<span class="nc" id="L494">        return builder.create();</span>
    }

    /**
     * Creates a new shortcut for the provided stop, and returns the ShortcutInfo for that shortcut
     * @param context Context used to create the shortcut
     * @param shortcutName the shortcutName for the stop shortcut
     * @param builder Instance of ArrivalsListActivity.Builder for the provided stop
     * @return the ShortcutInfo for the created shortcut
     */
    public static ShortcutInfoCompat createStopShortcut(Context context, String shortcutName, ArrivalsListActivity.Builder builder) {
<span class="nc" id="L505">        final ShortcutInfoCompat shortcut = UIUtils.makeShortcutInfo(context,</span>
                shortcutName,
<span class="nc" id="L507">                builder.getIntent(),</span>
                R.drawable.ic_stop_flag_triangle);
<span class="nc" id="L509">        ShortcutManagerCompat.requestPinShortcut(context, shortcut, null);</span>
<span class="nc" id="L510">        return shortcut;</span>
    }

    /**
     * Creates a new shortcut for the provided route, and returns the ShortcutInfo for that shortcut
     * @param context Context used to create the shortcut
     * @param routeId ID of the route
     * @param routeName short name of the route
     * @return the ShortcutInfo for the created shortcut
     */
    public static ShortcutInfoCompat createRouteShortcut(Context context, String routeId, String routeName) {
<span class="nc" id="L521">        final ShortcutInfoCompat shortcut = UIUtils.makeShortcutInfo(context,</span>
                routeName,
<span class="nc" id="L523">                RouteInfoActivity.makeIntent(context, routeId),</span>
                R.drawable.ic_trip_details);
<span class="nc" id="L525">        ShortcutManagerCompat.requestPinShortcut(context, shortcut, null);</span>
<span class="nc" id="L526">        return shortcut;</span>
    }

    /**
     * Default implementation for making a ShortcutInfoCompat object.  Note that this method doesn't
     * create the actual shortcut on the launcher - ShortcutManagerCompat.requestPinShortcut() must
     * be called with the ShortcutInfoCompat returned from this method to create the shortcut
     * on the launcher.
     *
     * @param name       The name of the shortcut
     * @param destIntent The destination intent
     * @param icon       Resource ID for the shortcut icon - should be black so it can be tinted and
     *                   60dp (2dp of asset padding) for high resolution on launcher screens
     * @return ShortcutInfoCompat that can be used to request pinning the shortcut
     */
    public static ShortcutInfoCompat makeShortcutInfo(Context context, String name,
            Intent destIntent, @DrawableRes int icon) {
        // Make sure the shortcut Activity always launches on top (#626)
<span class="nc" id="L544">        destIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);</span>
<span class="nc" id="L545">        destIntent.setAction(Intent.ACTION_VIEW);</span>

<span class="nc" id="L547">        Drawable drawableIcon = ResourcesCompat</span>
<span class="nc" id="L548">                .getDrawable(context.getResources(), icon, context.getTheme());</span>
<span class="nc" id="L549">        drawableIcon.setColorFilter(ContextCompat.getColor(context, R.color.shortcut_icon),</span>
                PorterDuff.Mode.SRC_IN);
<span class="nc" id="L551">        Drawable drawableBackground = ResourcesCompat</span>
<span class="nc" id="L552">                .getDrawable(context.getResources(), R.drawable.launcher_background, context.getTheme());</span>

<span class="nc" id="L554">        final LayerDrawable layerDrawable = new LayerDrawable(</span>
                new Drawable[]{drawableBackground, drawableIcon});

<span class="nc" id="L557">        int backgroundInset = UIUtils.dpToPixels(context, 2.0f);</span>
<span class="nc" id="L558">        layerDrawable.setLayerInset(0, backgroundInset, backgroundInset, backgroundInset, backgroundInset);</span>
<span class="nc" id="L559">        int iconInset = UIUtils.dpToPixels(context, 7.0f);</span>
<span class="nc" id="L560">        layerDrawable.setLayerInset(1, iconInset, iconInset, iconInset, iconInset);</span>

<span class="nc" id="L562">        final Bitmap b = Bitmap</span>
<span class="nc" id="L563">                .createBitmap(layerDrawable.getIntrinsicWidth(), layerDrawable.getIntrinsicHeight(),</span>
                        Bitmap.Config.ARGB_8888);
<span class="nc" id="L565">        final Canvas canvas = new Canvas(b);</span>
<span class="nc" id="L566">        layerDrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());</span>
<span class="nc" id="L567">        layerDrawable.draw(canvas);</span>

<span class="nc" id="L569">        return new ShortcutInfoCompat.Builder(context, name)</span>
<span class="nc" id="L570">                .setShortLabel(name)</span>
<span class="nc" id="L571">                .setIcon(IconCompat.createWithBitmap(b))</span>
<span class="nc" id="L572">                .setIntent(destIntent)</span>
<span class="nc" id="L573">                .build();</span>
    }

    public static void goToUrl(Context context, String url) {
<span class="nc" id="L577">        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span>
        try {
<span class="nc" id="L579">            context.startActivity(intent);</span>
<span class="nc" id="L580">        } catch (ActivityNotFoundException e) {</span>
<span class="nc" id="L581">            Toast.makeText(context, context.getString(R.string.browser_error), Toast.LENGTH_SHORT)</span>
<span class="nc" id="L582">                    .show();</span>
<span class="nc" id="L583">        }</span>
<span class="nc" id="L584">    }</span>

    public static void goToPhoneDialer(Context context, String url) {
<span class="nc" id="L587">        Intent intent = new Intent(Intent.ACTION_DIAL);</span>
<span class="nc" id="L588">        intent.setData(Uri.parse(url));</span>
<span class="nc" id="L589">        context.startActivity(intent);</span>
<span class="nc" id="L590">    }</span>

    /**
     * Opens email apps based on the given email address
     * @param email address
     * @param location string that shows the current location
     */
    public static void sendEmail(Context context, String email, String location) {
<span class="nc" id="L598">        sendEmail(context, email, location, null, false);</span>
<span class="nc" id="L599">    }</span>

    /**
     * Opens email apps based on the given email address
     * @param email address
     * @param location string that shows the current location
     * @param tripPlanUrl trip planning URL that failed, if this is a trip problem error report, or null if it's not
     */
    public static void sendEmail(Context context, String email, String location,
            String tripPlanUrl, boolean tripPlanFail) {
<span class="nc" id="L609">        String obaRegionName = RegionUtils.getObaRegionName();</span>
<span class="nc" id="L610">        boolean autoRegion = Application.getPrefs()</span>
<span class="nc" id="L611">                .getBoolean(context.getString(R.string.preference_key_auto_select_region), true);</span>
        String regionSelectionMethod;
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (autoRegion) {</span>
<span class="nc" id="L614">            regionSelectionMethod = context.getString(R.string.region_selected_auto);</span>
        } else {
<span class="nc" id="L616">            regionSelectionMethod = context.getString(R.string.region_selected_manually);</span>
        }

<span class="nc" id="L619">        UIUtils.sendEmail(context, email, location, obaRegionName, regionSelectionMethod,</span>
                tripPlanUrl, tripPlanFail);
<span class="nc" id="L621">    }</span>

    /**
     * Opens email apps based on the given email address
     * @param email address
     * @param location string that shows the current location
     * @param regionName name of the current api region
     * @param regionSelectionMethod string that shows if the current api region selected manually or
     *                              automatically
     * @param tripPlanUrl trip planning URL that failed, if this is a trip problem error report, or null if it's not
     */
    private static void sendEmail(Context context, String email, String location, String regionName,
            String regionSelectionMethod, String tripPlanUrl, boolean tripPlanFail) {
<span class="nc" id="L634">        PackageManager pm = context.getPackageManager();</span>
        PackageInfo appInfoOba;
        PackageInfo appInfoGps;
<span class="nc" id="L637">        String obaVersion = &quot;&quot;;</span>
<span class="nc" id="L638">        String googlePlayServicesAppVersion = &quot;&quot;;</span>
        try {
<span class="nc" id="L640">            appInfoOba = pm.getPackageInfo(context.getPackageName(),</span>
                    PackageManager.GET_META_DATA);
<span class="nc" id="L642">            obaVersion = appInfoOba.versionName;</span>
<span class="nc" id="L643">        } catch (PackageManager.NameNotFoundException e) {</span>
            // Leave version as empty string
<span class="nc" id="L645">        }</span>
        try {
<span class="nc" id="L647">            appInfoGps = pm.getPackageInfo(GoogleApiAvailability.GOOGLE_PLAY_SERVICES_PACKAGE, 0);</span>
<span class="nc" id="L648">            googlePlayServicesAppVersion = appInfoGps.versionName;</span>
<span class="nc" id="L649">        } catch (PackageManager.NameNotFoundException e) {</span>
            // Leave version as empty string
<span class="nc" id="L651">        }</span>
        String body;
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (location != null) {</span>
            // Have location
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (tripPlanUrl == null) {</span>
                // No trip plan
<span class="nc" id="L657">                body = context.getString(R.string.bug_report_body,</span>
                        obaVersion,
                        Build.MODEL,
                        Build.VERSION.RELEASE,
<span class="nc" id="L661">                        Build.VERSION.SDK_INT,</span>
                        googlePlayServicesAppVersion,
<span class="nc" id="L663">                        GoogleApiAvailability.GOOGLE_PLAY_SERVICES_VERSION_CODE,</span>
                        regionName,
                        regionSelectionMethod,
                        location);
            } else {
                // Trip plan
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if (tripPlanFail) {</span>
<span class="nc" id="L670">                    body = context.getString(R.string.bug_report_body_trip_plan_fail,</span>
                            obaVersion,
                            Build.MODEL,
                            Build.VERSION.RELEASE,
<span class="nc" id="L674">                            Build.VERSION.SDK_INT,</span>
                            googlePlayServicesAppVersion,
<span class="nc" id="L676">                            GoogleApiAvailability.GOOGLE_PLAY_SERVICES_VERSION_CODE,</span>
                            regionName,
                            regionSelectionMethod,
                            location,
                            tripPlanUrl);
                } else {
<span class="nc" id="L682">                    body = context.getString(R.string.bug_report_body_trip_plan,</span>
                            obaVersion,
                            Build.MODEL,
                            Build.VERSION.RELEASE,
<span class="nc" id="L686">                            Build.VERSION.SDK_INT,</span>
                            googlePlayServicesAppVersion,
<span class="nc" id="L688">                            GoogleApiAvailability.GOOGLE_PLAY_SERVICES_VERSION_CODE,</span>
                            regionName,
                            regionSelectionMethod,
                            location,
                            tripPlanUrl);
                }
            }
        } else {
            // No location
<span class="nc bnc" id="L697" title="All 2 branches missed.">            if (tripPlanUrl == null) {</span>
                // No trip plan
<span class="nc" id="L699">                body = context.getString(R.string.bug_report_body_without_location,</span>
                        obaVersion,
                        Build.MODEL,
                        Build.VERSION.RELEASE,
<span class="nc" id="L703">                        Build.VERSION.SDK_INT);</span>
            } else {
                // Trip plan
<span class="nc bnc" id="L706" title="All 2 branches missed.">                if (tripPlanFail) {</span>
<span class="nc" id="L707">                    body = context.getString(R.string.bug_report_body_trip_plan_without_location_fail,</span>
                            obaVersion,
                            Build.MODEL,
                            Build.VERSION.RELEASE,
<span class="nc" id="L711">                            Build.VERSION.SDK_INT,</span>
                            tripPlanUrl);
                } else {
<span class="nc" id="L714">                    body = context.getString(R.string.bug_report_body_trip_plan_without_location,</span>
                            obaVersion,
                            Build.MODEL,
                            Build.VERSION.RELEASE,
<span class="nc" id="L718">                            Build.VERSION.SDK_INT,</span>
                            tripPlanUrl);
                }
            }
        }

<span class="nc" id="L724">        Intent send = new Intent(Intent.ACTION_SEND);</span>
<span class="nc" id="L725">        send.putExtra(Intent.EXTRA_EMAIL,</span>
                new String[]{email});
        // Show trip planner subject line if we have a trip planning URL
        String subject;
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (tripPlanUrl == null) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (tripPlanFail) {</span>
<span class="nc" id="L731">                subject = context.getString(R.string.bug_report_subject_trip_plan);</span>
            } else {
<span class="nc" id="L733">                subject = context.getString(R.string.bug_report_subject);</span>
            }
        } else {
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (tripPlanFail) {</span>
<span class="nc" id="L737">                subject = context.getString(R.string.bug_report_subject_trip_plan_fail);</span>
            } else {
<span class="nc" id="L739">                subject = context.getString(R.string.bug_report_subject_trip_plan);</span>
            }
        }
<span class="nc" id="L742">        send.putExtra(Intent.EXTRA_SUBJECT, subject);</span>
<span class="nc" id="L743">        send.putExtra(Intent.EXTRA_TEXT, body);</span>
<span class="nc" id="L744">        send.setType(&quot;message/rfc822&quot;);</span>
        try {
<span class="nc" id="L746">            context.startActivity(Intent.createChooser(send, subject));</span>
<span class="nc" id="L747">        } catch (ActivityNotFoundException e) {</span>
<span class="nc" id="L748">            Toast.makeText(context, R.string.bug_report_error, Toast.LENGTH_LONG)</span>
<span class="nc" id="L749">                    .show();</span>
<span class="nc" id="L750">        }</span>
<span class="nc" id="L751">    }</span>

    public static String getRouteErrorString(Context context, int code) {
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (!isConnected(context)) {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (isAirplaneMode(context)) {</span>
<span class="nc" id="L756">                return context.getString(R.string.airplane_mode_error);</span>
            } else {
<span class="nc" id="L758">                return context.getString(R.string.no_network_error);</span>
            }
        }
<span class="nc bnc" id="L761" title="All 5 branches missed.">        switch (code) {</span>
            case ObaApi.OBA_INTERNAL_ERROR:
<span class="nc" id="L763">                return context.getString(R.string.internal_error);</span>
            case ObaApi.OBA_NOT_FOUND:
<span class="nc" id="L765">                ObaRegion r = Application.get().getCurrentRegion();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L767">                    return context.getString(R.string.route_not_found_error_with_region_name,</span>
<span class="nc" id="L768">                            r.getName());</span>
                } else {
<span class="nc" id="L770">                    return context.getString(R.string.route_not_found_error_no_region);</span>
                }
            case ObaApi.OBA_BAD_GATEWAY:
<span class="nc" id="L773">                return context.getString(R.string.bad_gateway_error);</span>
            case ObaApi.OBA_OUT_OF_MEMORY:
<span class="nc" id="L775">                return context.getString(R.string.out_of_memory_error);</span>
            default:
<span class="nc" id="L777">                return context.getString(R.string.generic_comm_error);</span>
        }
    }

    public static String getStopErrorString(Context context, int code) {
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (!isConnected(context)) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (isAirplaneMode(context)) {</span>
<span class="nc" id="L784">                return context.getString(R.string.airplane_mode_error);</span>
            } else {
<span class="nc" id="L786">                return context.getString(R.string.no_network_error);</span>
            }
        }
<span class="nc bnc" id="L789" title="All 5 branches missed.">        switch (code) {</span>
            case ObaApi.OBA_INTERNAL_ERROR:
<span class="nc" id="L791">                return context.getString(R.string.internal_error);</span>
            case ObaApi.OBA_NOT_FOUND:
<span class="nc" id="L793">                ObaRegion r = Application.get().getCurrentRegion();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L795">                    return context</span>
<span class="nc" id="L796">                            .getString(R.string.stop_not_found_error_with_region_name, r.getName());</span>
                } else {
<span class="nc" id="L798">                    return context.getString(R.string.stop_not_found_error_no_region);</span>
                }
            case ObaApi.OBA_BAD_GATEWAY:
<span class="nc" id="L801">                return context.getString(R.string.bad_gateway_error);</span>
            case ObaApi.OBA_OUT_OF_MEMORY:
<span class="nc" id="L803">                return context.getString(R.string.out_of_memory_error);</span>
            default:
<span class="nc" id="L805">                return context.getString(R.string.generic_comm_error);</span>
        }
    }

    /**
     * Returns the resource ID for a user-friendly error message based on device state (if a
     * network
     * connection is available or airplane mode is on) or an OBA REST API response code
     *
     * @param code The status code (one of the ObaApi.OBA_* constants)
     * @return the resource ID for a user-friendly error message based on device state (if a network
     * connection is available or airplane mode is on) or an OBA REST API response code
     */
    public static int getMapErrorString(Context context, int code) {
<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (!isConnected(context)) {</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (isAirplaneMode(context)) {</span>
<span class="nc" id="L821">                return R.string.airplane_mode_error;</span>
            } else {
<span class="nc" id="L823">                return R.string.no_network_error;</span>
            }
        }
<span class="nc bnc" id="L826" title="All 4 branches missed.">        switch (code) {</span>
            case ObaApi.OBA_INTERNAL_ERROR:
<span class="nc" id="L828">                return R.string.internal_error;</span>
            case ObaApi.OBA_BAD_GATEWAY:
<span class="nc" id="L830">                return R.string.bad_gateway_error;</span>
            case ObaApi.OBA_OUT_OF_MEMORY:
<span class="nc" id="L832">                return R.string.out_of_memory_error;</span>
            default:
<span class="nc" id="L834">                return R.string.map_generic_error;</span>
        }
    }

    /**
     * Returns true if the device is in Airplane Mode, and false if the device isn't in Airplane
     * mode or if it can't be determined
     * @param context
     * @return true if the device is in Airplane Mode, and false if the device isn't in Airplane
     * mode or if it can't be determined
     */
    public static boolean isAirplaneMode(Context context) {
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (context == null) {</span>
            // If the context is null, we can't get airplane mode state - assume no
<span class="nc" id="L848">            return false;</span>
        }
<span class="nc" id="L850">        ContentResolver cr = context.getContentResolver();</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">        return Settings.System.getInt(cr, Settings.System.AIRPLANE_MODE_ON, 0) != 0;</span>
    }

    /**
     * Returns true if the device is connected to a network, and false if the device isn't or if it
     * can't be determined
     * @param context
     * @return true if the device is connected to a network, and false if the device isn't or if it
     * can't be determined
     */
    public static boolean isConnected(Context context) {
<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (context == null) {</span>
            // If the context is null, we can't get connected state - assume yes
<span class="nc" id="L864">            return true;</span>
        }
<span class="nc" id="L866">        ConnectivityManager cm =</span>
<span class="nc" id="L867">                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</span>

<span class="nc" id="L869">        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();</span>
<span class="nc bnc" id="L870" title="All 4 branches missed.">        return (activeNetwork != null) &amp;&amp; activeNetwork.isConnectedOrConnecting();</span>
    }

    /**
     * Returns the first string for the query URI.
     */
    public static String stringForQuery(Context context, Uri uri, String column) {
<span class="nc" id="L877">        ContentResolver cr = context.getContentResolver();</span>
<span class="nc" id="L878">        Cursor c = cr.query(uri, new String[]{column}, null, null, null);</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (c != null) {</span>
            try {
<span class="nc bnc" id="L881" title="All 2 branches missed.">                if (c.moveToFirst()) {</span>
<span class="nc" id="L882">                    return c.getString(0);</span>
                }
            } finally {
<span class="nc" id="L885">                c.close();</span>
            }
        }
<span class="nc" id="L888">        return &quot;&quot;;</span>
    }

    public static Integer intForQuery(Context context, Uri uri, String column) {
<span class="nc" id="L892">        ContentResolver cr = context.getContentResolver();</span>
<span class="nc" id="L893">        Cursor c = cr.query(uri, new String[]{column}, null, null, null);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (c != null) {</span>
            try {
<span class="nc bnc" id="L896" title="All 2 branches missed.">                if (c.moveToFirst()) {</span>
<span class="nc" id="L897">                    return c.getInt(0);</span>
                }
            } finally {
<span class="nc" id="L900">                c.close();</span>
            }
        }
<span class="nc" id="L903">        return null;</span>
    }

    public static final int MINUTES_IN_HOUR = 60;

    /**
     * Takes the number of minutes, and returns a user-readable string
     * saying the number of minutes in which no arrivals are coming,
     * or the number of hours and minutes if minutes if minutes &gt; 60
     *
     * @param minutes            number of minutes for which there are no upcoming arrivals
     * @param additionalArrivals true if the response should include the word additional, false if
     *                           it should not
     * @param shortFormat        true if the format should be abbreviated, false if it should be
     *                           long
     * @return a user-readable string saying the number of minutes in which no arrivals are coming,
     * or the number of hours and minutes if minutes &gt; 60
     */
    public static String getNoArrivalsMessage(Context context, int minutes,
            boolean additionalArrivals, boolean shortFormat) {
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (minutes &lt;= MINUTES_IN_HOUR) {</span>
            // Return just minutes
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (additionalArrivals) {</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                if (shortFormat) {</span>
                    // Abbreviated version
<span class="nc" id="L928">                    return context</span>
<span class="nc" id="L929">                            .getString(R.string.stop_info_no_additional_data_minutes_short_format,</span>
<span class="nc" id="L930">                                    minutes);</span>
                } else {
                    // Long version
<span class="nc" id="L933">                    return context</span>
<span class="nc" id="L934">                            .getString(R.string.stop_info_no_additional_data_minutes, minutes);</span>
                }
            } else {
<span class="nc bnc" id="L937" title="All 2 branches missed.">                if (shortFormat) {</span>
                    // Abbreviated version
<span class="nc" id="L939">                    return context</span>
<span class="nc" id="L940">                            .getString(R.string.stop_info_nodata_minutes_short_format, minutes);</span>
                } else {
                    // Long version
<span class="nc" id="L943">                    return context.getString(R.string.stop_info_nodata_minutes, minutes);</span>
                }
            }
        } else {
            // Return hours and minutes
<span class="nc bnc" id="L948" title="All 2 branches missed.">            if (additionalArrivals) {</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                if (shortFormat) {</span>
                    // Abbreviated version
<span class="nc" id="L951">                    return context.getResources()</span>
<span class="nc" id="L952">                            .getQuantityString(</span>
                                    R.plurals.stop_info_no_additional_data_hours_minutes_short_format,
<span class="nc" id="L954">                                    minutes / 60, minutes % 60, minutes / 60);</span>
                } else {
                    // Long version
<span class="nc" id="L957">                    return context.getResources()</span>
<span class="nc" id="L958">                            .getQuantityString(R.plurals.stop_info_no_additional_data_hours_minutes,</span>
<span class="nc" id="L959">                                    minutes / 60, minutes % 60, minutes / 60);</span>
                }
            } else {
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (shortFormat) {</span>
                    // Abbreviated version
<span class="nc" id="L964">                    return context.getResources()</span>
<span class="nc" id="L965">                            .getQuantityString(</span>
                                    R.plurals.stop_info_nodata_hours_minutes_short_format,
                                    minutes / 60,
<span class="nc" id="L968">                                    minutes % 60, minutes / 60);</span>
                } else {
                    // Long version
<span class="nc" id="L971">                    return context.getResources()</span>
<span class="nc" id="L972">                            .getQuantityString(R.plurals.stop_info_nodata_hours_minutes,</span>
                                    minutes / 60,
<span class="nc" id="L974">                                    minutes % 60, minutes / 60);</span>
                }
            }
        }
    }

    /**
     * Returns true if the activity is still active and dialogs can be managed (i.e., displayed
     * or dismissed), or false if it is
     * not
     *
     * @param activity Activity to check for displaying/dismissing a dialog
     * @return true if the activity is still active and dialogs can be managed, or false if it is
     * not
     */
    public static boolean canManageDialog(Activity activity) {
<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (activity == null) {</span>
<span class="nc" id="L991">            return false;</span>
        }

<span class="nc bnc" id="L994" title="All 2 branches missed.">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {</span>
<span class="nc bnc" id="L995" title="All 4 branches missed.">            return !activity.isFinishing() &amp;&amp; !activity.isDestroyed();</span>
        } else {
<span class="nc bnc" id="L997" title="All 2 branches missed.">            return !activity.isFinishing();</span>
        }
    }

    /**
     * Returns true if the context is an Activity and is still active and dialogs can be managed
     * (i.e., displayed or dismissed) OR the context is not an Activity, or false if the Activity
     * is
     * no longer active.
     *
     * NOTE: We really shouldn't display dialogs from a Service - a notification is a better way
     * to communicate with the user.
     *
     * @param context Context to check for displaying/dismissing a dialog
     * @return true if the context is an Activity and is still active and dialogs can be managed
     * (i.e., displayed or dismissed) OR the context is not an Activity, or false if the Activity
     * is
     * no longer active
     */
    public static boolean canManageDialog(Context context) {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L1018">            return false;</span>
        }

<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (context instanceof Activity) {</span>
<span class="nc" id="L1022">            return canManageDialog((Activity) context);</span>
        } else {
            // We really shouldn't be displaying dialogs from a Service, but if for some reason we
            // need to do this, we don't have any way of checking whether its possible
<span class="nc" id="L1026">            return true;</span>
        }
    }

    /**
     * Returns true if the API level supports animating Views using ViewPropertyAnimator, false if
     * it doesn't
     *
     * @return true if the API level supports animating Views using ViewPropertyAnimator, false if
     * it doesn't
     */
    public static boolean canAnimateViewModern() {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1;</span>
    }

    /**
     * Returns true if the API level supports canceling existing animations via the
     * ViewPropertyAnimator, and false if it does not
     *
     * @return true if the API level supports canceling existing animations via the
     * ViewPropertyAnimator, and false if it does not
     */
    public static boolean canCancelAnimation() {
<span class="nc bnc" id="L1049" title="All 2 branches missed.">        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH;</span>
    }

    /**
     * Returns true if the API level supports our Arrival Info Style B (sort by route) views, false
     * if it does not.  See #350 and #275.
     *
     * @return true if the API level supports our Arrival Info Style B (sort by route) views, false
     * if it does not
     */
    public static boolean canSupportArrivalInfoStyleB() {
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH;</span>
    }

    /**
     * Shows a view, using animation if the platform supports it
     *
     * @param v                 View to show
     * @param animationDuration duration of animation
     */
    @TargetApi(14)
    public static void showViewWithAnimation(final View v, int animationDuration) {
        // If we're on a legacy device, show the view without the animation
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (!canAnimateViewModern()) {</span>
<span class="nc" id="L1073">            showViewWithoutAnimation(v);</span>
<span class="nc" id="L1074">            return;</span>
        }

<span class="nc bnc" id="L1077" title="All 4 branches missed.">        if (v.getVisibility() == View.VISIBLE &amp;&amp; v.getAlpha() == 1) {</span>
            // View is already visible and not transparent, return without doing anything
<span class="nc" id="L1079">            return;</span>
        }

<span class="nc" id="L1082">        v.clearAnimation();</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (canCancelAnimation()) {</span>
<span class="nc" id="L1084">            v.animate().cancel();</span>
        }

<span class="nc bnc" id="L1087" title="All 2 branches missed.">        if (v.getVisibility() != View.VISIBLE) {</span>
            // Set the content view to 0% opacity but visible, so that it is visible
            // (but fully transparent) during the animation.
<span class="nc" id="L1090">            v.setAlpha(0f);</span>
<span class="nc" id="L1091">            v.setVisibility(View.VISIBLE);</span>
        }

        // Animate the content view to 100% opacity, and clear any animation listener set on the view.
<span class="nc" id="L1095">        v.animate()</span>
<span class="nc" id="L1096">                .alpha(1f)</span>
<span class="nc" id="L1097">                .setDuration(animationDuration)</span>
<span class="nc" id="L1098">                .setListener(null);</span>
<span class="nc" id="L1099">    }</span>

    /**
     * Shows a view without using animation
     *
     * @param v View to show
     */
    public static void showViewWithoutAnimation(final View v) {
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        if (v.getVisibility() == View.VISIBLE) {</span>
            // View is already visible, return without doing anything
<span class="nc" id="L1109">            return;</span>
        }
<span class="nc" id="L1111">        v.setVisibility(View.VISIBLE);</span>
<span class="nc" id="L1112">    }</span>

    /**
     * Hides a view, using animation if the platform supports it
     *
     * @param v                 View to hide
     * @param animationDuration duration of animation
     */
    @TargetApi(14)
    public static void hideViewWithAnimation(final View v, int animationDuration) {
        // If we're on a legacy device, hide the view without the animation
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (!canAnimateViewModern()) {</span>
<span class="nc" id="L1124">            hideViewWithoutAnimation(v);</span>
<span class="nc" id="L1125">            return;</span>
        }

<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (v.getVisibility() == View.GONE) {</span>
            // View is already gone, return without doing anything
<span class="nc" id="L1130">            return;</span>
        }

<span class="nc" id="L1133">        v.clearAnimation();</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        if (canCancelAnimation()) {</span>
<span class="nc" id="L1135">            v.animate().cancel();</span>
        }

        // Animate the view to 0% opacity. After the animation ends, set its visibility to GONE as
        // an optimization step (it won't participate in layout passes, etc.)
<span class="nc" id="L1140">        v.animate()</span>
<span class="nc" id="L1141">                .alpha(0f)</span>
<span class="nc" id="L1142">                .setDuration(animationDuration)</span>
<span class="nc" id="L1143">                .setListener(new AnimatorListenerAdapter() {</span>
                    @Override
                    public void onAnimationEnd(Animator animation) {
<span class="nc" id="L1146">                        v.setVisibility(View.GONE);</span>
<span class="nc" id="L1147">                    }</span>
                });
<span class="nc" id="L1149">    }</span>

    /**
     * Hides a view without using animation
     *
     * @param v View to hide
     */
    public static void hideViewWithoutAnimation(final View v) {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (v.getVisibility() == View.GONE) {</span>
            // View is already gone, return without doing anything
<span class="nc" id="L1159">            return;</span>
        }
        // Hide the view without animation
<span class="nc" id="L1162">        v.setVisibility(View.GONE);</span>
<span class="nc" id="L1163">    }</span>

    /**
     * Prints View visibility information to the log for debugging purposes
     *
     * @param v View to log visibility information for
     */
    @TargetApi(12)
    public static void logViewVisibility(View v) {
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">            if (v.getVisibility() == View.VISIBLE) {</span>
<span class="nc" id="L1174">                Log.d(TAG, v.getContext().getResources().getResourceEntryName(v.getId())</span>
                        + &quot; is visible&quot;);
<span class="nc bnc" id="L1176" title="All 2 branches missed.">                if (UIUtils.canAnimateViewModern()) {</span>
<span class="nc" id="L1177">                    Log.d(TAG, v.getContext().getResources().getResourceEntryName(v.getId())</span>
<span class="nc" id="L1178">                            + &quot; alpha - &quot; + v.getAlpha());</span>
                }
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            } else if (v.getVisibility() == View.INVISIBLE) {</span>
<span class="nc" id="L1181">                Log.d(TAG, v.getContext().getResources().getResourceEntryName(v.getId())</span>
                        + &quot; is INVISIBLE&quot;);
<span class="nc bnc" id="L1183" title="All 2 branches missed.">            } else if (v.getVisibility() == View.GONE) {</span>
<span class="nc" id="L1184">                Log.d(TAG,</span>
<span class="nc" id="L1185">                        v.getContext().getResources().getResourceEntryName(v.getId()) + &quot; is GONE&quot;);</span>
            } else {
<span class="nc" id="L1187">                Log.d(TAG, v.getContext().getResources().getResourceEntryName(v.getId())</span>
<span class="nc" id="L1188">                        + &quot;.getVisibility() - &quot; + v.getVisibility());</span>
            }
        }
<span class="nc" id="L1191">    }</span>

    /**
     * Converts screen dimension units from dp to pixels, based on algorithm defined in
     * http://developer.android.com/guide/practices/screens_support.html#dips-pels
     *
     * @param dp value in dp
     * @return value in pixels
     */
    public static int dpToPixels(Context context, float dp) {
        // Get the screen's density scale
<span class="fc" id="L1202">        final float scale = context.getResources().getDisplayMetrics().density;</span>
        // Convert the dps to pixels, based on density scale
<span class="fc" id="L1204">        return (int) (dp * scale + 0.5f);</span>
    }

    /**
     * Sets the margins for a given view
     *
     * @param v View to set the margin for
     * @param l left margin, in pixels
     * @param t top margin, in pixels
     * @param r right margin, in pixels
     * @param b bottom margin, in pixels
     */
    public static void setMargins(View v, int l, int t, int r, int b) {
<span class="nc" id="L1217">        ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams();</span>
<span class="nc" id="L1218">        p.setMargins(l, t, r, b);</span>
<span class="nc" id="L1219">        v.setLayoutParams(p);</span>
<span class="nc" id="L1220">    }</span>

    /**
     * Formats a view so it is ignored for accessible access
     */
    public static void setAccessibilityIgnore(View view) {
<span class="nc" id="L1226">        view.setClickable(false);</span>
<span class="nc" id="L1227">        view.setFocusable(false);</span>
<span class="nc" id="L1228">        view.setContentDescription(&quot;&quot;);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) {</span>
<span class="nc" id="L1230">            view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_NO);</span>
        }
<span class="nc" id="L1232">    }</span>

    /**
     * Builds the list of Strings that should be shown for a given trip &quot;Bus Options&quot; menu,
     * provided the arguments for that trip
     *
     * @param c                 Context
     * @param isRouteFavorite   true if this route is a user favorite, false if it is not
     * @param hasUrl            true if the route provides a URL for schedule data, false if it does
     *                          not
     * @param isReminderVisible true if the reminder is currently visible for a trip, false if it
     *                          is
     *                          not
     * @param occupancy occupancy of this trip
     * @param occupancyState occupanceState of this trip
     * @return the list of Strings that should be shown for a given trip, provided the arguments for
     * that trip
     */
    public static List&lt;String&gt; buildTripOptions(Context c, boolean isRouteFavorite, boolean hasUrl,
                                                boolean isReminderVisible, boolean hasRouteFilter, Occupancy occupancy, OccupancyState occupancyState) {
<span class="fc" id="L1252">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        if (!isRouteFavorite) {</span>
<span class="fc" id="L1254">            list.add(c.getString(R.string.bus_options_menu_add_star));</span>
        } else {
<span class="fc" id="L1256">            list.add(c.getString(R.string.bus_options_menu_remove_star));</span>
        }

<span class="fc" id="L1259">        list.add(c.getString(R.string.bus_options_menu_show_route_on_map));</span>
<span class="fc" id="L1260">        list.add(c.getString(R.string.bus_options_menu_show_trip_details));</span>

<span class="fc bfc" id="L1262" title="All 2 branches covered.">        if (!isReminderVisible) {</span>
<span class="fc" id="L1263">            list.add(c.getString(R.string.bus_options_menu_set_reminder));</span>
        } else {
<span class="fc" id="L1265">            list.add(c.getString(R.string.bus_options_menu_edit_reminder));</span>
        }

<span class="fc bfc" id="L1268" title="All 2 branches covered.">        if (!hasRouteFilter) {</span>
<span class="fc" id="L1269">            list.add(c.getString(R.string.bus_options_menu_show_only_this_route));</span>
        } else {
<span class="fc" id="L1271">            list.add(c.getString(R.string.bus_options_menu_show_all_routes));</span>
        }

<span class="fc bfc" id="L1274" title="All 2 branches covered.">        if (hasUrl) {</span>
<span class="fc" id="L1275">            list.add(c.getString(R.string.bus_options_menu_show_route_schedule));</span>
        }

<span class="fc" id="L1278">        list.add(c.getString(R.string.bus_options_menu_report_trip_problem));</span>

<span class="fc bfc" id="L1280" title="All 2 branches covered.">        if (occupancy != null) {</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">            if (occupancyState == OccupancyState.HISTORICAL) {</span>
<span class="fc" id="L1282">                list.add(c.getString(R.string.menu_title_about_historical_occupancy));</span>
            } else {
<span class="fc" id="L1284">                list.add(c.getString(R.string.menu_title_about_occupancy));</span>
            }
        }

<span class="fc" id="L1288">        return list;</span>
    }

    /**
     * Builds the array of icons that should be shown for the trip &quot;Bus Options&quot; menu, given the
     * provided arguments for that trip
     *
     * @param isRouteFavorite   true if this route is a user favorite, false if it is not
     * @param hasUrl true if the route provides a URL for schedule data, false if it does
     *               not
     * @param occupancy occupancy of this trip
     * @return the array of icons that should be shown for a given trip
     */
    public static List&lt;Integer&gt; buildTripOptionsIcons(boolean isRouteFavorite, boolean hasUrl, Occupancy occupancy) {
<span class="nc" id="L1302">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (!isRouteFavorite) {</span>
<span class="nc" id="L1304">            list.add(R.drawable.focus_star_on);</span>
        } else {
<span class="nc" id="L1306">            list.add(R.drawable.focus_star_off);</span>
        }
<span class="nc" id="L1308">        list.add(R.drawable.ic_arrivals_styleb_action_map);</span>
<span class="nc" id="L1309">        list.add(R.drawable.ic_trip_details);</span>
<span class="nc" id="L1310">        list.add(R.drawable.ic_drawer_alarm);</span>
<span class="nc" id="L1311">        list.add(R.drawable.ic_content_filter_list);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        if (hasUrl) {</span>
<span class="nc" id="L1313">            list.add(R.drawable.ic_notification_event_note);</span>
        }
<span class="nc" id="L1315">        list.add(R.drawable.ic_alert_warning);</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if (occupancy != null) {</span>
<span class="nc" id="L1317">            list.add(R.drawable.ic_occupancy);</span>
        }
<span class="nc" id="L1319">        return list;</span>
    }

    /**
     * Sets the line and fill colors for real-time indicator circles contained in the provided
     * realtime_indicator.xml layout.  There are several circles, so each needs to be set
     * individually.  The resource code for the color to be used should be provided.
     *
     * @param vg        realtime_indicator.xml layout
     * @param lineColor resource code color to be used as line color, or null to use the default
     *                  colors
     * @param fillColor resource code color to be used as fill color, or null to use the default
     *                  colors
     */
    public static void setRealtimeIndicatorColorByResourceCode(ViewGroup vg, Integer lineColor,
            Integer fillColor) {
<span class="fc" id="L1335">        Resources r = vg.getResources();</span>
<span class="fc" id="L1336">        setRealtimeIndicatorColor(vg, r.getColor(lineColor), r.getColor(fillColor));</span>
<span class="fc" id="L1337">    }</span>

    /**
     * Sets the line and fill colors for real-time indicator circles contained in the provided
     * realtime_indicator.xml layout.  There are several circles, so each needs to be set
     * individually.  The integer representation of the color to be used should be provided.
     *
     * @param vg        realtime_indicator.xml layout
     * @param lineColor color to be used as line color, or null to use the default colors
     * @param fillColor color to be used as fill color, or null to use the default colors
     */
    public static void setRealtimeIndicatorColor(ViewGroup vg, Integer lineColor,
            Integer fillColor) {
<span class="fc bfc" id="L1350" title="All 2 branches covered.">        for (int i = 0; i &lt; vg.getChildCount(); i++) {</span>
<span class="fc" id="L1351">            View v = vg.getChildAt(i);</span>
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">            if (v instanceof RealtimeIndicatorView) {</span>
<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">                if (lineColor != null) {</span>
<span class="fc" id="L1354">                    ((RealtimeIndicatorView) v).setLineColor(lineColor);</span>
                } else {
                    // Use default color
<span class="nc" id="L1357">                    ((RealtimeIndicatorView) v).setLineColor(</span>
                            R.color.realtime_indicator_line);
                }
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">                if (fillColor != null) {</span>
<span class="fc" id="L1361">                    ((RealtimeIndicatorView) v).setFillColor(fillColor);</span>
                } else {
                    // Use default color
<span class="nc" id="L1364">                    ((RealtimeIndicatorView) v).setLineColor(</span>
                            R.color.realtime_indicator_fill);
                }
            }
        }
<span class="fc" id="L1369">    }</span>

    /**
     * Creates a new Bitmap, with the black color of the source image changed to the given color.
     * The source Bitmap isn't modified.
     *
     * @param source the source Bitmap with a black background
     * @param color  the color to change the black color to
     * @return the resulting Bitmap that has the black changed to the color
     */
    public static Bitmap colorBitmap(Bitmap source, int color) {
<span class="nc" id="L1380">        int width = source.getWidth();</span>
<span class="nc" id="L1381">        int height = source.getHeight();</span>
<span class="nc" id="L1382">        int[] pixels = new int[width * height];</span>
<span class="nc" id="L1383">        source.getPixels(pixels, 0, width, 0, 0, width, height);</span>

<span class="nc bnc" id="L1385" title="All 2 branches missed.">        for (int x = 0; x &lt; pixels.length; ++x) {</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">            pixels[x] = (pixels[x] == Color.BLACK) ? color : pixels[x];</span>
        }

<span class="nc" id="L1389">        Bitmap out = Bitmap.createBitmap(width, height, source.getConfig());</span>
<span class="nc" id="L1390">        out.setPixels(pixels, 0, width, 0, 0, width, height);</span>
<span class="nc" id="L1391">        return out;</span>
    }

    /**
     * Returns true if the provided touch event was within the provided view
     *
     * @return true if the provided touch event was within the provided view
     */
    public static boolean isTouchInView(View view, MotionEvent event) {
<span class="nc" id="L1400">        Rect rect = new Rect();</span>
<span class="nc" id="L1401">        view.getGlobalVisibleRect(rect);</span>
<span class="nc" id="L1402">        return rect.contains((int) event.getRawX(), (int) event.getRawY());</span>
    }

    /**
     * Returns the current time for comparison against another current time.  For API levels &gt;=
     * Jelly Bean MR1 the SystemClock.getElapsedRealtimeNanos() method is used, and for API levels
     * &lt;
     * Jelly Bean MR1 System.currentTimeMillis() is used.
     *
     * @return the current time for comparison against another current time, in nanoseconds
     */
    public static long getCurrentTimeForComparison() {
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {</span>
            // Use elapsed real-time nanos, since its guaranteed monotonic
<span class="nc" id="L1416">            return SystemClock.elapsedRealtimeNanos();</span>
        } else {
<span class="nc" id="L1418">            return TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis());</span>
        }
    }

    /**
     * Open the soft keyboard
     */
    public static void openKeyboard(Context context) {
<span class="nc" id="L1426">        InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(</span>
                Context.INPUT_METHOD_SERVICE);
<span class="nc" id="L1428">        inputMethodManager.toggleSoftInput(InputMethodManager.SHOW_FORCED,</span>
                InputMethodManager.HIDE_NOT_ALWAYS);
<span class="nc" id="L1430">    }</span>

    /**
     * Closes the soft keyboard
     */
    public static void closeKeyboard(Context context, View v) {
<span class="nc" id="L1436">        InputMethodManager imm =</span>
<span class="nc" id="L1437">                (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);</span>
<span class="nc" id="L1438">        imm.hideSoftInputFromWindow(v.getWindowToken(), 0);</span>
<span class="nc" id="L1439">    }</span>

    /**
     * Returns a list of all situations (service alerts) that are specific to the stop, routes, and
     * agency for the provided arrivals-and-departures-for-stop response.  For route-specific alerts, this
     * involves looping through the routes and checking the references element to see if there are
     * any route-specific alerts, and adding them to the list to be shown above the list of
     * arrivals for a stop.  See #700.
     *
     * @param response response from arrivals-and-departures-for-stop API
     * @param filter   list of route_ids to retrieve service alerts for, or null to retrieve service
     *                 alerts for all routes. Note that this filter only affects alerts scoped to
     *                 routes - it does not affect alerts scoped to stops or agencies
     * @return a list of all situations (service alerts) that are specific to the stop, routes, and
     * agency. If a route filter list is provided, situations for all stops and agencies are included
     * in the returned list, but only situations scoped for route_ids in the provided filter list are
     * included in the returned list (i.e., situations specified for route_ids that aren't in the
     * filter list are excluded).
     */
    public static List&lt;ObaSituation&gt; getAllSituations(final ObaArrivalInfoResponse response, List&lt;String&gt; filter) {
<span class="fc" id="L1459">        List&lt;ObaSituation&gt; allSituations = new ArrayList&lt;&gt;();</span>
        // Add agency-wide and stop-specific alerts
<span class="fc" id="L1461">        allSituations.addAll(response.getSituations());</span>

        // Add all existing Ids to a HashSet for O(1) retrieval (vs. list)
<span class="fc" id="L1464">        HashSet&lt;String&gt; allIds = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1465" title="All 2 branches covered.">        for (ObaSituation s : allSituations) {</span>
<span class="fc" id="L1466">            allIds.add(s.getId());</span>
<span class="fc" id="L1467">        }</span>

        // Do the same for filtered routes
<span class="fc" id="L1470">        HashSet&lt;String&gt; filterIds = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L1471" title="1 of 4 branches missed.">        if (filter != null &amp;&amp; !filter.isEmpty()) {</span>
<span class="fc bfc" id="L1472" title="All 2 branches covered.">            for (String routeId : filter) {</span>
<span class="fc" id="L1473">                filterIds.add(routeId);</span>
<span class="fc" id="L1474">            }</span>
        }

        // Scan through the routes, and if a route-specific situation hasn't been added yet, add it
        // If a filter list exists and a route_id is not included in the filter list, don't included
        // it's situations in the returned list.
<span class="fc" id="L1480">        ObaArrivalInfo[] info = response.getArrivalInfo();</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">        for (ObaArrivalInfo i : info) {</span>
<span class="fc bfc" id="L1482" title="All 4 branches covered.">            if (filterIds.isEmpty() || filterIds.contains(i.getRouteId())) {</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">                for (String situationId : i.getSituationIds()) {</span>
<span class="fc bfc" id="L1484" title="All 2 branches covered.">                    if (!allIds.contains(situationId)) {</span>
<span class="fc" id="L1485">                        allIds.add(situationId);</span>
<span class="fc" id="L1486">                        allSituations.add(response.getSituation(situationId));</span>
                    }
                }
            }
        }
<span class="fc" id="L1491">        return allSituations;</span>
    }

    /**
     * Returns true if the provided currentTime falls within the situation's (i.e., alert's) active
     * windows or if the situation does not provide an active window, and false if the currentTime
     * falls outside of the situation's active windows
     *
     * @param currentTime the time to compare to the situation's windows, in milliseconds between
     *                    the current time and midnight, January 1, 1970 UTC
     * @return true if the provided currentTime falls within the situation's (i.e., alert's) active
     * windows or if the situation does not provide an active window, and false if the currentTime
     * falls outside of the situation's active windows
     */
    public static boolean isActiveWindowForSituation(ObaSituation situation, long currentTime) {
<span class="fc bfc" id="L1506" title="All 2 branches covered.">        if (situation.getActiveWindows().length == 0) {</span>
            // We assume a situation is active if it doesn't contain any active window information
<span class="fc" id="L1508">            return true;</span>
        }
        // Active window times are in seconds since epoch
<span class="fc" id="L1511">        long currentTimeSeconds = TimeUnit.MILLISECONDS.toSeconds(currentTime);</span>
<span class="fc" id="L1512">        boolean isActiveWindowForSituation = false;</span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">        for (ObaSituation.ActiveWindow activeWindow : situation.getActiveWindows()) {</span>
<span class="fc" id="L1514">            long from = activeWindow.getFrom();</span>
<span class="fc" id="L1515">            long to = activeWindow.getTo();</span>
            // 0 is a valid end time that means no end to the window - see #990
<span class="fc bfc" id="L1517" title="All 6 branches covered.">            if (from &lt;= currentTimeSeconds &amp;&amp; (to == 0 || currentTimeSeconds &lt;= to)) {</span>
<span class="fc" id="L1518">                isActiveWindowForSituation = true;</span>
<span class="fc" id="L1519">                break;</span>
            }
        }
<span class="fc" id="L1522">        return isActiveWindowForSituation;</span>
    }

    /**
     * Returns the time formatting as &quot;1:10pm&quot; to be displayed as an absolute time for an
     * arrival/departure
     *
     * @param time an arrival or departure time (e.g., from ArrivalInfo)
     * @return the time formatting as &quot;1:10pm&quot; to be displayed as an absolute time for an
     * arrival/departure
     */
    public static String formatTime(Context context, long time) {
<span class="fc" id="L1534">        return DateUtils.formatDateTime(context,</span>
                time,
                DateUtils.FORMAT_SHOW_TIME |
                        DateUtils.FORMAT_NO_NOON |
                        DateUtils.FORMAT_NO_MIDNIGHT
        );
    }

    /**
     * Set smaller text size if the route short name has more than 3 characters
     *
     * @param view Text view
     * @param routeShortName Route short name
     */
    public static void maybeShrinkRouteName(Context context, TextView view, String routeShortName) {
<span class="fc bfc" id="L1549" title="All 2 branches covered.">        if (routeShortName.length() &lt; 4) {</span>
            // No-op if text is short enough to fit
<span class="fc" id="L1551">            return;</span>
<span class="fc bfc" id="L1552" title="All 2 branches covered.">        } else if (routeShortName.length() == 4) {</span>
<span class="fc" id="L1553">            view.setTextSize(TypedValue.COMPLEX_UNIT_PX, context.getResources().</span>
<span class="fc" id="L1554">                    getDimension(R.dimen.route_name_text_size_medium));</span>
<span class="pc bpc" id="L1555" title="1 of 2 branches missed.">        } else if (routeShortName.length() &gt; 4) {</span>
<span class="fc" id="L1556">            view.setTextSize(TypedValue.COMPLEX_UNIT_PX, context.getResources().</span>
<span class="fc" id="L1557">                    getDimension(R.dimen.route_name_text_size_small));</span>
        }
<span class="fc" id="L1559">    }</span>

    /**
     * Transforms a given opaque color into the same color but with the given alpha value
     *
     * @param solidColor hex color value that is completely opaque
     * @param alpha      Specify an alpha value. 0 means fully transparent, and 255 means fully
     *                   opaque.
     * @return the provided color with the given alpha value
     */
    public static int getTransparentColor(int solidColor, int alpha) {
<span class="fc" id="L1570">        int r = Color.red(solidColor);</span>
<span class="fc" id="L1571">        int g = Color.green(solidColor);</span>
<span class="fc" id="L1572">        int b = Color.blue(solidColor);</span>
<span class="fc" id="L1573">        return Color.argb(alpha, r, g, b);</span>
    }

    /**
     * Returns the location of the map center if it has been previously saved in the bundle, or
     * null if it wasn't saved in the bundle.
     *
     * @param b bundle to check for the map center
     * @return the location of the map center if it has been previously saved in the bundle, or null
     * if it wasn't saved in the bundle.
     */
    public static Location getMapCenter(Bundle b) {
<span class="fc bfc" id="L1585" title="All 2 branches covered.">        if (b == null) {</span>
<span class="fc" id="L1586">            return null;</span>
        }
<span class="fc" id="L1588">        Location center = null;</span>
<span class="fc" id="L1589">        double lat = b.getDouble(MapParams.CENTER_LAT);</span>
<span class="fc" id="L1590">        double lon = b.getDouble(MapParams.CENTER_LON);</span>

<span class="pc bpc" id="L1592" title="1 of 4 branches missed.">        if (lat != 0.0 &amp;&amp; lon != 0.0) {</span>
<span class="fc" id="L1593">            center = LocationUtils.makeLocation(lat, lon);</span>
        }
<span class="fc" id="L1595">        return center;</span>
    }

    /**
     * Creates a JPEG image file with the current date/time as the name
     *
     * @param nameSuffix A string that will be added to the end of the file name, or null if
     *                   nothing
     *                   should be added
     * @return a JPEG image file with the current date/time as the name
     */
    public static File createImageFile(Context context, String nameSuffix) throws IOException {
        // Create an image file name
<span class="nc" id="L1608">        String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());</span>
<span class="nc" id="L1609">        StringBuilder imageFileName = new StringBuilder();</span>
<span class="nc" id="L1610">        imageFileName.append(&quot;JPEG_&quot;);</span>
<span class="nc" id="L1611">        imageFileName.append(timeStamp);</span>
<span class="nc" id="L1612">        imageFileName.append(&quot;_&quot;);</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">        if (nameSuffix != null) {</span>
<span class="nc" id="L1614">            imageFileName.append(nameSuffix);</span>
        }
<span class="nc" id="L1616">        File storageDir = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES);</span>
<span class="nc" id="L1617">        return File.createTempFile(</span>
<span class="nc" id="L1618">                imageFileName.toString(),  /* prefix */</span>
                &quot;.jpg&quot;,         /* suffix */
                storageDir      /* directory */
        );
    }

    /**
     * Decode a smaller sampled bitmap given a large bitmap.
     * Adapted from https://developer.android.com/training/displaying-bitmaps/load-bitmap.html and
     * http://stackoverflow.com/a/31720143/937715.
     *
     * @param pathName  path to the full size image file
     * @param reqWidth  desired width
     * @param reqHeight desired height
     * @return a smaller version of the image at pathName, given the desired width and height
     */
    public static Bitmap decodeSampledBitmapFromFile(String pathName, int reqWidth, int reqHeight)
            throws IOException {
        // First decode with inJustDecodeBounds=true to check dimensions
<span class="nc" id="L1637">        final BitmapFactory.Options options = new BitmapFactory.Options();</span>
<span class="nc" id="L1638">        options.inJustDecodeBounds = true;</span>
<span class="nc" id="L1639">        BitmapFactory.decodeFile(pathName, options);</span>

        // Calculate inSampleSize
<span class="nc" id="L1642">        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span>

        // Decode bitmap with inSampleSize set
<span class="nc" id="L1645">        options.inJustDecodeBounds = false;</span>

<span class="nc" id="L1647">        Bitmap b = BitmapFactory.decodeFile(pathName, options);</span>
<span class="nc" id="L1648">        return rotateImageIfRequired(b, pathName);</span>
    }

    /**
     * Calculate an inSampleSize for use in a {@link BitmapFactory.Options} object when decoding
     * bitmaps using the decode* methods from {@link BitmapFactory}. This implementation calculates
     * the closest inSampleSize that will result in the final decoded bitmap having a width and
     * height equal to or larger than the requested width and height. This implementation does not
     * ensure a power of 2 is returned for inSampleSize which can be faster when decoding but
     * results in a larger bitmap which isn't as useful for caching purposes.
     *
     * From http://stackoverflow.com/a/31720143/937715.
     *
     * @param options   An options object with out* params already populated (run through a decode*
     *                  method with inJustDecodeBounds==true
     * @param reqWidth  The requested width of the resulting bitmap
     * @param reqHeight The requested height of the resulting bitmap
     * @return The value to be used for inSampleSize
     */
    private static int calculateInSampleSize(BitmapFactory.Options options,
            int reqWidth, int reqHeight) {
        // Raw height and width of image
<span class="nc" id="L1670">        final int height = options.outHeight;</span>
<span class="nc" id="L1671">        final int width = options.outWidth;</span>
<span class="nc" id="L1672">        int inSampleSize = 1;</span>

<span class="nc bnc" id="L1674" title="All 4 branches missed.">        if (height &gt; reqHeight || width &gt; reqWidth) {</span>
            // Calculate ratios of height and width to requested height and width
<span class="nc" id="L1676">            final int heightRatio = Math.round((float) height / (float) reqHeight);</span>
<span class="nc" id="L1677">            final int widthRatio = Math.round((float) width / (float) reqWidth);</span>

            // Choose the smallest ratio as inSampleSize value, this will guarantee a final image
            // with both dimensions larger than or equal to the requested height and width.
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;</span>

            // This offers some additional logic in case the image has a strange
            // aspect ratio. For example, a panorama may have a much larger
            // width than height. In these cases the total pixels might still
            // end up being too large to fit comfortably in memory, so we should
            // be more aggressive with sample down the image (=larger inSampleSize).

<span class="nc" id="L1689">            final float totalPixels = width * height;</span>

            // Anything more than 2x the requested pixels we'll sample down further
<span class="nc" id="L1692">            final float totalReqPixelsCap = reqWidth * reqHeight * 2;</span>

<span class="nc bnc" id="L1694" title="All 2 branches missed.">            while (totalPixels / (inSampleSize * inSampleSize) &gt; totalReqPixelsCap) {</span>
<span class="nc" id="L1695">                inSampleSize++;</span>
            }
        }
<span class="nc" id="L1698">        return inSampleSize;</span>
    }

    /**
     * Rotate an image if required.
     *
     * @param img       The image bitmap
     * @param imagePath Path to image
     * @return The resulted Bitmap after manipulation
     */
    private static Bitmap rotateImageIfRequired(Bitmap img, String imagePath) throws IOException {
<span class="nc" id="L1709">        ExifInterface ei = new ExifInterface(imagePath);</span>
<span class="nc" id="L1710">        int orientation = ei</span>
<span class="nc" id="L1711">                .getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span>

<span class="nc bnc" id="L1713" title="All 4 branches missed.">        switch (orientation) {</span>
            case ExifInterface.ORIENTATION_ROTATE_90:
<span class="nc" id="L1715">                return rotateImage(img, 90);</span>
            case ExifInterface.ORIENTATION_ROTATE_180:
<span class="nc" id="L1717">                return rotateImage(img, 180);</span>
            case ExifInterface.ORIENTATION_ROTATE_270:
<span class="nc" id="L1719">                return rotateImage(img, 270);</span>
            default:
<span class="nc" id="L1721">                return img;</span>
        }
    }

    /**
     * Rotate the given bitmap
     *
     * @param img    image to rotate
     * @param degree number of degrees to rotate, from 0-360
     * @return the provided bitmap rotated by the given number of degrees
     */
    private static Bitmap rotateImage(Bitmap img, int degree) {
<span class="nc" id="L1733">        Matrix matrix = new Matrix();</span>
<span class="nc" id="L1734">        matrix.postRotate(degree);</span>
<span class="nc" id="L1735">        Bitmap rotatedImg = Bitmap</span>
<span class="nc" id="L1736">                .createBitmap(img, 0, 0, img.getWidth(), img.getHeight(), matrix, true);</span>
<span class="nc" id="L1737">        img.recycle();</span>
<span class="nc" id="L1738">        return rotatedImg;</span>
    }

    /**
     * Launches the fare payment app for the currently selected region if the payment app is
     * installed, otherwise directs the user to the Google Play store listing to download it.  If
     * a region has a fare payment app warning, it will show the warning before checking if the app
     * is installed, unless the user has opted out of the warning.
     * If the current region is null (i.e., if a custom API URL is entered), then no-op.
     * @param activity activity to launch the fare payment app or Google Play store from
     */
    public static void launchPayMyFareApp(@NonNull Activity activity) {
<span class="nc" id="L1750">        ObaRegion region = Application.get().getCurrentRegion();</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (region == null) {</span>
            // If a custom API URL is set (i.e., no region), then no op
<span class="nc" id="L1753">            return;</span>
        }

<span class="nc bnc" id="L1756" title="All 4 branches missed.">        if (!TextUtils.isEmpty(region.getPaymentWarningTitle()) || !TextUtils.isEmpty(region.getPaymentWarningBody())) {</span>
            // Region has a warning for using the payment app
<span class="nc bnc" id="L1758" title="All 2 branches missed.">            if (!Application.getPrefs().getBoolean(activity.getString(R.string.preference_key_never_show_payment_warning_dialog), false)) {</span>
                // User hasn't opted out of warning dialog yet - show the dialog
<span class="nc" id="L1760">                showPaymentWarningDialog(activity, region);</span>
            } else {
                // User opted out of warning - start the Intent
<span class="nc" id="L1763">                startPaymentIntent(activity, region);</span>
            }
        } else {
            // No payment warning for this region - start the Intent
<span class="nc" id="L1767">            startPaymentIntent(activity, region);</span>
        }
<span class="nc" id="L1769">    }</span>

    /**
     * Launches the payment app for the provided region if it's already installed, and if not
     * directs the user to the listing in Google Play where it can be downloaded
     * @param activity Activity to use to launch the Intent
     * @param region region to launch a payment Intent for
     */
    private static void startPaymentIntent(@NonNull Activity activity, @NonNull ObaRegion region) {
<span class="nc" id="L1778">        PackageManager manager = activity.getPackageManager();</span>
<span class="nc" id="L1779">        Intent intent = manager.getLaunchIntentForPackage(region.getPaymentAndroidAppId());</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (intent != null) {</span>
            // Launch installed app
<span class="nc" id="L1782">            intent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span class="nc" id="L1783">            activity.startActivity(intent);</span>
<span class="nc" id="L1784">            ObaAnalytics.reportUiEvent(FirebaseAnalytics.getInstance(activity),</span>
<span class="nc" id="L1785">                    Application.get().getString(R.string.analytics_label_button_fare_payment),</span>
<span class="nc" id="L1786">                    Application.get().getString(R.string.analytics_label_open_app));</span>
        } else {
            // Go to Play Store listing to download app
<span class="nc" id="L1789">            intent = new Intent(Intent.ACTION_VIEW);</span>
<span class="nc" id="L1790">            intent.setData(Uri.parse(Application.get().getString(R.string.google_play_listing_prefix, region.getPaymentAndroidAppId())));</span>
<span class="nc" id="L1791">            activity.startActivity(intent);</span>
<span class="nc" id="L1792">            ObaAnalytics.reportUiEvent(FirebaseAnalytics.getInstance(activity),</span>
<span class="nc" id="L1793">                    Application.get().getString(R.string.analytics_label_button_fare_payment),</span>
<span class="nc" id="L1794">                    Application.get().getString(R.string.analytics_label_download_app));</span>
        }
<span class="nc" id="L1796">    }</span>

    /**
     * Shows the payment warning to the user for the provided region if the user hasn't already
     * opted out of the warning, and then calls the method to create the correct payment Intent.
     * If the user has opted out of the warning, just call the method to create the payment Intent
     * @param activity Activity to use to launch the Intent
     * @param region region to launch a payment Intent for
     */
    private static void showPaymentWarningDialog(@NonNull Activity activity, @NonNull ObaRegion region) {
<span class="nc" id="L1806">        View view = activity.getLayoutInflater().inflate(R.layout.payment_warning_dialog, null);</span>
<span class="nc" id="L1807">        CheckBox neverShowDialog = view.findViewById(R.id.payment_warning_never_ask_again);</span>
<span class="nc" id="L1808">        TextView warningBody = view.findViewById(R.id.payment_warning_body);</span>

<span class="nc" id="L1810">        neverShowDialog.setOnCheckedChangeListener((compoundButton, isChecked) -&gt; {</span>
            // Save the preference
<span class="nc" id="L1812">            PreferenceUtils.saveBoolean(activity.getString(R.string.preference_key_never_show_payment_warning_dialog), isChecked);</span>
<span class="nc" id="L1813">        });</span>

<span class="nc" id="L1815">        warningBody.setText(region.getPaymentWarningBody());</span>

<span class="nc" id="L1817">        Drawable icon = activity.getResources().getDrawable(android.R.drawable.ic_dialog_alert);</span>
<span class="nc" id="L1818">        DrawableCompat.setTint(icon, activity.getResources().getColor(R.color.alert_icon_error));</span>

<span class="nc" id="L1820">        androidx.appcompat.app.AlertDialog.Builder builder = new androidx.appcompat.app.AlertDialog.Builder(activity)</span>
<span class="nc" id="L1821">                .setTitle(region.getPaymentWarningTitle())</span>
<span class="nc" id="L1822">                .setIcon(icon)</span>
<span class="nc" id="L1823">                .setCancelable(false)</span>
<span class="nc" id="L1824">                .setView(view)</span>
<span class="nc" id="L1825">                .setPositiveButton(R.string.ok,</span>
<span class="nc" id="L1826">                        (dialog, which) -&gt; startPaymentIntent(activity, region)</span>
                );

<span class="nc" id="L1829">        builder.create().show();</span>
<span class="nc" id="L1830">    }</span>

    /**
     * Launches the HOPR bikeshare app for Tampa if the app is installed, otherwise directs the user
     * to the Google Play store listing to download it.
     *
     * @param context context to launch the fare payment app or Google Play store from
     */
    public static void launchTampaHoprApp(@NonNull Context context) {
<span class="nc" id="L1839">        PackageManager manager = context.getPackageManager();</span>
<span class="nc" id="L1840">        Intent intent = manager.getLaunchIntentForPackage(context.getString(R.string.hopr_android_app_id));</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">        if (intent != null) {</span>
            // Launch installed app
<span class="nc" id="L1843">            intent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span class="nc" id="L1844">            context.startActivity(intent);</span>
<span class="nc" id="L1845">            ObaAnalytics.reportUiEvent(FirebaseAnalytics.getInstance(context),</span>
<span class="nc" id="L1846">                    Application.get().getString(R.string.analytics_label_button_bike_share),</span>
<span class="nc" id="L1847">                    Application.get().getString(R.string.analytics_label_open_app));</span>
        } else {
            // Go to Play Store listing to download app
<span class="nc" id="L1850">            intent = new Intent(Intent.ACTION_VIEW);</span>
<span class="nc" id="L1851">            intent.setData(Uri.parse(Application.get().getString(R.string.google_play_listing_prefix, context.getString(R.string.hopr_android_app_id))));</span>
<span class="nc" id="L1852">            context.startActivity(intent);</span>
<span class="nc" id="L1853">            ObaAnalytics.reportUiEvent(FirebaseAnalytics.getInstance(context),</span>
<span class="nc" id="L1854">                    Application.get().getString(R.string.analytics_label_button_bike_share),</span>
<span class="nc" id="L1855">                    Application.get().getString(R.string.analytics_label_download_app));</span>
        }
<span class="nc" id="L1857">    }</span>

    /**
     * Sets the visibility and colors of the silhouettes in the provided occupancy.xml viewgroup
     *  @param v         occupancy.xml layout viewgroup containing the silhouettes
     * @param occupancy the occupancy value to use to set the silhouette visibility
     * @param occupancyState the state of the occupancy to use to set the silhouette color
     */
    public static void setOccupancyVisibilityAndColor(ViewGroup v, Occupancy occupancy, OccupancyState occupancyState) {
<span class="fc" id="L1866">        ImageView silhouette1 = v.findViewById(R.id.silhouette1);</span>
<span class="fc" id="L1867">        silhouette1.setVisibility(View.INVISIBLE);</span>
<span class="fc" id="L1868">        ImageView silhouette2 = v.findViewById(R.id.silhouette2);</span>
<span class="fc" id="L1869">        silhouette2.setVisibility(View.INVISIBLE);</span>
<span class="fc" id="L1870">        ImageView silhouette3 = v.findViewById(R.id.silhouette3);</span>
<span class="fc" id="L1871">        silhouette3.setVisibility(View.INVISIBLE);</span>

        // Hide the entire view group if occupancy is null
<span class="fc bfc" id="L1874" title="All 2 branches covered.">        if (occupancy == null) {</span>
<span class="fc" id="L1875">            v.setVisibility(View.GONE);</span>
<span class="fc" id="L1876">            return;</span>
        } else {
<span class="fc" id="L1878">            v.setVisibility(View.VISIBLE);</span>
        }

<span class="fc" id="L1881">        int silhouetteColor = Application.get().getResources().getColor(R.color.stop_info_occupancy);</span>
<span class="fc" id="L1882">        int backgroundColor = Application.get().getResources().getColor(R.color.stop_info_occupancy_background);</span>
<span class="fc bfc" id="L1883" title="All 2 branches covered.">        if (occupancyState == OccupancyState.HISTORICAL) {</span>
            // Set the alpha for historical occupancy to 60%
<span class="fc" id="L1885">            float alpha = 0.6f;</span>
<span class="fc" id="L1886">            v.setAlpha(alpha);</span>
<span class="fc" id="L1887">            silhouette1.setAlpha(alpha);</span>
<span class="fc" id="L1888">            silhouette2.setAlpha(alpha);</span>
<span class="fc" id="L1889">            silhouette3.setAlpha(alpha);</span>
        }

        // Below switch continues into following cases to minimize number of setVisibility() calls
<span class="fc bfc" id="L1893" title="All 5 branches covered.">        switch (occupancy) {</span>
            case NOT_ACCEPTING_PASSENGERS:
                // 3 icons
            case FULL:
                // 3 icons
            case CRUSHED_STANDING_ROOM_ONLY:
                // 3 icons
<span class="fc" id="L1900">                silhouette3.setVisibility(View.VISIBLE);</span>
            case STANDING_ROOM_ONLY:
                // 2 icons
<span class="fc" id="L1903">                silhouette2.setVisibility(View.VISIBLE);</span>
            case FEW_SEATS_AVAILABLE:
                // 2 icons
<span class="fc" id="L1906">                silhouette2.setVisibility(View.VISIBLE);</span>
            case MANY_SEATS_AVAILABLE:
                // 1 icon
<span class="fc" id="L1909">                silhouette1.setVisibility(View.VISIBLE);</span>
            case EMPTY:
                // 0 icons
        }

        // Set silhouette colors
<span class="fc" id="L1915">        ImageViewCompat.setImageTintList(silhouette1, ColorStateList.valueOf(silhouetteColor));</span>
<span class="fc" id="L1916">        ImageViewCompat.setImageTintList(silhouette2, ColorStateList.valueOf(silhouetteColor));</span>
<span class="fc" id="L1917">        ImageViewCompat.setImageTintList(silhouette3, ColorStateList.valueOf(silhouetteColor));</span>

        // Set background color
<span class="fc" id="L1920">        v.setBackgroundResource(R.drawable.occupancy_background);</span>
<span class="fc" id="L1921">        GradientDrawable d = (GradientDrawable) v.getBackground();</span>
<span class="fc" id="L1922">        d.setColor(backgroundColor);</span>
<span class="fc" id="L1923">    }</span>

    /**
     * Sets the content description of the occupancy view group based on the provided occupancy
     *
     * @param v              occupancy.xml layout viewgroup containing the silhouettes
     * @param occupancy      the occupancy value to use to set the content description
     * @param occupancyState the state of the occupancy
     */
    public static void setOccupancyContentDescription(ViewGroup v, Occupancy occupancy, OccupancyState occupancyState) {
        // Hide the entire view group if occupancy is null
<span class="fc bfc" id="L1934" title="All 2 branches covered.">        if (occupancy == null) {</span>
<span class="fc" id="L1935">            v.setContentDescription(&quot;&quot;);</span>
<span class="fc" id="L1936">            return;</span>
        }

<span class="fc" id="L1939">        int stringId = R.string.historically_full;</span>

        // Below switch continues into following cases to minimize lines of code
<span class="pc bpc" id="L1942" title="1 of 6 branches missed.">        switch (occupancy) {</span>
            case NOT_ACCEPTING_PASSENGERS:
                // &quot;Full&quot;
            case FULL:
                // &quot;Full&quot;
            case CRUSHED_STANDING_ROOM_ONLY:
                // &quot;Full&quot;
<span class="fc bfc" id="L1949" title="All 2 branches covered.">                if (occupancyState == OccupancyState.HISTORICAL) {</span>
<span class="fc" id="L1950">                    stringId = R.string.historically_full;</span>
<span class="fc bfc" id="L1951" title="All 2 branches covered.">                } else if (occupancyState == OccupancyState.REALTIME) {</span>
<span class="fc" id="L1952">                    stringId = R.string.realtime_full;</span>
<span class="pc bpc" id="L1953" title="1 of 2 branches missed.">                } else if (occupancyState == OccupancyState.PREDICTED) {</span>
<span class="fc" id="L1954">                    stringId = R.string.predicted_full;</span>
                }
                break;
            case STANDING_ROOM_ONLY:
                // &quot;Standing room&quot;
<span class="fc bfc" id="L1959" title="All 2 branches covered.">                if (occupancyState == OccupancyState.HISTORICAL) {</span>
<span class="fc" id="L1960">                    stringId = R.string.historically_standing_room;</span>
<span class="fc bfc" id="L1961" title="All 2 branches covered.">                } else if (occupancyState == OccupancyState.REALTIME) {</span>
<span class="fc" id="L1962">                    stringId = R.string.realtime_standing_room;</span>
<span class="pc bpc" id="L1963" title="1 of 2 branches missed.">                } else if (occupancyState == OccupancyState.PREDICTED) {</span>
<span class="fc" id="L1964">                    stringId = R.string.predicted_standing_room;</span>
                }
                break;
            case FEW_SEATS_AVAILABLE:
                // &quot;Few seats available&quot;
<span class="fc bfc" id="L1969" title="All 2 branches covered.">                if (occupancyState == OccupancyState.HISTORICAL) {</span>
<span class="fc" id="L1970">                    stringId = R.string.historically_few_seats_available;</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">                } else if (occupancyState == OccupancyState.REALTIME) {</span>
<span class="fc" id="L1972">                    stringId = R.string.realtime_few_seats_available;</span>
<span class="pc bpc" id="L1973" title="1 of 2 branches missed.">                } else if (occupancyState == OccupancyState.PREDICTED) {</span>
<span class="fc" id="L1974">                    stringId = R.string.predicted_few_seats_available;</span>
                }
                break;
            case MANY_SEATS_AVAILABLE:
                // &quot;Many seats available&quot;
<span class="fc bfc" id="L1979" title="All 2 branches covered.">                if (occupancyState == OccupancyState.HISTORICAL) {</span>
<span class="fc" id="L1980">                    stringId = R.string.historically_many_seats_available;</span>
<span class="fc bfc" id="L1981" title="All 2 branches covered.">                } else if (occupancyState == OccupancyState.REALTIME) {</span>
<span class="fc" id="L1982">                    stringId = R.string.realtime_many_seats_available;</span>
<span class="pc bpc" id="L1983" title="1 of 2 branches missed.">                } else if (occupancyState == OccupancyState.PREDICTED) {</span>
<span class="fc" id="L1984">                    stringId = R.string.predicted_many_seats_available;</span>
                }
                break;
            case EMPTY:
                // &quot;Empty&quot;
<span class="fc bfc" id="L1989" title="All 2 branches covered.">                if (occupancyState == OccupancyState.HISTORICAL) {</span>
<span class="fc" id="L1990">                    stringId = R.string.historically_empty;</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">                } else if (occupancyState == OccupancyState.REALTIME) {</span>
<span class="fc" id="L1992">                    stringId = R.string.realtime_empty;</span>
<span class="pc bpc" id="L1993" title="1 of 2 branches missed.">                } else if (occupancyState == OccupancyState.PREDICTED) {</span>
<span class="fc" id="L1994">                    stringId = R.string.predicted_empty;</span>
                }
                break;
        }

<span class="fc" id="L1999">        v.setContentDescription(Application.get().getString(stringId));</span>
<span class="fc" id="L2000">    }</span>

    /**
     * Asks the user to whitelist the application for energy restrictions (e.g., running in
     * the background). See https://developer.android.com/training/monitoring-device-state/doze-standby#support_for_other_use_cases
     *
     * @param activity
     */
    public static void openBatteryIgnoreIntent(Activity activity) {
<span class="nc" id="L2009">        Intent intent = new Intent();</span>
<span class="nc" id="L2010">        intent.setAction(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);</span>
<span class="nc" id="L2011">        intent.setData(Uri.parse(&quot;package:&quot; + activity.getPackageName()));</span>
<span class="nc" id="L2012">        activity.startActivity(intent);</span>
<span class="nc" id="L2013">    }</span>

    public static void setAppTheme(String themeValue) {
<span class="nc bnc" id="L2016" title="All 2 branches missed.">        if (themeValue.equalsIgnoreCase(Application.get().getString(R.string.preferences_app_theme_option_system_default))) {</span>
<span class="nc" id="L2017">            AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);</span>
        }
<span class="nc bnc" id="L2019" title="All 2 branches missed.">        if (themeValue.equalsIgnoreCase(Application.get().getString(R.string.preferences_app_theme_option_dark))) {</span>
<span class="nc" id="L2020">            AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);</span>
        }
<span class="nc bnc" id="L2022" title="All 2 branches missed.">        if (themeValue.equalsIgnoreCase(Application.get().getString(R.string.preferences_app_theme_option_light))) {</span>
<span class="nc" id="L2023">            AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);</span>
        }
<span class="nc" id="L2025">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.2.0</div></body></html>