<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RealtimeService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">obaGoogleDebug</a> &gt; <a href="index.source.html" class="el_package">org.onebusaway.android.directions.realtime</a> &gt; <span class="el_source">RealtimeService.java</span></div><h1>RealtimeService.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2016 Cambridge Systematics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.onebusaway.android.directions.realtime;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.IntentService;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.util.Log;

import androidx.core.app.NotificationCompat;

import org.onebusaway.android.R;
import org.onebusaway.android.app.Application;
import org.onebusaway.android.directions.model.ItineraryDescription;
import org.onebusaway.android.directions.tasks.TripRequest;
import org.onebusaway.android.directions.util.OTPConstants;
import org.onebusaway.android.directions.util.TripRequestBuilder;
import org.opentripplanner.api.model.Itinerary;
import org.opentripplanner.api.model.Leg;
import org.opentripplanner.api.model.TripPlan;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

/**
 * This service is started after a trip is planned by the user so they can be notified if the
 * trip results for their request change in the near future. For example, if a user plans a trip,
 * and then the top result for that trip gets delayed by 20 minutes, the user will be notified
 * that new trip results are available.
 */
public class RealtimeService extends IntentService {

    private static final String TAG = &quot;RealtimeService&quot;;

    private static final String ITINERARY_DESC = &quot;.ItineraryDesc&quot;;
    private static final String ITINERARY_END_DATE = &quot;.ItineraryEndDate&quot;;

    public RealtimeService() {
<span class="nc" id="L61">        super(&quot;RealtimeService&quot;);</span>
<span class="nc" id="L62">    }</span>

    /**
     * Start realtime updates.
     *
     * @param source Activity from which updates are started
     * @param bundle Bundle with selected itinerary/parameters
     */
    public static void start(Activity source, Bundle bundle) {

<span class="nc" id="L72">        SharedPreferences prefs = Application.getPrefs();</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (!prefs.getBoolean(OTPConstants.PREFERENCE_KEY_LIVE_UPDATES, true)) {</span>
<span class="nc" id="L74">            return;</span>
        }

<span class="nc" id="L77">        bundle.putSerializable(OTPConstants.NOTIFICATION_TARGET, source.getClass());</span>
<span class="nc" id="L78">        Intent intent = new Intent(OTPConstants.INTENT_START_CHECKS);</span>
<span class="nc" id="L79">        intent.putExtras(bundle);</span>
<span class="nc" id="L80">        source.sendBroadcast(intent);</span>
<span class="nc" id="L81">    }</span>

    @Override
    public void onHandleIntent(Intent intent) {
<span class="nc" id="L85">        Bundle bundle = intent.getExtras();</span>

<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (intent.getAction().equals(OTPConstants.INTENT_START_CHECKS)) {</span>
<span class="nc" id="L88">            disableListenForTripUpdates();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (!rescheduleRealtimeUpdates(bundle)) {</span>
<span class="nc" id="L90">                Itinerary itinerary = getItinerary(bundle);</span>
<span class="nc" id="L91">                startRealtimeUpdates(bundle, itinerary);</span>
<span class="nc" id="L92">            }</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        } else if (intent.getAction().equals(OTPConstants.INTENT_CHECK_TRIP_TIME)) {</span>
<span class="nc" id="L94">            checkForItineraryChange(bundle);</span>
        }

<span class="nc" id="L97">        RealtimeWakefulReceiver.completeWakefulIntent(intent);</span>
<span class="nc" id="L98">    }</span>

    // Depending on preferences / whether there is realtime info, start updates.
    private void startRealtimeUpdates(Bundle params, Itinerary itinerary) {

<span class="nc" id="L103">        Log.d(TAG, &quot;Checking whether to start realtime updates.&quot;);</span>

<span class="nc" id="L105">        boolean realtimeLegsOnItineraries = false;</span>

<span class="nc bnc" id="L107" title="All 2 branches missed.">        for (Leg leg : itinerary.legs) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (leg.realTime) {</span>
<span class="nc" id="L109">                realtimeLegsOnItineraries = true;</span>
            }
<span class="nc" id="L111">        }</span>

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (realtimeLegsOnItineraries) {</span>
<span class="nc" id="L114">            Log.d(TAG, &quot;Starting realtime updates for itinerary&quot;);</span>

            // init alarm mgr
<span class="nc" id="L117">            getAlarmManager().setInexactRepeating(AlarmManager.RTC, new Date().getTime(),</span>
<span class="nc" id="L118">                    OTPConstants.DEFAULT_UPDATE_INTERVAL_TRIP_TIME, getAlarmIntent(params));</span>
        } else {
<span class="nc" id="L120">            Log.d(TAG, &quot;No realtime legs on itinerary&quot;);</span>
        }

<span class="nc" id="L123">    }</span>

    /**
     * Check to see if the start of real-time trip updates should be rescheduled, and if necessary
     * reschedule it
     *
     * @param bundle trip details to be passed to TripRequestBuilder constructor
     * @return true if the start of trip real-time updates has been rescheduled, false if updates
     * should begin immediately
     */
    private boolean rescheduleRealtimeUpdates(Bundle bundle) {
        // Delay if this trip doesn't start for at least an hour
<span class="nc" id="L135">        Date start = new TripRequestBuilder(bundle).getDateTime();</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (start == null) {</span>
            // To avoid NPE, return true to say that it's been rescheduled, but don't actually reschedule it
            // FIXME - Figure out why sometimes the bundle is empty - see #790 and #791
<span class="nc" id="L139">            return true;</span>
        }
<span class="nc" id="L141">        Date queryStart = new Date(start.getTime() - OTPConstants.REALTIME_SERVICE_QUERY_WINDOW);</span>
<span class="nc" id="L142">        boolean reschedule = new Date().before(queryStart);</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (reschedule) {</span>
<span class="nc" id="L145">            Log.d(TAG, &quot;Start service at &quot; + queryStart);</span>
<span class="nc" id="L146">            Intent future = new Intent(OTPConstants.INTENT_START_CHECKS);</span>
<span class="nc" id="L147">            future.putExtras(bundle);</span>

            int flags;
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {</span>
<span class="nc" id="L151">                flags = PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_MUTABLE;</span>
            } else {
<span class="nc" id="L153">                flags = PendingIntent.FLAG_CANCEL_CURRENT;</span>
            }
<span class="nc" id="L155">            PendingIntent pendingIntent = PendingIntent.getBroadcast(getApplicationContext(),</span>
                    0, future, flags);
<span class="nc" id="L157">            getAlarmManager().set(AlarmManager.RTC_WAKEUP, queryStart.getTime(), pendingIntent);</span>
        }

<span class="nc" id="L160">        return reschedule;</span>
    }

    private void checkForItineraryChange(final Bundle bundle) {
<span class="nc" id="L164">        TripRequestBuilder builder = TripRequestBuilder.initFromBundleSimple(bundle);</span>
<span class="nc" id="L165">        ItineraryDescription desc = getItineraryDescription(bundle);</span>
<span class="nc" id="L166">        Class target = getNotificationTarget(bundle);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L168">            disableListenForTripUpdates();</span>
<span class="nc" id="L169">            return;</span>
        }
<span class="nc" id="L171">        checkForItineraryChange(target, builder, desc);</span>
<span class="nc" id="L172">    }</span>

    private void checkForItineraryChange(final Class&lt;? extends Activity&gt; source, final TripRequestBuilder builder, final ItineraryDescription itineraryDescription) {

<span class="nc" id="L176">        Log.d(TAG, &quot;Check for change&quot;);</span>

<span class="nc" id="L178">        TripRequest.Callback callback = new TripRequest.Callback() {</span>
            @Override
            public void onTripRequestComplete(TripPlan tripPlan, String url) {
<span class="nc bnc" id="L181" title="All 6 branches missed.">                if (tripPlan == null || tripPlan.itineraries == null || tripPlan.itineraries.isEmpty()) {</span>
<span class="nc" id="L182">                    onTripRequestFailure(-1, null);</span>
<span class="nc" id="L183">                    return;</span>
                }

                // Check each itinerary. Notify user if our *current* itinerary doesn't exist
                // or has a lower rank.
<span class="nc bnc" id="L188" title="All 2 branches missed.">                for (int i = 0; i &lt; tripPlan.itineraries.size(); i++) {</span>
<span class="nc" id="L189">                    ItineraryDescription other = new ItineraryDescription(tripPlan.itineraries.get(i));</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">                    if (itineraryDescription.itineraryMatches(other)) {</span>

<span class="nc" id="L193">                        long delay = itineraryDescription.getDelay(other);</span>
<span class="nc" id="L194">                        Log.d(TAG, &quot;Schedule deviation on itinerary: &quot; + delay);</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">                        if (Math.abs(delay) &gt; OTPConstants.REALTIME_SERVICE_DELAY_THRESHOLD) {</span>
<span class="nc" id="L197">                            Log.d(TAG, &quot;Notify due to large early/late schedule deviation.&quot;);</span>
<span class="nc" id="L198">                            showNotification(itineraryDescription,</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                                    (delay &gt; 0) ? R.string.trip_plan_delay</span>
<span class="nc" id="L200">                                            : R.string.trip_plan_early,</span>
                                    R.string.trip_plan_notification_new_plan_text,
<span class="nc" id="L202">                                    source, builder.getBundle(), tripPlan.itineraries);</span>
<span class="nc" id="L203">                            disableListenForTripUpdates();</span>
<span class="nc" id="L204">                            return;</span>
                        }

                        // Otherwise, we are still good.
<span class="nc" id="L208">                        Log.d(TAG, &quot;Itinerary exists and no large schedule deviation.&quot;);</span>
<span class="nc" id="L209">                        checkDisableDueToTimeout(itineraryDescription);</span>

<span class="nc" id="L211">                        return;</span>
                    }
                }
<span class="nc" id="L214">                Log.d(TAG, &quot;Did not find a matching itinerary in new call - notify user that something has changed.&quot;);</span>
<span class="nc" id="L215">                showNotification(itineraryDescription,</span>
                        R.string.trip_plan_notification_new_plan_title,
                        R.string.trip_plan_notification_new_plan_text, source,
<span class="nc" id="L218">                        builder.getBundle(), tripPlan.itineraries);</span>
<span class="nc" id="L219">                disableListenForTripUpdates();</span>
<span class="nc" id="L220">            }</span>

            @Override
            public void onTripRequestFailure(int result, String url) {
<span class="nc" id="L224">                Log.e(TAG, &quot;Failure checking itineraries. Result=&quot; + result + &quot;, url=&quot; + url);</span>
<span class="nc" id="L225">                disableListenForTripUpdates();</span>
<span class="nc" id="L226">            }</span>
        };

<span class="nc" id="L229">        builder.setListener(callback);</span>

        try {
<span class="nc" id="L232">            builder.execute();</span>
<span class="nc" id="L233">        } catch (Exception e) {</span>
<span class="nc" id="L234">            e.printStackTrace();</span>
<span class="nc" id="L235">            disableListenForTripUpdates();</span>
<span class="nc" id="L236">        }</span>
<span class="nc" id="L237">    }</span>

    private void showNotification(ItineraryDescription description, int title, int message,
                                  Class&lt;? extends Activity&gt; notificationTarget,
                                  Bundle params, List&lt;Itinerary&gt; itineraries) {

<span class="nc" id="L243">        String titleText = getResources().getString(title);</span>
<span class="nc" id="L244">        String messageText = getResources().getString(message);</span>

<span class="nc" id="L246">        Intent openIntent = new Intent(getApplicationContext(), notificationTarget);</span>
<span class="nc" id="L247">        openIntent.putExtras(params);</span>
<span class="nc" id="L248">        openIntent.putExtra(OTPConstants.INTENT_SOURCE, OTPConstants.Source.NOTIFICATION);</span>
<span class="nc" id="L249">        openIntent.putExtra(OTPConstants.ITINERARIES, (ArrayList&lt;Itinerary&gt;) itineraries);</span>
<span class="nc" id="L250">        openIntent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</span>
        int flags;
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {</span>
<span class="nc" id="L253">            flags = PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_MUTABLE;</span>
        } else {
<span class="nc" id="L255">            flags = PendingIntent.FLAG_CANCEL_CURRENT;</span>
        }
<span class="nc" id="L257">        PendingIntent openPendingIntent = PendingIntent</span>
<span class="nc" id="L258">                .getActivity(getApplicationContext(),</span>
                        0,
                        openIntent,
                        flags);

<span class="nc" id="L263">        NotificationCompat.Builder mBuilder =</span>
<span class="nc" id="L264">                new NotificationCompat.Builder(getApplicationContext(), Application.CHANNEL_TRIP_PLAN_UPDATES_ID)</span>
<span class="nc" id="L265">                        .setSmallIcon(R.drawable.ic_stat_notification)</span>
<span class="nc" id="L266">                        .setContentTitle(titleText)</span>
<span class="nc" id="L267">                        .setStyle(new NotificationCompat.BigTextStyle().bigText(messageText))</span>
<span class="nc" id="L268">                        .setContentText(messageText)</span>
<span class="nc" id="L269">                        .setPriority(NotificationCompat.PRIORITY_MAX)</span>
<span class="nc" id="L270">                        .setContentIntent(openPendingIntent);</span>

<span class="nc" id="L272">        NotificationManager notificationManager =</span>
<span class="nc" id="L273">                (NotificationManager) getApplicationContext()</span>
<span class="nc" id="L274">                        .getSystemService(Context.NOTIFICATION_SERVICE);</span>
<span class="nc" id="L275">        Notification notification = mBuilder.build();</span>
<span class="nc" id="L276">        notification.defaults = Notification.DEFAULT_ALL;</span>
<span class="nc" id="L277">        notification.flags |= Notification.FLAG_AUTO_CANCEL | Notification.FLAG_SHOW_LIGHTS;</span>

<span class="nc" id="L279">        Integer notificationId = description.getId();</span>
<span class="nc" id="L280">        notificationManager.notify(notificationId, notification);</span>
<span class="nc" id="L281">    }</span>

    // If the end time for this itinerary has passed, disable trip updates.
    private void checkDisableDueToTimeout(ItineraryDescription itineraryDescription) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (itineraryDescription.isExpired()) {</span>
<span class="nc" id="L286">            Log.d(TAG, &quot;End of trip has passed.&quot;);</span>
<span class="nc" id="L287">            disableListenForTripUpdates();</span>
        }
<span class="nc" id="L289">    }</span>

    public void disableListenForTripUpdates() {
<span class="nc" id="L292">        Log.d(TAG, &quot;Disable trip updates.&quot;);</span>
<span class="nc" id="L293">        getAlarmManager().cancel(getAlarmIntent(null));</span>
<span class="nc" id="L294">    }</span>


    private AlarmManager getAlarmManager() {
<span class="nc" id="L298">        return (AlarmManager) getApplicationContext().getSystemService(Context.ALARM_SERVICE);</span>
    }

    private PendingIntent getAlarmIntent(Bundle bundle) {
<span class="nc" id="L302">        Intent intent = new Intent(OTPConstants.INTENT_CHECK_TRIP_TIME);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (bundle != null) {</span>
<span class="nc" id="L304">            Bundle extras = getSimplifiedBundle(bundle);</span>
<span class="nc" id="L305">            intent.putExtras(extras);</span>
        }
        int flags;
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.S) {</span>
<span class="nc" id="L309">            flags = PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_MUTABLE;</span>
        } else {
<span class="nc" id="L311">            flags = PendingIntent.FLAG_UPDATE_CURRENT;</span>
        }
<span class="nc" id="L313">        PendingIntent alarmIntent = PendingIntent.getBroadcast(getApplicationContext(), 0, intent,</span>
                flags);
<span class="nc" id="L315">        return alarmIntent;</span>
    }

    private Itinerary getItinerary(Bundle bundle) {
<span class="nc" id="L319">        ArrayList&lt;Itinerary&gt; itineraries = (ArrayList&lt;Itinerary&gt;) bundle</span>
<span class="nc" id="L320">                .getSerializable(OTPConstants.ITINERARIES);</span>
<span class="nc" id="L321">        int i = bundle.getInt(OTPConstants.SELECTED_ITINERARY);</span>
<span class="nc" id="L322">        return itineraries.get(i);</span>
    }

    private ItineraryDescription getItineraryDescription(Bundle bundle) {
<span class="nc" id="L326">        String ids[] = bundle.getStringArray(ITINERARY_DESC);</span>
<span class="nc" id="L327">        long date = bundle.getLong(ITINERARY_END_DATE);</span>
<span class="nc" id="L328">        return new ItineraryDescription(Arrays.asList(ids), new Date(date));</span>
    }

    private Class getNotificationTarget(Bundle bundle) {
<span class="nc" id="L332">        String name = bundle.getString(OTPConstants.NOTIFICATION_TARGET);</span>
        try {
<span class="nc" id="L334">            return Class.forName(name);</span>
<span class="nc" id="L335">        } catch(ClassNotFoundException e) {</span>
<span class="nc" id="L336">            Log.e(TAG, &quot;unable to find class for name &quot; + name);</span>
        }
<span class="nc" id="L338">        return null;</span>
    }

    private Bundle getSimplifiedBundle(Bundle params) {
<span class="nc" id="L342">        Itinerary itinerary = getItinerary(params);</span>
<span class="nc" id="L343">        ItineraryDescription desc = new ItineraryDescription(itinerary);</span>

<span class="nc" id="L345">        Bundle extras = new Bundle();</span>
<span class="nc" id="L346">        new TripRequestBuilder(params).copyIntoBundleSimple(extras);</span>

<span class="nc" id="L348">        List&lt;String&gt; idList = desc.getTripIds();</span>
<span class="nc" id="L349">        String[] ids = idList.toArray(new String[idList.size()]);</span>
<span class="nc" id="L350">        extras.putStringArray(ITINERARY_DESC, ids);</span>
<span class="nc" id="L351">        extras.putLong(ITINERARY_END_DATE, desc.getEndDate().getTime());</span>

<span class="nc" id="L353">        Class&lt;? extends Activity&gt; source = (Class&lt;? extends Activity&gt;)</span>
<span class="nc" id="L354">                params.getSerializable(OTPConstants.NOTIFICATION_TARGET);</span>

<span class="nc" id="L356">        extras.putString(OTPConstants.NOTIFICATION_TARGET, source.getName());</span>

<span class="nc" id="L358">        return extras;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>Generated by the Android Gradle plugin 8.2.0</div></body></html>